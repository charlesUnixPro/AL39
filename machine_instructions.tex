\newcommand{\ins}[3]{
%\resizebox{\linewidth}{!}{
\begin{tabular}{|p{0.2\linewidth}|p{0.6\linewidth}|p{0.2\linewidth}|}
\hline
#1 & #2 & #3 \\
\hline
\end{tabular}
\vskip 1pc
%}
}

% Labeled instruction line
\newcommand{\inlbl}[2]{
\begin{tabular}{p{0.3\linewidth} p{0.7\linewidth}}
#1 & #2 \\
\end{tabular}
\\
}

% Unlabeled instruction line
\newcommand{\inull}[1]{
\inlbl{}{#1}
}

\newcommand{\infmt}[1]{
\inlbl{FORMAT:}{#1} 
}

\newcommand{\inbif}{
\infmt{Basic instruction format (see Figure \ref{f4.1}).}
}

\newcommand{\insum}[1]{
\inlbl{SUMMARY:}{#1}
}

% MODIFICATIONS: #1

\newcommand{\inmod}[1]{
\inlbl{MODIFICATIONS:}{#1} \\
}

% MODIFICATIONS: All except ci, sc, scr

\newcommand{\incss}{
\inmod{All except \texttt{ci}, \texttt{sc}, \texttt{sc}}
}

% MODIFICATIONS: All except du, dl, ci, sc, scr

\newcommand{\indcs}{
\inmod{All except \texttt{du}, \texttt{dl}, \texttt{ci}, \texttt{sc}, \texttt{sc}}
}

% MODIFICATIONS: All except du, dl

\newcommand{\inmul}{
\inmod{All except \texttt{du}, \texttt{dl}}
}

% MODIFICATIONS: All

\newcommand{\inall}{
\inmod{All}
}

% MODIFICATIONS: All, but none affect instruction execution.

\newcommand{\inabn}{
\inmod{All, but none affect instruction execution.}
}

% INDICATORS: #1

\newcommand{\inind}[1]{
\inlbl{INDICATORS:}{#1}
}

% INDICATORS: (Indicators not listed are not affected)

\newcommand{\inina}{
\inind{(Indicators not listed are not affected)}
}

% INDICATORS: None affected

\newcommand{\innaf}{
\inind{None affected}
}


% exponent over/underflow

\newcommand{\ineou}{
\inlbl{\hspace{1em}Exponent}{If exponent is greater than +127, then ON}
\inlbl{\hspace{1em}overflow}{}
\inlbl{\hspace{1em}Exponent}{If exponent is less than -128, then ON}
\inlbl{\hspace{1em}underflow}{}
}

%    Zero #1

\newcommand{\ininz}[1]{
\inlbl{\hspace{1em}Zero}{#1}
}


%    Zero If C(#1) = 0, then ON; otherwise OFF

\newcommand{\ininZ}[1]{
\inlbl{\hspace{1em}Zero}{If C(#1) = 0, then ON; otherwise OFF}
}


%    Negative #1

\newcommand{\ininn}[1]{
\inlbl{\hspace{1em}Negative}{#1}
}

%    Negative If C(#1)0 = 1, then ON; otherwise OFF

\newcommand{\ininN}[1]{
\inlbl{\hspace{1em}Negative}{If C(#1)\textsubscript{0} = 1, then ON; otherwise OFF}
}


%    Overflow #1

\newcommand{\inino}[1]{
\inlbl{\hspace{1em}Overflow}{#1}
}

%    Carry #1

\newcommand{\ininc}[1]{
\inlbl{\hspace{1em}Carry}{#1}
}

% Carry    If a carry out of #10 is generated, then ON; otherwise OFF

\newcommand{\ininC}[1]{
\ininc{If a carry out of #1\tsb{0} is generated, then ON; otherwise OFF}
}


%     Overflow If range of #1 is exceeded, then ON
\newcommand{\ininO}[1]{
\inlbl{\hspace{1em}Overflow}{If range of #1 is exceeded, then ON}
}

%    Parity mask  #1

\newcommand{\inpar}[1]{
\inlbl{\hspace{1em}Parity mask}{#1}
}

%    Not BAR mode  #1

\newcommand{\inbar}[1]{
\inlbl{\hspace{1em}Not BAR mode}{#1}
}

%    Truncation  #1

\newcommand{\intru}[1]{
\inlbl{\hspace{1em}Truncation}{#1}
}

% NOTES: #1

\newcommand{\innte}[1]{
\inlbl{NOTES:}{#1}
}

% NOTES, add'l paragraph

\newcommand{\innta}[1]{
\inull {#1}
}

% NOTES: Attempted repetition with the rpl instruction causes an illegal procedure fault.

\newcommand{\inrpl}[1]{
\innte {Attempted repetition with the rpl instruction causes an illegal procedure fault.}
}

%        Attempted repetition with the rpl instruction causes an illegal procedure fault.

\newcommand{\inrpa}[1]{
\innta {Attempted repetition with the rpl instruction causes an illegal procedure fault.}
}

\newcommand{\inrrr}{
\innte {Attempted repetition with the rpt, rpd, or rpl instructions causes an
illegal procedure fault.}
}

\section{MACHINE INSTRUCTIONS}


This section describes the complete set of machine instructions for the Multics
processor.  The presentation assumes that the reader is familiar with the
general structure of the processor, the representation of information, the data
formats, and the method of address preparation.  Additional information on
these subjects appears near the beginning of this section and in Sections
\ref{s2}, \ref{s3}, \ref{s5}, and \ref{s6}.


\subsection{INSTRUCTION REPERTOIRE}

The processor interprets a 10-bit field of the instruction word as the
operation code. This field size yields 1024 possible instructions of which 547
are implemented. There are 456 basic operations and 91 extended instruction set
(EIS) operations.


\subsubsection{Arrangement of Instructions}

Instructions are presented alphabetically by their mnemonic codes within functional categories. An overall alphabetic listing of instruction codes and their names appears in Appendix \ref{aB}.


\subsubsection{Basic Operations}

The 456 basic operations in the processor all require exactly one 36-bit
machine word.  They are categorized as follows:


\begin{tabular}{ r l }

181 & Fixed-point binary arithmetic \\
85 & Boolean operations\\
34 & Floating-point binary arithmetic \\
36 & Transfer of control \\
75 & Pointer register \\
17 & Miscellaneous \\
28 & Privileged \\
\end{tabular}



\subsubsection{Extended Instruction Set (EIS) Operations}

The 91 extended instruction set (EIS) operations are divided into 62 EIS
single-word instructions and 29 EIS multiword instructions.

\subsubsubsection{EIS Single-Word Operations}


The 62 EIS single-word instructions load, store, and perform special arithmetic
on the address registers (ARn) used to access bit- and character-string
operands, and safe-store decimal unit (DU) control information required to
service a processor fault or interrupt. Like the basic operations, EIS
single-word instructions require exactly one 36-bit machine word.  

\subsubsubsection{EIS Multiword Operations}

The 29 EIS multiword instructions perform decimal arithmetic and bit- and
character-string operations. They require three or four 36-bit machine words
depending on individual operand descriptor requirements.  

\subsection{FORMAT OF INSTRUCTION DESCRIPTION}

Each instruction in the repertoire is described in the following pages of this section. The
descriptions are presented in the format shown below.

\ins {MNEMONIC} {INSTRUCTION NAME} {OPCODE}
\infmt {Figure or figure reference}
\insum {Text and/or bit transfer equations}
\inmod {Text}
\inind {Text and/or logic statements}
\innte {Text}

\paragraph {Line 1: MNEMONIC, INSTRUCTION NAME, OPCODE}
\paragraph {}

This line has three parts that contain the following:

\begin {enumerate}

\item MNEMONIC -- The mnemonic code for the operation field of the assembler statement.
The Multics assembler, ALM, recognizes this character string value and maps it into the
appropriate binary pattern when generating the actual object code.

\item INSTRUCTION NAME -- The name of the machine instruction from which the mnemonic
was derived.

\item OPCODE -- The octal value of the operation code for the instruction. A 0 or a 1 in
parentheses following an octal code indicates whether bit 27 (opcode extension bit) of
the instruction word is OFF or ON.

\end{enumerate}

\paragraph {Line 2: FORMAT}
\paragraph {}

The layout and definition of the subfields of the instruction word or words are given here
either as a figure or as a reference to a figure.

\paragraph {Line 3: SUMMARY}
\paragraph {}

The change in the state of the processor effected by the execution of the instruction is
described in a short, symbolic form. If reference is made to the state of an indicator in the
summary, it is the state of the indicator before the instruction is executed.

\paragraph {Line 4: MODIFICATIONS}
\paragraph {}

Those modifiers that cannot be used with the instruction are listed explicitly as exceptions.
See \ref{s6} for a discussion of address modification.

\paragraph {Line 5: INDICATORS}
\paragraph {}

Only those indicators are listed whose state can be changed by the execution of the
instruction. In most cases, a condition for setting ON as well as one for setting OFF is stated. If
only one of the two is stated, then the indicator remains unchanged if the condition is not met.
Unless stated otherwise, the conditions refer to the contents of registers existing after instruction
execution. Refer also to {``}Common Attributes of Instructions,'' later in this section.

\paragraph {Line 6: NOTES}
\paragraph {}

This part of the description exists only in those cases where the summary is not sufficient
for in-depth understanding of the instruction.

\subsection{DEFINITIONS OF NOTATION AND SYMBOLS}

\subsubsection{Main Memory Addresses}

\inlbl {y}
 {an 18-bit computed address as generated during address preparation.}
\inlbl {Y}
 {a 24-bit main memory address of the instruction operand after all address preparation (including appending) is complete.}
\inlbl {Y-pair}
 {a pair of main memory locations with successive addresses, the smaller
address being even. When Y is even, it designates the pair Y(even), Y+1; and
when it is odd, the pair Y-1, Y(odd). The main memory location with the smaller
(even) address contains the most significant part of a double-word operand or
the first of a pair of instructions.}


\inlbl {Y-blockn}
{a block of main memory locations of 4-, 8-, 16-, or 32-word extent. For a block
of n-word extent, the processor forces Y-blockn to a 0 modulo n address and
performs address incrementing through the block accordingly, stopping when
the address next reaches a value 0 modulo n.}

\inlbl {Y-charnk}
{a character or string of characters in main memory of character size n bits as
operand descriptor k and may have values 4, 6, or 9. See Section 6 for details}

\inlbl {Y-bitk}
{a bit or string of bits in main memory as described by the kth operand
descriptor. See Section 6 for details of operand descriptors.}

\subsubsection{Index Values}

When reference is made to the elements of a string of characters or bits in main memory,
the notation shown in {``}Register Position and Contents'' below is used. The index used to show
traversing a string of extent n may take any of the values in the interval (1,n) unless noted
otherwise. The elements of a main memory block are traversed explicitly by using the index as an
addend to the given block address, (e.g., Y-block8+m and Y-block4+2m+1).


\subsubsection{Abbreviations and Symbols}


\inlbl {A}
{Accumulator register}
\inlbl {ARn}
{Address register n (n = 0, 1, 2, ..., 7)}
\inlbl {AQ}
{Combined accumulator-quotient register}
\inlbl {BAR}
{Base address register}
\inlbl {C( )}
{{``}Contents of''}
\inlbl {CA}
{Computed address}
\inlbl {DSBR}
{Descriptor segment base register}
\inlbl {DSBR.ADDR}
{Address field of DSBR}
\inlbl {DSBR.BND}
{Bound field of DSBR}
\inlbl {DSBR.STACK}
{Stack base field of DSBR}
\inlbl {DSBR.U}
{Unpaged flag of DSBR}
\inlbl {E}
{Exponent register}
\inlbl {EA}
{Combined exponent-accumulator register}
\inlbl {EAQ}
{Combined exponent-accumulator-quotient register}
\inlbl {ERN}
{Effective ring number}
\inlbl {ESN}
{Effective segment number}
\inlbl {IC}
{Instruction counter}
\inlbl {IR}
{Indicator register}
\inlbl {PPR}
{Procedure pointer register}
\inlbl {PPR.PRR}
{Procedure ring register of PPR}
{\inlbl {PPR.PSR}
{Procedure segment register of PPR}
\inlbl {PPR.IC}
{Instruction counter register of PPR (same as IC above)}
\inlbl {PPR.P}
{Privileged flag of PPR}
\inlbl {PRn}
{Pointer register n (n = 0, 1, 2, ..., 7)}
\inlbl {PRn.RNR}
{Ring number register of PRn}
\inlbl {PRn.SNR}
{Segment number register of PRn}
\inlbl {PRn.WORDNO}
{Word address register of PRn}
\inlbl {PRn.CHAR}
{Character address register of PRn}
\inlbl {PRn.BITNO}
{Bit offset register of PRn}
\inlbl {Q}
{Quotient register}
\inlbl {PTWAM}
{Page table word associative memory}
\inlbl {SDWAM}
{Segment descriptor word associative memory}
\inlbl {RALR}
{Ring alarm register}
\inlbl {TPR}
{Temporary pointer register}
\inlbl {TPR.CA}
{Computed address register of TPR (same as CA above)}
\inlbl {TPR.TRR}
{Temporary ring register of TPR}
\inlbl {TPR.TSR}
{Temporary segment register of TPR}
\inlbl {TPR.TBR}
{Temporary bit register of TPR}
\inlbl {TR}
{Timer register}
\inlbl {Xn}
{Index register n (n = 0, 1, 2, ..., 7)}
\inlbl {Z}
{Temporary pseudo-result of a nonstore comparative operation}

\subsubsection{Register Positions and Contents}

In the definitions that follow, {``}R'' stands for any of the registers listed above, as well as for
main memory words, word-pairs, word-blocks, and bit- or character-strings.

\inlbl {R\textsubscript{i}}
{The i\textsuperscript{th} bit, character, or byte position of R}
\inlbl {R(i)}
{The i\textsuperscript{th} register of a set of n registers named R}
\inlbl {R\textsubscript{i,j}}
{The bit, character, or byte positions i through j of R}
\inlbl {C(R)}
{The contents of the full register R}
\inlbl {C(R)\textsubscript{i}}
{The contents of the i\textsuperscript{th} bit, character, or byte of R}
\inlbl {C(R)\textsubscript{i,j}}
{The contents of the bits, characters, or bytes i through j of R}
\inlbl {xx\dots x}
{A string of binary bits (0's or l's) of any necessary length}

When the description of an instruction specifies a change for a part of a register or main
memory location, it is understood that the part of the register or main memory location not
mentioned remains unchanged.

\subsubsection{Other Symbols}

\inlbl {$\rightarrow$}
{replaces}
\inlbl {::}
{compare with}
\inlbl {\&}
{the Boolean connective AND}
\inlbl {$|$}
{the Boolean connective OR}
\inlbl {$\oplus$}
{the Boolean connective NON-EQUIVALENCE (or EXCLUSIVE OR)}
\inlbl {\~{}XXX}
{the logical inverse (ones complement) of the quantity XXX}
\inlbl {$\neq$}
{not equal}
\inlbl {n**m}
{indicates exponentiation (n and m are integers); for example, the fifth power of 2 is represented as 2**5.}
\inlbl {$\times$}
{multiplication; for example, C(Y) times C(Q) is represented as C(Y) $\times$ C(Q)}
\inlbl {/}
{division; for example, C(Y) divided by C(A) is represented as C(Y) / C(A).}
\inlbl {$||$}
{concatenation; for example, string1 $||$ string2.}
\inlbl {$|$\ldots$|$}
{the absolute value of the value between vertical bars (no algebraic sign). For example the absolute value of C(A) plus C(Y) is represented as: $|$ C(A) + C(Y) $|$ .}
\inlbl {C(R)modn}
{A coined notation for remaindering or modulo arithmetic; for example C(REG) modulo 9 is represented as C(REG)\tsb{mod9}}




\subsection{COMMON ATTRIBUTES OF INSTRUCTIONS}

\subsubsection{Illegal Modification}

If an illegal modifier is used with any instruction, an illegal procedure fault with a subcode
class of illegal modifier occurs.

\subsubsection{Parity Indicator}

The parity indicator is turned ON at the end of a main memory access that has incorrect
parity.

\subsection{INSTRUCTION WORD FORMATS}

\subsubsection{Basic and EIS Single-Word Instructions}

The basic instructions and EIS single-word instructions require exactly one 36-bit machine
word and are interpreted according to the format shown in \ref{f4.1}.

\begin{figure}[H]
\begin{center}
\begin{bytefield}{36}
\\
\bitheader{0,17,18,27,28,29,30,35} \\
\bitbox{18}{ADDRESS}
\bitbox{10}{OPCODE}
\bitbox{1}{I}
\bitbox{1}{A}
\bitbox{6}{TAG} \\
\bitbox[]{18}{\hfill\tiny 18}
\bitbox[]{10}{\hfill\tiny 10}
\bitbox[]{1}{\hfill\tiny 1}
\bitbox[]{1}{\hfill\tiny 1}
\bitbox[]{6}{\hfill\tiny 6}
\end{bytefield}
\caption{Basic and EIS Single-Word Instruction Format}
\label{f4.1}
\end{center}
\end{figure}

\inlbl {ADDRESS}{The given address of the operand or indirect word. This address may be:}
\inull {\hspace{1em} An 18-bit absolute main memory address if A = 0 (absolute mode only)}
\inull {\hspace{1em} An 18-bit offset relative to the base address register if A = 0 (BAR mode only)}
\inull {\hspace{1em} An 18-bit offset relative to the base of the current procedure segment if A
= 0 (appending mode only)}
\inull {\hspace{1em} A 3-bit pointer register number (n) and a 15-bit offset relative to
C(PRn.WORDNO) if A = 1 (absolute and appending modes only)}
\inull {\hspace{1em} A 3-bit address register number (n) and a 15-bit offset relative to C(ARn) if
A = 1 (all modes depending on instruction type)}
\inull {\hspace{1em} An 18-bit literal signed or unsigned constant (all modes depending on
instruction type and modifier)}
\inull {\hspace{1em} An 8-bit shift operation count (all modes)}
\inull {\hspace{1em} An 18-bit offset relative to the current value of the instruction counter
C(PPR.IC) (all modes)}

\inlbl {OPCODE}{Instruction operation code.}

\inlbl {I}{Interrupt inhibit bit. When this bit is set ON, the processor will defer all
external interrupt signals. See Section 7 for a discussion of interrupts.}

\inlbl {A}{
Indirect via pointer register flag. See Section 6 for a discussion of the use of
pointer registers.}

\inlbl {TAG}{Instruction address modifier.
See Section 6 for a discussion of address
modification.}

Machine words in this format are generated by ALM in processing the basic and EIS singleword instructions (described later in this section) and the \texttt{arg} pseudo-instruction).

\subsubsection{Indirect Words}

Certain of the basic and EIS single-word instructions permit indirection to be specified as
part of address modification. When such indirection is specified, C(Y) is interpreted as an indirect
word according to the format shown in \ref{f4.2}.

\begin{figure}[H]
\begin{center}
\begin{bytefield}{36}
\\
\bitheader{0,17,18,29,30,35} \\
\bitbox{18}{ADDRESS}
\bitbox{12}{TALLY}
\bitbox{6}{TAG} \\
\bitbox[]{18}{\hfill\tiny 18}
\bitbox[]{12}{\hfill\tiny 12}
\bitbox[]{6}{\hfill\tiny 6}
\end{bytefield}
\caption{Indirect Word Format}
\label{f4.2}
\end{center}
\end{figure}

\inlbl{ADDRESS}{
The given address of the operand or next indirect word. This address may be:}
\inull{\hspace{1em}An 18-bit absolute main memory address if A = 0 in the instruction word
(absolute mode only)}
\inull{\hspace{1em}An 18-bit offset relative to the base address register (BAR) if A = 0 in the
instruction word (BAR mode only)}
\inull{\hspace{1em}An 18-bit offset relative to the base of the segment in which the word
resides if A = 0 (appending mode only)}
\inull{\hspace{1em}Three zero bits and a 15-bit segment number if TAG = (43)8 (ITS
modification) (absolute and appending modes only)}
\inull{\hspace{1em}A 3-bit pointer register number and 15 zero bits if TAG = (41)8 (ITP
modification) (absolute and appending modes only)}

\inlbl{TALLY}{A count field for use by those address modifiers that involve tallying}

\inlbl{TAG}{
This field may be (depending on the TAG value causing the indirection):}
\inull{\hspace{1em}A 6-bit address modifier}
\inull{\hspace{1em}A 6-bit increment to be added to or subtracted from ADDRESS on each
reference}
\inull{\hspace{1em}A 1-bit character mode (6- or 9-bit) flag, two 0 bits, and a 3-bit character
position number}

Machine words in this format may be generated by use of the ALM vfd pseudo-instruction.

\subsubsection{EIS Multiword Instructions}

The EIS multiword instructions require three or four machine words depending on the
operand descriptor requirements of the individual instructions. The words are interpreted
according to the format shown in Figure 4-3. The instruction descriptions (later in this section)
contain ALM coding examples. Refer to the Multics Commands and Active Functions, Order No.
AG92, {``}alm'' command for additional information.

\begin{figure}[H]
\begin{center}
\begin{bytefield}{36}
\\
\bitheader{0,17,18,27,28,29,30,35} \\
\bitbox{18}{VARIABLE}
\bitbox{10}{OPCODE}
\bitbox{1}{I}
\bitbox{7}{MF1} \\
%\bitbox[]{18}{\hfill\tiny 18}
%\bitbox[]{10}{\hfill\tiny 10}
%\bitbox[]{1}{\hfill\tiny 1}
%\bitbox[]{7}{\hfill\tiny 7} \\
%\bitbox{36}{operand descriptor or indirect pointer for operand 1} \\
\wordbox{2}{
\bitbox[]{18}{\hfill\tiny 18}
\bitbox[]{10}{\hfill\tiny 10}
\bitbox[]{1}{\hfill\tiny 1}
\bitbox[]{7}{\hfill\tiny 7} \\
operand descriptor or indirect pointer for operand 1} \\
\bitbox{36}{operand descriptor or indirect pointer for operand 2} \\
\bitbox{36}{operand descriptor or indirect pointer for operand 3} \\
\bitbox[]{36}{\hfill\tiny 36}
\end{bytefield}
\caption{EIS Multiword Instruction Format}
\label{f4.3}
\end{center}
\end{figure}

\inlbl {VARIABLE}{
This field is interpreted variously according to the requirements of the
individual EIS instructions. Its interpretation is given under FORMAT for each
EIS instruction. The modification fields MF2 and MF3 are contained in this
field if they are required.}

\inlbl {OPCODE}{
Instruction operation code as for basic and EIS single-word instructions.}

\inlbl {I}{
Interrupt inhibit bit as for basic and EIS single-word instructions.}

\inlbl {MF1}{
Modification field for operand descriptor 1. See EIS modification fields (MF)
below for details.}

Machine words in this format are generated by ALM in processing the EIS multiword
instructions described later in this section and their associated operand descriptor or indirect
pointer pseudo-operations.

\subsubsection{EIS Modification Fields (MF)}

Each of the operand descriptors following an EIS multiword instruction word has a
modification field in the instruction word. The modification field controls the interpretation of the
operand descriptor. The modification field is interpreted according to the format shown in Figure

\begin{figure}[H]
\begin{center}
\begin{bytefield}{7}
\\
\bitheader{0,1,2,3,6} \\
\bitbox{1}{a}
\bitbox{1}{b}
\bitbox{1}{c}
\bitbox{4}{REG} \\
\bitbox[]{1}{\hfill\tiny 1}
\bitbox[]{1}{\hfill\tiny 1}
\bitbox[]{1}{\hfill\tiny 1}
\bitbox[]{4}{\hfill\tiny 4} \\
\end{bytefield}
\caption{EIS Modification Field (MF) Format}
\label{f4.4}
\end{center}
\end{figure}

\begin{tabular}{l l p{0.8\linewidth}}
key & & \\
a & AR &
Address register flag. This flag controls interpretation of the ADDRESS field
of the operand descriptor just as the {``}A'' flag controls interpretation of the
ADDRESS field of the basic and EIS single-word instructions. \\
b & RL &
Register length control. If RL = 0, then the length (N) field of the operand
descriptor contains the length of the operand. If RL = 1, then the length (N)
field of the operand descriptor contains a selector value specifying a register
holding the operand length. Operand length is interpreted as units of the data
size (1-, 4-, 6-, or 9-bit) given in the associated operand descriptor. \\
c & ID &
Indirect descriptor control. If ID = 1 for MF\textsl{k}, then the \textsl{k}th word following the
instruction word is an indirect pointer to the operand descriptor for the \textsl{k}th
operand; otherwise, that word is the operand descriptor.  \\
 & REG &
The register number for R-type modification (if any) of ADDRESS of the
operand descriptor. These modifications are similar to R-type modifications
for basic instructions and are summarized in Table 4-1. Illegal modifiers have
the entry {``}IPR'' and cause an illegal procedure fault.

\end{tabular}


\begin{table}[H]
\begin{center}
\caption{R-type Modifiers for REG Fields}
\label{t4.1}
\begin{tabular}{|c|c|c|c|c|}
\hline
 & & & \textit{\textbf{Meaning as used in:}} & \\
 & & & \textit{\textbf{Indirect operand}} & \\
\textit{\textbf{Octal Code}} &
\textit{\textbf{R-type}} &
\textit{\textbf{MF.REG}} &
\textit{\textbf{descriptor-pointer}} &
\textit{\textbf{C(operand descriptor)\tsb{32,35}}} \\
\hline
00 & \texttt{n} & \texttt{n} & \texttt{n} & IPR \\
01 & \texttt{au} & \texttt{au} & \texttt{au} & \texttt{au} \\
02 & \texttt{qu} & \texttt{qu} & \texttt{qu} & \texttt{qu} \\
03 & \texttt{du} & IPR & IPR & \texttt{du}\tsp{(a)} \\
04 & \texttt{ic} & \texttt{ic} & \texttt{ic} & \texttt{ic}\tsp{(b)} \\
05 & \texttt{al} & \texttt{a}\tsp{(c)} & \texttt{al} & \texttt{a}\tsp{(c)} \\
06 & \texttt{ql} & \texttt{q}\tsp{(c)} & \texttt{ql} & \texttt{q}\tsp{(c)} \\
07 & \texttt{dl} & IPR & IPR & IPR \\
10 & \texttt{x0} & \texttt{x0} & \texttt{x0} & \texttt{x0} \\
11 & \texttt{x1} & \texttt{x1} & \texttt{x1} & \texttt{x1} \\
12 & \texttt{x2} & \texttt{x2} & \texttt{x2} & \texttt{x2} \\
13 & \texttt{x3} & \texttt{x3} & \texttt{x3} & \texttt{x3} \\
14 & \texttt{x4} & \texttt{x4} & \texttt{x4} & \texttt{x4} \\
15 & \texttt{x5} & \texttt{x5} & \texttt{x5} & \texttt{x5} \\
16 & \texttt{x6} & \texttt{x6} & \texttt{x6} & \texttt{x6} \\
17 & \texttt{x7} & \texttt{x7} & \texttt{x7} & \texttt{x7} \\
\hline
\end{tabular}

\begin{tabular}{p{0.1\linewidth} p{0.9\linewidth}}
a) &
The du modifier is permitted only in the second operand descriptor of the scd, scdr, scm,
and scmr instructions to specify that the test character(s) reside(s) in bits 0-18 of the operand
descriptor. \\
b) &
The ic modifier is permitted in MFk.REG and C (od)32,35 only if MF\textsl{k}.RL = 0, that is, if the
contents of the register is an address offset, not the designation of a register containing the
operand length. \\
c) &
The limit of addressing extent of the processor is 2**18 words; that is, given an address, y, a
modifier may be employed to access a main memory word anywhere in the range (y-2**17, y
+2**17-1), provided other address range constraints are not violated. Since it is desirable to
address this same extent as words, characters, and bits it is necessary to provide a register
with range greater than the 12 bits of N or the 18 bits of normal R-type modifiers. This is done
by extending the range of the A and Q modifiers as follows: \\
\end{tabular}
\begin{center}
\begin{tabular}{c c c}
Mode & Range & A,Q bits \\
9-bit & 21 & 15,35 \\
6-bit & 21 & 15,35 \\
4-bit & 22 & 14,35 \\
bit & 24 & 12,35 \\
\end{tabular}
\end{center}

\begin{tabular}{p{0.1\linewidth} p{0.9\linewidth}}
& The unused high-order bits are ignored. \\
\end{tabular}
\end{center}
\end{table}

\subsubsubsection{MF Coding Examples}

All of the EIS instruction descriptions in this section give examples of ALM coding formats.
For example, the mlr instruction shows:

\begin{quotation}
\texttt{
\begin{tabular}{p{.2\linewidth}l}
mlr & (MF1),(MF2)[,fill(octalexpression)][,enablefault] \\
\end{tabular}
\begin{tabular}{p{.2\linewidth}ll}
descn\textsl{a} & Y-char\textsl{1}[(CN1)],N1 & \textsl{n} = 4, 6, or 9 (TA1 = 2, 1, or 0) \\
descn\textsl{a} & Y-char\textsl{2}[(CN2)],N2 & \textsl{n} = 4, 6, or 9 (TA2 = 2, 1, or 0) \\
\end{tabular}
}
\end{quotation}
where MF1 and MF2 represent the EIS Modifier Fields for the first and second data descriptors,
respectively.

The meanings of the various codes in an MF field are:

\begin {tabular} {lp{0.8\linewidth}}
\textbf{\textsl{If C(MFn) Contains}} & \textbf{\textsl{It Means}} \\
pr & 
Y-charn is not the memory address of the data but is a reference to a
pointer register pointing to the data. \\
id &
The data in descn is not the data descriptor but is the memory address
(or pointer register reference) of the data descriptor. \\
rl &
The field Nn is not the data length but is the code for register containing
the data length (see \ref{t4.1}).
\end {tabular}

\subsubsection{EIS Operand Descriptors and Indirect Pointers}

The words following an EIS multiword instruction word are either operand descriptors or
indirect pointers to the operand descriptors. The interpretation of the words is performed
according to the settings of the control bits in the associated modification field (MF). The \textsl{k}th word
following the instruction word is interpreted according to the contents of MF\textsl{k}. See EIS
modification fields (MF) above for meaning of the various control bits. See \ref{s2} and \ref{s6}
for further details.

\subsubsubsection{Operand Descriptor Indirect Pointer Format}

If MF\textsl{k}.ID = 1, then the \textsl{k}th word following an EIS multiword instruction word is not an
operand descriptor, but is an indirect pointer to an operand descriptor and is interpreted as shown
in \ref {f4.5}.

\begin{figure}[H]
\begin{center}
\begin{bytefield}{36}
\\
\bitheader{0,17,18,28,29,30,31,32,35} \\
\bitbox{18}{ADDRESS}
%\bitbox{11}{\bitboxes*{11}{00000000000}}
\bitbox{11}{00000000000}
\bitbox{1}{A}
%\bitbox{2}{\bitboxes*{2}{00}}
\bitbox{2}{00}
\bitbox{4}{REG} \\
\bitbox[]{18}{\hfill\tiny 18}
\bitbox[]{11}{\hfill\tiny 11}
\bitbox[]{1}{\hfill\tiny 1}
\bitbox[]{2}{\hfill\tiny 2}
\bitbox[]{4}{\hfill\tiny 4} \\
\end{bytefield}
\caption {Operand Descriptor Indirect Pointer Format}
\label{f4.5}
\end{center}
\end{figure}

\inlbl {ADDRESS}{
The given address of the operand descriptor. This address may be:}
\inull{\hspace{1em}An 18-bit absolute main memory address if A = 0 (absolute mode only)}
\inull{\hspace{1em} An 18-bit offset relative to the base address register (BAR) if A = 0 (BAR
mode only)}
\inull{\hspace{1em} An 18-bit offset relative to the base of the current procedure segment if A
= 0 (appending mode only)}
\inull{\hspace{1em} A 3-bit pointer register number (n) and a 15-bit offset relative to
C(PRn.WORDNO) if A = 1 (all modes)}
\inlbl {A} {Indirect via pointer register flag. This flag controls interpretation of the
ADDRESS field of the indirect pointer just as the {``}A'' flag controls
interpretation of the ADDRESS field of the basic and EIS single-word
instructions.}
\inlbl {REG}{Address modifier for ADDRESS. All register modifiers except du and dl may
be used. If the ic modifier is used, then ADDRESS is an 18-bit offset relative
to value of the instruction counter for the instruction word. C(REG) is
always interpreted as a word offset.}

Machine words in this format are generated by the ALM arg pseudo-instruction giving an
appropriate TAG field.

\subsubsubsection{Alphanumeric Operand Descriptor Format}

For any operand of an EIS multiword instruction that requires alphanumeric data, the
operand descriptor is interpreted as shown in Figure 4-6.

\begin{figure}[H]
\begin{center}
\begin{bytefield}{36}
\\
\bitheader{0,17,18,20,21,22,23,24,35} \\
\bitbox{18}{ADDRESS}
\bitbox{3}{CN}
\bitbox{2}{TA}
\bitbox{1}{0}
\bitbox{12}{N} \\
\bitbox[]{18}{\hfill\tiny 18}
\bitbox[]{3}{\hfill\tiny 3}
\bitbox[]{2}{\hfill\tiny 2}
\bitbox[]{1}{\hfill\tiny 1}
\bitbox[]{12}{\hfill\tiny 12} \\
\end{bytefield}
\caption {Alphanumeric Operand Descriptor Format}
\label{f4.6}
\end{center}
\end{figure}


\inlbl {ADDRESS}{
The given address of the operand. This address may be (for the \textsl{k}th operand):}
\inull{\hspace{1em}An 18-bit absolute main memory address if MF\textsl{k}.AR= 0 (absolute mode
only)}
\inull{\hspace{1em}An 18-bit offset relative to the base address register if MF\textsl{k}.AR = 0 (BAR
mode only)}
\inull{\hspace{1em} An 18-bit offset relative to the base of the current procedure segment if
MF\textsl{k}.AR = 0 (appending mode only)}
\inull{\hspace{1em} A 3-bit address register number (n) and a 15-bit word offset relative to
C(ARn) if MF\textsl{k}.AR = 1 (all modes)}
\inlbl {CN}{
Character number.
This field gives the character position relative to
ADDRESS of the first operand character. Its interpretation depends on the
data type (see TA below) of the operand. below shows the interpretation of
the field. A digit in the table indicates the corresponding character position
(see \ref {s2} for data formats) and an {``}x'' indicates an invalid code for the
data type.
Invalid codes cause illegal procedure faults.
(For further
explanation, see the Note under AR\textsl{n}.BITNO in \ref {s3}, {``}Address Registers''.)}
\inlbl {TA}{
Type alphanumeric. This is the data type code for the operand. The
interpretation of the field is shown in Table 4-3. The code shown as Invalid
causes an illegal procedure fault.}
\inlbl {N}{
Operand length. If MF\textsl{k}.RL = 0, this field contains the string length of the
operand. If MF\textsl{k}.RL = 1, this field contains the code for a register holding the
operand string length. See \ref{t4.1} and EIS modification fields (MF) above
for a discussion of register codes.}

Machine words of this format are generated by ALM when processing the \texttt{desc4a}, \texttt{desc6a},
and \texttt{desc9a} pseudo-instructions.

\begin{table}[H]
\begin{center}
\caption {Alphanumeric Character Number (CN) Codes}
\label{t4.2}
\begin{tabular}{|c|c|c|c|}
\hline
\textit{\textbf{C(CN)}} & 
\textit{\textbf{4-bit}} &
\textit{\textbf{6-bit}} &
\textit{\textbf{9-bit}} \\
\hline
000 & \texttt{0} & \texttt{0} & \texttt{0} \\
001 & \texttt{1} & \texttt{1} & \texttt{x} \\
010 & \texttt{2} & \texttt{2} & \texttt{1} \\
011 & \texttt{3} & \texttt{3} & \texttt{x} \\
100 & \texttt{4} & \texttt{4} & \texttt{2} \\
101 & \texttt{5} & \texttt{5} & \texttt{x} \\
110 & \texttt{6} & \texttt{x} & \texttt{3} \\
111 & \texttt{7} & \texttt{x} & \texttt{x} \\
\hline
\end{tabular}
\end{center}
\end{table}

\begin{table}[H]
\begin{center}
\caption {Alphanumeric Data Type (TA) Codes}
\label{t4.3}
\begin{tabular}{|c|c|}
\hline
\textit{\textbf{C(TA)}} & \textit{\textbf{Data type}} \\
\hline
00 & 9-bit \\
01 & 6-bit \\
10 & 4-bit \\
11 & Invalid \\
\hline
\end{tabular}
\end{center}
\end{table}

\subsubsubsection{Numeric Operand Descriptor Format}


For any operand of an EIS multiword instruction that requires numeric data, the operand
descriptor is interpreted as shown in \ref{f4.7}.

\begin{figure}[H]
\begin{center}
\begin{bytefield}{36}
\\
\bitheader{0,17,18,20,21,22,23,24,28,30,35} \\
\bitbox{18}{ADDRESS}
\bitbox{3}{CN}
\bitbox{1}{a}
\bitbox{2}{S}
\bitbox{6}{SF}
\bitbox{6}{N} \\
\bitbox[]{18}{\hfill\tiny 18}
\bitbox[]{3}{\hfill\tiny 3}
\bitbox[]{1}{\hfill\tiny 1}
\bitbox[]{2}{\hfill\tiny 2}
\bitbox[]{6}{\hfill\tiny 6}
\bitbox[]{6}{\hfill\tiny 6} \\
\end{bytefield}
\caption {Numeric Operand Descriptor Format}
\label{f4.7}
\end{center}
\end{figure}

\begin{tabular}{l l p{0.8\linewidth}}
key & & \\
 & ADDRESS &
The given address of the operand.
This address may be (for the \textsl{k}th
operand): \\
& & \hspace{1em}
An 18-bit absolute main memory address if MFk.AR= 0 (absolute mode
only) \\
& & \hspace{1em}
An 18-bit offset relative to the base address register if MFk.AR = 0 (BAR
mode only) \\
& & \hspace{1em}
An 18-bit offset relative to the base of the current procedure segment if
MF\textsl{k}.AR = 0 (appending mode only) \\
& & \hspace{1em}
A 3-bit address register number (n) and a 15-bit word offset relative to
C(AR\textsl{n}) if MF\textsl{k}.AR = 1 (all modes) \\
& CN & 
Character number. This field gives the character position relative to
ADDRESS of the first operand digit. Its interpretation depends on the data
type (see TN below) of the operand.
\ref{f4.2} above shows the
interpretation of the field. (For further information, see the Note under
AR\textsl{n}.BITNO in \ref{3} on Address Registers.) \\
a & TN & 
Type numeric. This is the data type code for the operand. The codes are: \\
%\begin{center}
\begin{tabular} {cc}
\textbf{\textsl{C(TN)}} & \textbf{\textsl{Data type}} \\
0 & 9-bit \\
1 & 3-bit \\
\end{tabular}
%\end{center}
 & S &
Sign and decimal type of data. The interpretation of the field is shown in
\ref{t4.4}. \\
 & SF &
Scaling factor. This field contains the two's complement value of the base 10
scaling factor; that is, the value of m for numbers represented as n $\times$ 10**m.
The decimal point is assumed to the right of the least significant digit of n.
Negative values move the decimal point to the left; positive values, to the
right. The range of m is (-32,31). The scaling factor is ignored if S=00. \\
 & N &
Operand length. If MF\textsl{k}.RL = 0, this field contains the operand length in
digits. If MF\textsl{k}.RL = 1, it contains the REG code for the register holding the
operand length and C(REG) is treated as a 0 modulo 64 number. See 
\ref{t4.1} and EIS modification fields (MF) above for a discussion of register codes. \\
\end{tabular}

Machine words in this format are generated by ALM when processing the \texttt{desc4fl},
\texttt{desc4ls}, \texttt{desc4ts}, \texttt{desc4ns}, \texttt{desc9fl}, \texttt{desc9ls}, \texttt{desc9ts}, and \texttt{desc9ns} pseudo-instructions.

\subsubsubsection{Bit-string Operand Descriptor Format}

For any operand of an EIS multiword instruction that requires bit-string data, the operand
descriptor is interpreted as shown in Figure 4-8.


\begin{figure}[H]
\begin{center}
\begin{bytefield}{36}
\\
\bitheader{0,17,18,19,20,23,24,35} \\
\bitbox{18}{ADDRESS}
\bitbox{2}{C}
\bitbox{4}{B}
\bitbox{12}{N} \\
\bitbox[]{18}{\hfill\tiny 18}
\bitbox[]{2}{\hfill\tiny 2}
\bitbox[]{4}{\hfill\tiny 4}
\bitbox[]{12}{\hfill\tiny 12} \\
\end{bytefield}
\caption {Bit String Operand Descriptor Format}
\label{f4.8}
\end{center}
\end{figure}

\inlbl {ADDRESS} {
The given address of the operand. This address may be (for the kth operand):}
\inull{\hspace{1em} An 18-bit main memory address if MFk.AR= 0 (absolute mode only)}
\inull{\hspace{1em} An 18-bit offset relative to the base address register if MFk.AR = 0 (BAR
mode only)}
\inull{\hspace{1em} An 18-bit offset relative to the base of the current procedure segment if
MF\textsl{k}.AR = 0 (appending mode only)}
\inull{\hspace{1em} A 3-bit address register number (n) and a 15-bit word offset relative to
C(ARn) if MF\textsl{k}.AR = 1 (all modes)}
\inlbl {C} {
The character number of the 9-bit character relative to ADDRESS containing
the first bit of the operand. (For further explanation, see the Note under
AR\textsl{n}.BITNO in \ref{s3} on Address Registers.)}
\inlbl {B}{
The bit number within the 9-bit character, C, of the first bit of the operand.}
\inlbl {N}{
Operand length. If MF\textsl{k}.RL = 0, this field contains the string length of the
operand. If MF\textsl{k}.RL = 1, this field contains the code for a register holding the
operand string length. See \ref{t4.1} and EIS modification fields (MF) above
for a discussion of register codes.}

Machine words of this format are generated by ALM when processing the descb pseudoinstruction.

\subsection{FIXED-POINT ARITHMETIC INSTRUCTIONS}

\subsubsection{Fixed-Point Data Movement Load}

\ins{eaa}{Effective Address to A}{635 (0)}
\inbif
\insum {C(TPR.CA) $\rightarrow$ C(A)\textsubscript{0,17}}
\inull {00\dots0 $\rightarrow$ C(A)\textsubscript{18,35}}
\inmul
\inina
\ininZ {A}
\ininN {A}
\innte {The \texttt{eaa} instruction, and the instructions \texttt{eaq} and \texttt{eaxn}, facilitate
interregister data movements. The data source is specified by the address
modification, and the data destination by the operation code of the
instruction. }
\innta {Attempted repetition with the rpl instruction causes an illegal procedure
fault. }





\ins{eaq}{Effective Address to Q}{636 (0)}
\inbif
\insum {C(TPR.CA) $\rightarrow$ C(Q)\textsubscript{0,17}}
\inull {00\dots0 $\rightarrow$ C(Q)\textsubscript{18,35}}
\inmul
\inina
\ininZ {Q}
\ininN {Q}
\inrpl

\cac {From `\texttt{eaa} NOTES': The \texttt{eaa} instruction, and the instructions \texttt{eaq} and
\texttt{eaxn}, facilitate
interregister data movements. The data source is specified by the address
modification, and the data destination by the operation code of the
instruction. }


\ins{eaxn}{Effective Address to Index Register n}{62$n$ (0)}
\inbif
\insum {For n = 0, 1, \dots or 7 as determined by operation code}
\inull {C(TPR.CA) $\rightarrow$ C(Xn)}
\inmul
\inina
\ininZ {Xn}
\ininN {Xn}
\inrpl

\cac {From `\texttt{eaa} NOTES': The \texttt{eaa} instruction, and the instructions \texttt{eaq} and
\texttt{eaxn}, facilitate
interregister data movements. The data source is specified by the address
modification, and the data destination by the operation code of the
instruction. }

\ins{lca}{Load Complement A}{335 (0)}
\inbif
\insum {-C(Y) $\rightarrow$ C(A)}
\inall
\inina
\ininZ {A}
\ininN {A}
\inino {If range of A is exceeded, then ON}
\innte {The \texttt{lca} instruction changes the number to its negative while
moving it
from Y to A. The operation is executed by forming the twos complement of
the string of 36 bits. In twos complement arithmetic, the value 0 is its own
negative. An overflow condition exists if C(Y) = -2**35.}






\ins {lcaq}{Load Complement AQ}{337 (0)}
\inbif
\insum {-C(Y-pair) $\rightarrow$ C(AQ)}
\indcs
\inina
\ininZ {AQ}
\ininN {AQ}
\inino {If range of AQ is exceeded, then ON}
\innte {The \texttt{lcaq} instruction changes the number to its negative while
moving it
from Y-pair to AQ. The operation is executed by forming the twos
complement of the string of 72 bits. In twos complement arithmetic, the
value 0 is its own negative. An overflow condition exists if C(Y-pair) =
-2**71. }




\ins {lcq} {Load Complement Q} {336 (0)}
\inbif
\insum {-C(Y) $\rightarrow$ C(Q)}
\inall
\inina

\ininZ {Q}
\ininN {Q}
\ininO {Q}
\innte{ 
The lcq instruction changes the number to its negative while moving it
from Y to Q The operation is executed by forming the twos complement of
the string of 36 bits. In twos complement arithmetic, the value 0 is its own
negative. An overflow condition exists if C(Y) = -2**35.}


\ins {lcx\textsl{n}} {Load Complement Index Register \textsl{n}} {32\textsl{n} (0)}
\inbif
\insum {
For n = 0, 1, ..., or 7 as determined by operation code}
\inull {\hspace{1em} -C(Y)0,17 $\rightarrow$ C(Xn)}
\incss
\inina
\ininZ {Xn}
\ininN {Xn}
\ininO {Xn}
\innte { 
The lcxn instruction changes the number to its negative while moving it
from Y0,17 to Xn The operation is executed by forming the twos
complement of the string of 18 bits. In twos complement arithmetic, the
value 0 is its own negative. An overflow condition exists if C(Y)0,17 =
-2**17.}
\innta{
Attempted repetition with the rpl instruction and with the same register
given as target and modifier causes an illegal procedure fault.}

\ins {lda} {Load A} {235 (0)}
\inbif
\insum {C(Y) $\rightarrow$ C(A)}
\inall
\inina
\ininZ {A}
\ininN {A}
\ininO {A}






\ins {ldac} {Load A and Clear} {034 (0)}
\inbif
\insum {C(Y) $\rightarrow$ C(A)}
\inull {00...0 $\rightarrow$ C(Y)}
\indcs
\inina
\ininZ {A}
\ininN {A}
\innte{
The ldac instruction causes a special main memory reference that
performs the load and clear in one cycle. Thus, this instruction can be
used in locking data.}






\ins {ldaq} {Load AQ  } {237 (0)}
\inbif
\insum {C(Y-pair) $\rightarrow$ C(AQ)}
\indcs
\inina
\ininZ {AQ}
\ininN {AQ}







\ins {ldi} {Load Indicator Register} {634 (0)}
\inbif
\insum {C(Y)18,31 $\rightarrow$ C(IR)}
\incss
\inina
\inpar {
If C(Y)27 = 1, and the processor is in absolute or instruction privileged
mode, then ON; otherwise OFF. This indicator is not affected in the
normal or BAR modes.}
\inbar {
Cannot be changed by the ldi instruction}
\inlbl{\hspace{1em}Mid instruction\\\hspace{1em} interrupt fault}{
If C(Y)30 = 1, and the processor is in absolute or instruction privileged
mode, then ON; otherwise OFF. This indicator is not affected in normal or
BAR modes.}
\inlbl{\hspace{1em}Absolute mode} {
Cannot be changed by the ldi instruction}
\inlbl{\hspace{1em}All other} {
If corresponding bit in C(Y) is 1, then ON; otherwise, OFF}
\innte{
The relation between C(Y)18,31 and the indicators is given in \ref{t4.5}
below.}
\innta{
The tally runout indicator reflects C(Y)25 regardless of what address
modification is performed on the ldi instruction.}
\innta{
Attempted repetition with the rpt, rpd, or rpl instructions causes an
illegal procedure fault.}

\begin{table}[H]
\begin{center}
\caption { Relation Between Data Bits and Indicators Bit}
\label{t4.5}
\begin{tabular}{|c|l|}
\hline
\textit{\textbf{BIt Position C(Y)}} & 
\textit{\textbf{Indicator}} \\
\hline
18 & Zero \\
19 & Negative \\
20 & Carry \\
21 & Overflow \\
22 & Exponent overflow \\
23 & Exponent underflow \\
24 & Overflow mask \\
25 & Tally runout \\
26 & Parity error \\
27 & Parity mask \\
28 & Not BAR mode \\
29 & Truncation \\
30 & Mid instruction interrupt fault \\
31 & Absolute mode \\
\hline
\end{tabular}
\end{center}
\end{table}













\ins {ldq} {Load Q} {236 (0)}
\inbif
\insum {C(Y) $\rightarrow$ C(Q)}
\inall
\inina

\ininZ {Q}
\ininN {Q}









\ins {ldqc} {Load Q and Clear} {032 (0)}
\inbif
\insum {C(Y) $\rightarrow$ C(Q)}
\inull {\hspace{1em} 00...0 $\rightarrow$ C(Y)}
\indcs
\inina
\ininZ {Y}
\ininN {Y}
\innte {
The ldqc instruction causes a special main memory reference that
performs the load and clear in one cycle. Thus, this instruction can be
used in locking data.}










\ins {ldxn} {Load Index Register \textsl{n}} {22\textsl{n} (0)}
\inbif
\insum {For n = 0, 1, ..., or 7 as determined by operation code}
\inull{\hspace{1em}C(Y)0,17 $\rightarrow$ C(Xn)}
\incss
\inina
\ininZ {Xn}
\ininN {Xn}
\innte{
Attempted repetition with the rpl instruction with the same register given
as target and modifier causes an illegal procedure fault.}











\ins {lreg} {Load Registers} {073 (0)}
\inbif
\insum {C(Y-block8)0,17 $\rightarrow$ C(X0)}
\inull {C(Y-block8)18,35 $\rightarrow$ C(X1)}
\inull {C(Y-block8+1)0,17 $\rightarrow$ C(X2)}
\inull {C(Y-block8+1)18,35 $\rightarrow$ C(X3)}
\inull {C(Y-block8+2)0,17 $\rightarrow$ C(X4)}
\inull {C(Y-block8+2)18,35 $\rightarrow$ C(X5)}
\inull {C(Y-block8+3)0,17 $\rightarrow$ C(X6)}
\inull {C(Y-block8+3)18,35 $\rightarrow$ C(X7)}
\inull {C(Y-block8+4) $\rightarrow$ C(A)}
\inull {C(Y-block8+5) $\rightarrow$ C(Q)}
\inull {C(Y-block8+6)0,7 $\rightarrow$ C(E)}
\indcs
\innaf
\innte{
Attempted repetition with the rpt, rpd, or rpl instructions causes an
illegal procedure fault.}









\ins {lxln} {Load Index Register n from Lower} {72n (0)}
\inbif
\insum {For n = 0, 1, ..., or 7 as determined by operation code}
\inull {\hspace{1em}C(Y)18,35 $\rightarrow$ C(Xn)}
\incss
\inina
\ininZ {Xn}
\ininN {Xn}
\innte {
Attempted repetition with the rpl instruction with the same register given
as target and modifier causes an illegal procedure fault.}

\subsubsection{Fixed-Point Data Movement Store}

\ins {sreg} {Store Registers} {753 (0)}
\inbif
\insum {C(X0) $\rightarrow$ C(Y-block8)0,17}
\inull {C(X1) $\rightarrow$ C(Y-block8)18,35}
\inull {C(X2) $\rightarrow$ C(Y-block8+1)0,17}
\inull {C(X3) $\rightarrow$ C(Y-block8+1)18,35}
\inull {C(X4) $\rightarrow$ C(Y-block8+2)0,17}
\inull {C(X5) $\rightarrow$ C(Y-block8+2)18,35}
\inull {C(X6) $\rightarrow$ C(Y-block8+3)0,17}
\inull {C(X7) $\rightarrow$ C(Y-block8+3)18,35}
\inull {C(A) $\rightarrow$ C(Y-block8+4)}
\inull {(Q) $\rightarrow$ C(Y-block8+5)}
\inull {C(E) $\rightarrow$ C(Y-block8+6)0,7}
\inull {00...0 $\rightarrow$ C(Y-block8+6)8,35}
\inull {C(TR) $\rightarrow$ C(Y-block8+7)0,26}
\inull {00...0 $\rightarrow$ C(Y-block8+7)27,32}
\inull {C(RALR) $\rightarrow$ C(Y-block8+7)33,35}
\indcs
\innaf
\innte {
Attempted repetition with the rpt, rpd, or rpl instructions causes an
illegal procedure fault.}








 
\ins {sta} {Store A} {755 (0)}
\inbif
\insum {C(A) $\rightarrow$ C(Y)}
\inmul
\innaf
\inrpl
 




\ins {stac} {Store A Conditional} {354 (0)}
\inbif
\insum {If C(Y) = 0, then C(A) $\rightarrow$ C(Y)}
\indcs
\inina
\ininz {If initial C(Y) = 0, then ON; otherwise OFF}
\innte {
If the initial C(Y) is nonzero, then C(Y) is not changed by the stac
instruction.}
\innta {
The stac instruction uses a special main memory reference that prohibits
such references by other processors between the test and the data
transfer. Thus, it may be used for data locking.}
\inrpl




\ins {stacq} {Store A Conditional on Q} {654 (0)}
\inbif
\insum {If C(Y) = C(Q), then C(A) $\rightarrow$ C(Y)}
\indcs
\inina
\ininz {If initial C(Y) = C(Q), then ON; otherwise OFF}
\innte {
If the initial C(Y) is $\neq$ C(Q), then C(Y) is not changed by the stacq
instruction.}
\innta {
The stacq instruction uses a special main memory reference that prohibits
such references by other processors between the test and the data
transfer. Thus, it may be used for shared data locking and unlocking.}
\innta {
On the DPS 8M processor, data shared by more than one processor may, at
any time, be in more than one processor's cache memory. To aid the
integrity of shared data, the stacq instruction will always bypass cache
and obtain its operand from main memory. In addition, a synchronizing
function inhibits completion of the stacq instruction until the processor
executing the stacq instruction is notified by the scu that write completes
have occurred and write notifications requesting cache block clears have
been sent to the other processors for all write instructions that the
processor previously issued. This feature, therefore, makes the stacq
instruction the preferred choice for unlocking shared data bases.}
\innta {
Attempted repetition with the rpl instruction causes an illegal procedure
fault.}
 






\ins {staq} {Store AQ} {757 (0)}
\inbif
\insum {C(AQ) $\rightarrow$ C(Y-pair)}
\indcs
\innaf
\inrpl
 





\ins {stba} {Store Bytes of A} {551 (0)}
\inbif
\insum { 9-bit bytes of C(A) $\rightarrow$ corresponding bytes of C(Y), the byte positions
affected being specified in the TAG field.}
\inmod {None (see NOTES below)}
\innaf
\innte {
Binary ones in the TAG field of this instruction specify the byte positions of
A and Y that are affected. The control relations are shown in \ref{t4.6}}
\innta {
ALM treats a given numeric TAG field for this instruction as an octal
number.}
\innta {
Attempted repetition with the rpt, rpd, or rpl instructions causes an
illegal procedure fault.}

\begin{table}[H]
\begin{center}
\caption {Control Relations for Store Byte Instructions (9-Bit)}
\label{t4.6}
\begin{tabular}{|c|c|c|}
\hline
\textit{\textbf{Bit position)}} & 
\textit{\textbf{Bit of}} &
  \\
\textit{\textbf{within TAG)}} & 
\textit{\textbf{instructi}} &
  \\
\textit{\textbf{field)}} & 
\textit{\textbf{on}} &
\textit{\textbf{Byte of A and Y}} \\
\hline
0 & 30 & Byte 0 (bits 0-8) \\
1 & 31 & Byte 1 (bits 9-17) \\
2 & 32 & Byte 2 (bits 18-26) \\
3 & 33 & Byte 3 (bits 27-35) \\
\hline
\end{tabular}
\end{center}
\end{table}







\ins {stbq} {Store Bytes of Q} {552 (0)}
\inbif
\insum {9-bit bytes of C(Q) $\rightarrow$ corresponding bytes of C(Y), the byte positions affected being specified in the TAG field.}
\inmod {None (see NOTES below)}
\innaf
\innte {
Binary ones in the TAG field of this instruction specify the byte positions of
Q and Y that are affected. The control relations are shown in \ref{t4.6}
above.}
\innta {
ALM treats a given numeric TAG field for this instruction as an octal
number.}
\innta {
Attempted repetition with the rpt, rpd, or rpl instructions causes an
illegal procedure fault.}






\ins {stc1} {Store Instruction Counter Plus 1} {554 (0)}
\inbif

\insum {C(PPR.IC) + 1 $\rightarrow$ C(Y)0,17}
\inull {C(IR) $\rightarrow$ C(Y)18,31}
\inull {00\ldots0 $\rightarrow$ C(Y)32,35}
\indcs
\innaf
\innte {
The contents of the instruction counter C(PPR.IC) and the indicator
register (IR) after address preparation are stored in C(Y)0,17 and C(Y)18,31,
respectively. C(Y)25 reflects the state of the tally runout indicator prior to
modification. The relations between C(Y)18,31 and the indicators are given
in Table 4-5.}
\innta {
Attempted repetition with the rpt, rpd, or rpl instructions causes an
illegal procedure fault.}






\ins {stc2} {Store Instruction Counter Plus 2} {750 (0)}
\inbif
\insum {C(PPR.IC) + 2 $\rightarrow$ C(Y)0,17}
\indcs
\innaf
\innte {
The contents of the instruction counter C(PPR.IC) are stored in C(Y)0,17.}
\innta {
Attempted repetition with the rpt, rpd, or rpl instructions causes an
illegal procedure fault.}
 








\ins {stca} {Store Characters of A} {751 (0)}
\inbif
\insum {
Characters of C(A) $\rightarrow$ corresponding characters of C(Y), the character
positions affected being specified in the TAG field.}
\inmod {None (see NOTES below)}
\innaf
\innte {
Binary ones in the TAG field of this instruction specify character positions
of A and Y that are affected. The control relations are shown in \ref{t4.7}.
ALM treats a given numeric TAG field for this instruction as an octal
number.}
\innta {
Attempted repetition with the rpt, rpd, or rpl instructions causes an
illegal procedure fault. }

\begin{table}[H]
\begin{center}
\caption {Control Relations for Store Character Instructions (6-Bit)}
\label{t4.7}
\begin{tabular}{|c|c|c|}
\hline
\textit{\textbf{Bit position)}} & 
 &
  \\
\textit{\textbf{within TAG)}} & 
\textit{\textbf{Bit of}} &
\textit{\textbf{Character of A and}} \\
\textit{\textbf{field)}} & 
\textit{\textbf{instruction}} &
\textit{\textbf{Y}} \\
\hline
0 & 30 & Byte 0 (bits 0-5) \\
1 & 31 & Byte 1 (bits 6-11) \\
2 & 32 & Byte 2 (bits 12-17) \\
3 & 33 & Byte 3 (bits 18-23) \\
4 & 34 & Byte 4 (bits 24-29) \\
5 & 35 & Byte 5 (bits 30-35) \\
\hline
\end{tabular}
\end{center}
\end{table}










\ins {stcq} {Store Characters of Q} {752 (0)}
\inbif
\insum {Characters of C(Q) $\rightarrow$ corresponding characters of C(Y), the character
positions affected being specified by the TAG field.}
\inmod {None (see NOTES below)}
\innaf
\innte {
Binary ones in the TAG field of this instruction specify the character
positions of Q and Y that are affected. The control relations are shown in
\ref{t4.7} above.}
\innta {
ALM treats a given numeric TAG field for this instruction as an octal
number. }
\innta {
Attempted repetition with the rpt, rpd, or rpl instructions causes an
illegal procedure fault. }

\ins {stcd} {Store Control Double} {357 (0)}
\inbif
\insum {C(PPR) $\rightarrow$ C(Y-pair) as follows:}
\inull{hspace{1em}000 $\rightarrow$ C(Y-pair)0,2}
\inull{hspace{1em}C(PPR.PSR) $\rightarrow$ C(Y-pair)3,17}
\inull{hspace{1em}C(PPR.PRR) $\rightarrow$ C(Y-pair)18,20}
\inull{hspace{1em}00...0 $\rightarrow$ C(Y-pair)21,29}
\inull{hspace{1em}(43)8 $\rightarrow$ C(Y-pair)30,35}
\inull{hspace{1em}C(PPR.IC)+2 $\rightarrow$ C(Y-pair)36,53}
\inull{hspace{1em}00...0 $\rightarrow$ C(Y-pair)54,71}
\indcs
\innaf
\innte {
Attempted repetition with the rpt, rpd, or rpl instructions causes an
illegal procedure fault.}






\ins {sti} {Store Indicator Register} {754 (0)}
\inbif
\insum {C(IR) $\rightarrow$ C(Y)18,31}
\inull {00\ldots0 $\rightarrow$ C(Y)32,35}
\indcs
\innaf
\innte {
The contents of the indicator register after address preparation are stored
in C(Y)18,31. C(Y)18,31 reflects the state of the tally runout indicator prior
to address preparation. The relation between C(Y)18,31 and the indicators
is given in \ref{4.5}.}
\innta {
Attempted repetition with the rpt, rpd, or rpl instructions causes an
illegal procedure fault.}
 





\ins {stq} {Store Q} {756 (0)}
\inbif
\insum {C(Q) $\rightarrow$ C(Y)}
\inmul
\innaf
\inrpl
 




\ins {stt} {Store Timer Register} {454 (0)}
\inbif
\insum {C(TR) $\rightarrow$ C(Y)0,26}
\inull {00\ldots0 $\rightarrow$ C(Y)27,35}
\indcs
\innaf
\innte {
Attempted repetition with the rpt, rpd, or rpl instructions causes an
illegal procedure fault.}





\ins {stxn} {Store Index Register n} {74n (0)}
\inbif
\insum {For n = 0, 1, ..., or 7 as determined by operation code}
\inull {hspace{1em}C(Xn) $\rightarrow$ C(Y)0,17}
\indcs
\innaf
\inrpl






\ins {stz} {Store Zero} {450 (0)}
\inbif
\insum {00...0 $\rightarrow$ C(Y)}
\inmul
\innaf
\inrpl
 






\ins {sxln} {Store Index Register n in Lower} {44n (0)}
\inbif
\insum {For n = 0, 1, ..., or 7 as determined by operation code}
\inull {\hspace{1em}C(Xn) $\rightarrow$ C(Y)18,35}
\indcs
\innaf
\inrpl





\subsubsection{Fixed-Point Data Movement Shift}




\ins {alr} {Left Rotate} {775 (0)}
\inbif
\insum {
Shift C(A) left the number of positions given in C(TPR.CA)11,17; entering
each bit leaving A0 into A35.}
\indcs
\inina
\ininZ {A}
\ininN {A}
\inrpl






\ins {als} {A Left Shift} {735 (0)}
\inbif
\insum {
Shift C(A) left the number of positions given in by C(TPR.CA) 11,17; filling
vacated positions with zeros.}
\indcs
\inina
\ininZ {A}
\ininN {A}
\ininc {If C(A)0 changes during the shift, then ON; otherwise OFF}
\inrpl







\ins {arl} {Right Logical} {771 (0)}
\inbif
\insum {
Shift C(A) right the number of positions given in C(TPR.CA) 11,17; filling
vacated positions with zeros.}

\indcs
\inina
\ininZ {A}
\ininN {A}
\inrpl
 




\ins {ars} {A Right Shift} {731 (0)}
\inbif
\insum {
Shift C(A) right the number of positions given in C(TPR.CA) 11,17; filling
vacated positions with initial C(A)0.}
\indcs
\inina
\ininZ {A}
\ininN {A}
\inrpl




\ins {llr} {Long Left Rotate} {777 (0)}
\inbif
\insum {
Shift C(AQ) left by the number of positions given in C(TPR.CA)11,17;
entering each bit leaving AQ0 into AQ71.}
\indcs
\inina
\ininZ {AQ}
\ininO {AQ}
\inrpl







\ins {lls} {Long Left Shift} {737 (0)}
\inbif
\insum {
 Shift C(AQ) left the number of positions given in C(TPR.CA)11,17; filling
vacated positions with zeros.}
\indcs
\inina
\ininZ {AQ}
\ininN {AQ}
\ininc {If C(AQ)0 changes during the shift, then ON; otherwise OFF}
\inrpl




\ins {lrl} {Long Right Logical} {773 (0)}
\inbif
\insum {
Shift C(AQ) right the number of positions given in C(TPR.CA) 11,17; filling
vacated positions with zeros.}
\indcs
\inina
\ininZ {AQ}
\ininN {AQ}
\inrpl




\ins {lrs} {Long Right Shift} {733 (0)}
\inbif
\insum {
Shift C(AQ) right the number of positions given in C(TPR.CA) 11,17; filling
vacated positions with initial C(AQ)0.}
\indcs
\inina
\ininZ {AQ}
\ininN {AQ}
\inrpl





\ins {qlr} {Q Left Rotate} {776 (0)}
\inbif
\insum {
Shift C(Q) left the number of positions given in C(TPR.CA)11,17; entering
each bit leaving Q0 into Q35.}
\indcs
\inina
\ininZ {Q}
\ininN {Q}
\inrpl





\ins {qls} {Q Left Shift} {736 (0)}
\inbif
\insum {
Shift C(Q) left the number of positions given in C(TPR.CA) 11,17; fill vacated
positions with zeros.}

\indcs
\inina
\ininZ {Q}
\ininN {Q}
\ininc {If C(Q)0 changes during the shift, then ON; otherwise OFF}
\inrpl














\ins {qrl} {Q Right Logical} {772 (0)}
\inbif
\insum {
Shift C(Q) right the number of positions specified by Y11,17; fill vacated
positions with zeros.}
\indcs
\inina
\ininZ {Q}
\ininN {Q}
\inrpl









\ins {qrs} {Q Right Shift} {732 (0)}
\inbif
\insum {
Shift C(Q) right the number of positions given in C(TPR.CA)11,17; filling
vacated positions with initial C(Q)0.}
\indcs
\inina
\ininZ {Q}
\ininN {Q}
\inrpl






\subsubsection{Fixed-Point Addition}




\ins {ada} {Add to A} {075 (0)}
\inbif
\insum {C(A) + C(Y) $\rightarrow$ C(A)}
\inall
\inina
\ininZ {A}
\ininN {A}
\ininO {A}
\ininC {A}









\ins {adaq} {Add to AQ} {077 (0)}
\insum {C(AQ) + C(Y-pair) $\rightarrow$ C(AQ)}
\indcs
\inina
\ininZ {AQ}
\ininN {AQ}
\ininO {AQ}
\ininC {AQ}












\ins {adl} {Add Low to AQ} {033 (0)}
\inbif
\insum {C(AQ) + C(Y) sign extended $\rightarrow$ C(AQ)}
\incss
\inina
\ininZ {AQ}
\ininN {AQ}
\ininO {AQ}
\ininC {AQ}
\innte {A 72-bit number is formed from C(Y) in the following manner:}
\innta {\hspace{1em}The lower 36 bits (36,71) are identical to C(Y).}
\innta {\hspace{1em}Each of the upper 36 bits (0,35) is identical to C(Y)0.}
\innta {This 72-bit number is added to the contents of the combined AQ-register.}







\ins {adla} {Add Logical to A} {035 (0)}
\inbif
\insum {C(A) + C(Y) $\rightarrow$ C(A)}
\inall
\inina
\ininZ {A}
\ininN {A}
\ininC {A}
\innte{
The adla instruction is identical to the ada instruction with the exception
that the overflow indicator is not affected by the adla instruction, nor does
an overflow fault occur. Operands and results are treated as unsigned,
positive binary integers.}









\ins {adlaq} {Add Logical to AQ} {037 (0)}
\inbif
\insum {C(AQ) + C(Y-pair) $\rightarrow$ C(AQ)}
\indcs
\inina
\ininZ {AQ}
\ininN {AQ}
\ininC {AQ}
\innte {
The adlaq instruction is identical to the adaq instruction with the
exception that the overflow indicator is not affected by the adlaq
instruction, nor does an overflow fault occur. Operands and results are
treated as unsigned, positive binary integers.}







\ins {adlq} {Add Logical to Q} {036 (0)}
\inbif
\insum {C(Q) + C(Y) $\rightarrow$ C(Q)}
\inall
\inina
\ininZ {Q}
\ininN {Q}
\ininC {Q}
\innte { 
The adlq instruction is identical to the adq instruction with the exception
that the overflow indicator is not affected by the adlq instruction, nor does
an overflow fault occur. Operands and results are treated as unsigned,
positive binary integers.}






\ins {adlxn} {Add Logical to Index Register n} {02n (0)}
\inbif
 
\insum {For n = 0, 1, ..., or 7 as determined by operation code}
\inull {\hspace{1em}C(Xn) + C(Y)0,17 $\rightarrow$ C(Xn)}
\incss
\inina
\ininZ {Xn}
\ininN {Xn}
\ininC {Xn}
\innte {
The adlxn instruction is identical to the adxn instruction with the
exception that the overflow indicator is not affected by the adlxn
instruction, nor does an overflow fault occur. Operands and results are
treated as unsigned, positive binary integers.}











\ins {adq} {Add to Q} {076 (0)}
\inbif
\insum {C(Q) + C(Y) $\rightarrow$ C(Q)}
\inall
\inina
\ininZ {Q}
\ininN {Q}
\ininO {Q}
\ininC {Q}







\ins {adxn} {Add to Index Register n} {06n (0)}
\inbif
\insum {For n = 0, 1, ..., or 7 as determined by operation code}
\inull {\hspace{1em}C(Xn) + C(Y)0,17 $\rightarrow$ C(Xn)}
\incss
\inina
\ininZ {Xn}
\ininN {Xn}
\ininO {Xn}
\ininC {Xn}




\ins {aos} {Add One to Storage} {054 (0)}
\inbif
\insum {C(Y) + 1 $\rightarrow$ C(Y)}
\indcs
\inina
\ininZ {Y}
\ininN {Y}
\ininO {Y}
\ininC {Y}
\inrpl









\ins {asa} {Add Stored to A} {055 (0)}
\inbif
\insum {C(A) + C(Y) $\rightarrow$ C(Y)}
\indcs
\inina
\ininZ {Y}
\ininN {Y}
\ininO {Y}
\ininC {Y}
\inrpl






\ins {asq} {Add Stored to Q} {056 (0)}
\inbif
\insum {C(Q) + C(Y) $\rightarrow$ C(Y)}
\indcs
\inina
\ininZ {Y}
\ininN {Y}
\ininO {Y}
\ininC {Y}
\inrpl





\ins {asxn} {Add Stored to Index Register n} {04n (0)}
\inbif
\insum {For n = 0, 1, ..., or 7 as determined by operation code}
\inull {\hspace{1em}C(Xn) + C(Y)0,17 $\rightarrow$ C(Y)0,17}
\indcs
\inina
\ininz {If C(Y)\tsb{0,17} = 0, then ON; otherwise OFF}
\ininN {Y}
\inino {If range of Y\tsb{0,17} is exceeded, then ON}
\ininC {Y}
\inrpl
 




\ins {awca} {Add with Carry to A} {071 (0)}
\inbif
\insum {If carry indicator OFF, then C(A) + C(Y) $\rightarrow$ C(A)}
\inull {If carry indicator ON, then C(A) + C(Y) + 1 $\rightarrow$ C(A)}
\inall
\inina
\ininZ {A}
\ininN {A}
\ininO {A}
\ininC {A}
\innte {
The awca instruction is identical to the ada instruction with the exception
that when the carry indicator is ON at the beginning of the instruction, 1 is
added to the sum of C(A) and C(Y).}





\ins {awcq} {Add with Carry to Q} {072 (0)}
\inbif
\insum {If carry indicator OFF, then C(Q) + C(Y) $\rightarrow$ C(Q)}
\inull {If carry indicator ON, then C(Q) + C(Y) + 1 $\rightarrow$ C(Q)}
\inall
\inina
\ininZ {Q}
\ininN {Q}
\ininO {Q}
\ininC {Q}
\innte { 
The awcq instruction is identical to the adq instruction with the exception
that when the carry indicator is ON at the beginning of the instruction, 1 is
added to the sum of C(Q) and C(Y).}








\subsubsection{Fixed-Point Subtraction}




\ins {sba} {Subtract from A} {175 (0)}
\inbif
\insum {C(A) - C(Y) $\rightarrow$ C(A)}
\inall
\inina
\ininZ {A}
\ininN {A}
\ininO {A}
\ininC {A}


\ins {sbaq} {Subtract from AQ} {177 (0)}
\inbif
\insum {C(AQ) - C(Y-pair) $\rightarrow$ C(AQ)}
\indcs
\inina
\ininZ {AQ}
\ininN {AQ}
\ininO {AQ}
\ininC {AQ}
 
 
 
\ins {sbla} {Subtract Logical from A} {135 (0)}
\inbif
\insum {C(A) - C(Y) $\rightarrow$ C(A)}
\inall
\inina
\ininZ {A}
\ininN {A}
\ininC {A}
\innte {
The sbla instruction is identical to the sba instruction with the exception
that the overflow indicator is not affected by the sbla instruction, nor does
an overflow fault occur. Operands and results are treated as unsigned,
positive binary integers.}





\ins {sblaq} {Subtract Logical from AQ} {137 (0)}
\inbif
\insum {C(AQ) - C(Y-pair) $\rightarrow$ C(AQ)}
\indcs
\inina
\ininZ {AQ}
\ininN {AQ}
\ininC {AQ}
\innte { 
The sblaq instruction is identical to the sbaq instruction with the
exception that the overflow indicator is not affected by the sblaq
instruction, nor does an overflow fault occur. Operands and results are
treated as unsigned, positive binary integers.}






\ins {sblq} {Subtract Logical from Q} {136 (0)}
\inbif
\insum {C(Q) - C(Y) $\rightarrow$ C(Q)} 
\inall
\inina
\ininZ {Q}
\ininN {Q}
\ininC {Q}
\innte { 
The sblq instruction is identical to the sbq instruction with the exception
that the overflow indicator is not affected by the sblq instruction, nor does
an overflow fault occur. Operands and results are treated as unsigned,
positive binary integers.}




\ins {sblxn} {Subtract Logical from Index Register n} {12n (0)}
\inbif
\insum {For n = 0, 1, ..., or 7 as determined by operation code}
\inull {\hspace{1em}C(Xn) - C(Y)0,17 $\rightarrow$ C(Xn)}
\incss
\inina
\ininZ {Xn}
\ininN {Xn}
\ininC {Xn}
\innte {
The sblxn instruction is identical to the sbxn instruction with the
exception that the overflow indicator is not affected by the sblxn
instruction, nor does an overflow fault occur. Operands and results are
treated as unsigned, positive binary integers.}






\ins {sbq} {Subtract from Q} {176 (0)}
\inbif
\insum {C(Q) - C(Y) $\rightarrow$ C(Q)}
\inall
\inina
\ininZ {Q}
\ininN {Q}
\ininO {Q}
\ininC {Q}
 
 
 
\ins {sbxn} {Subtract from Index Register n} {16n (0)}
\inbif
\insum {For n = 0, 1, ..., or 7 as determined by operation code}
\inull {\hspace{1em}C(Xn) - C(Y)0,17 $\rightarrow$ C(Xn)}
\incss
\inina
\ininZ {Xn}
\ininN {Xn}
\ininO {Xn}
\ininC {Xn}
 
 
 
\ins {ssa} {Subtract Stored from A} {155 (0)}
\inbif
\insum {C(A) - C(Y) $\rightarrow$ C(Y)}
\indcs
\inina
\ininZ {Y}
\ininN {Y}
\ininO {Y}
\ininC {Y}
\inrpl




\ins {ssq} {Subtract Stored from Q} {156 (0)}
\inbif
\insum {C(Q) - C(Y) $\rightarrow$ C(Y)}
\indcs
\inina
\ininZ {Y}
\ininN {Y}
\ininO {Y}
\ininC {Y}
\inrpl




 
\ins {ssxn} {Subtract Stored from Index Register n} {14n (0)}
\inbif
\insum {For n = 0, 1, ..., or 7 as determined by operation code}
\inull {\hspace{1em}C(Xn) - C(Y)0,17 $\rightarrow$ C(Y)0,17}
\indcs
\inina
\ininz {If C(Y)\tsb{0,17} = 0, then ON; otherwise OFF}
\ininN {Y}
\ininO {Y\tsp{0,17}}
\ininC {Y}
\inrpl





\ins {swca} {Subtract with Carry from A} {171 (0)}
\inbif
\insum {If carry indicator ON, then C(A)- C(Y) $\rightarrow$ C(A)}
\inull {If carry indicator OFF, then C(A) - C(Y) - 1 $\rightarrow$ C(A)}
\inall
\inina
\ininZ {A}
\ininN {A}
\ininO {A}
\ininC {A}
\innte { 
The swca instruction is identical to the sba instruction with the exception
that when the carry indicator is OFF at the beginning of the instruction, +1
is subtracted from the difference of C(A) minus C(Y). The swca instruction
treats the carry indicator as the complement of a borrow indicator due to
the implementation of negative numbers in twos complement form.}

 
 



\ins {swcq} {Subtract with Carry from Q} {172 (0)}
\inbif
\insum {If carry indicator ON, then C(Q) - C(Y) $\rightarrow$ C(Q)}
\inull {If carry indicator OFF, then C(Q) - C(Y) - 1 $\rightarrow$ C(Q)}
\inall
\inina
\ininZ {Q}
\ininN {Q}
\ininO {Q}
\ininC {Q}
\innte { 
The swcq instruction is identical to the sbq instruction with the exception
that when the carry indicator is OFF at the beginning of the instruction, +1
is subtracted from the difference of C(Q) minus C(Y). The swcq instruction
treats the carry indicator as the complement of a borrow indicator due to
the implementation of negative numbers in twos complement form.}






\subsubsection{Fixed-Point Multiplication}

\ins {mpf} {Multiply Fraction} {401 (0)}
\inbif
\insum {C(A) $\times$ C(Y) $\rightarrow$ C(AQ), left adjusted}
\incss
\inina
\ininZ {AQ}
\ininN {AQ}
\ininO {AQ}
\innte {
Two 36-bit fractional factors (including sign) are multiplied to form a 71bit fractional product (including sign), which is stored left-adjusted in the
AQ register. AQ71 contains a zero. Overflow can occur only in the case of
A and Y containing negative l and the result exceeding the range of the AQ
register.}


\begin{bytefield}{36}
\bitheader{0,1,35} \\
\bitbox{1}{s}
\bitbox{35}{factor C(A)}\\
\end{bytefield}

$\mathlarger{\mathlarger{\mathlarger{\times}}}$

\begin{bytefield}{36}
\bitheader{0,1,35} \\
\bitbox{1}{s}
\bitbox{35}{factor C(Y)}\\
\end{bytefield}


\noindent{yielding}

\begin{bytefield}{72}
\bitheader{0,1,70,71} \\
\bitbox{1}{s}
\bitbox{70}{product C(AQ)}\\
\bitbox{1}{0}
\end{bytefield}





\ins {mpy} {Multiply Integer} {402 (0)}
\inbif
\insum {C(Q) $\times$ C(Y) $\rightarrow$ C(AQ), right adjusted}
\incss
\inina
\ininZ {AQ}
\ininN {AQ}
\innte {
Two 36-bit integer factors (including sign) are multiplied to form a 71-bit
integer product (including sign), which is stored right-adjusted in the AQregister. AQ0 is filled with an {``}extended sign bit''.
In the case of (-2*35) $\times$ (-2**35) = +2**70, AQ 1 is used to represent the
product rather than the sign. No overflow can occur.}

\begin{bytefield}{36}
\bitheader{0,1,35} \\
\bitbox{1}{s}
\bitbox{35}{factor C(A)}\\
\end{bytefield}

$\mathlarger{\mathlarger{\mathlarger{\times}}}$

\begin{bytefield}{36}
\bitheader{0,1,35} \\
\bitbox{1}{s}
\bitbox{35}{factor C(Y)}\\
\end{bytefield}


\noindent{yielding}

\begin{bytefield}{72}
\bitheader{0,1,2,71} \\
\bitbox{1}{s}
\bitbox{1}{s}
\bitbox{70}{product C(AQ)}\\
\end{bytefield}


\subsubsection{Fixed-Point Division}



\ins {div} {Divide Integer} {506 (0)}
\inbif
\insum {C(Q) / (Y) integer quotient $\rightarrow$ C(Q)}
\inull {integer remainder $\rightarrow$ C(A)}
\inall
\inina
\inull {\textbf{\textsl{If division takes place:}}}
\ininZ {Q}
\ininN {Q}
\inull {\textbf{\textsl{If no division takes place:}}}
\ininz {If divisor = 0, then ON; otherwise OFF}
\ininN {If dividend $<$ 0, then ON; otherwise OFF}
\innte {
A 36-bit integer dividend (including sign) is divided by a 36-bit integer
divisor (including sign) to form a 36-bit integer quotient (including sign)
and a 36-bit integer remainder (including sign). The remainder sign is
equal to the dividend sign unless the remainder is zero.}
\innta {
If the dividend = -2**35 and the divisor = -1 or if the divisor = 0, then
division does not take place. Instead, a divide check fault occurs, C(Q)
contains the dividend magnitude, and the negative indicator reflects the
dividend sign.}



\begin{bytefield}{36}
\bitheader{0,1,35} \\
\bitbox{1}{s}
\bitbox{35}{factor C(A)}\\
\end{bytefield}

$\mathlarger{\mathlarger{\mathlarger{/}}}$

\begin{bytefield}{36}
\bitheader{0,1,35} \\
\bitbox{1}{s}
\bitbox{35}{factor C(Y)}\\
\end{bytefield}


\noindent{yielding}

\begin{bytefield}{36}
\bitheader{0,1,35} \\
\bitbox{1}{s}
\bitbox{35}{remainder C(A)}\\
\end{bytefield}

\begin{bytefield}{36}
\bitheader{0,1,35} \\
\bitbox{1}{s}
\bitbox{35}{quotient C(Q)}\\
\end{bytefield}





\ins {dvf} {Divide Fraction} {507 (0)}
\inbif
\insum {C(AQ) / (Y) fractional quotient $\rightarrow$ C(A)}
\inull {fractional remainder $\rightarrow$ C(Q)}
\inall
\inina
\inull {\textbf{\textsl{If division takes place:}}}
\ininZ
\ininN
\inull {\textbf{\textsl{If no division takes place:}}}
\ininz {If divisor = 0, then ON; otherwise OFF}
\ininn {If dividend $<$ 0, then ON; otherwise OFF}
\innte {
A 71-bit fractional dividend (including sign) is divided by a 36-bit fractional
divisor yielding a 36-bit fractional quotient (including sign) and a 36-bit
fractional remainder (including sign). C(AQ)71 is ignored; bit position 35
of the remainder corresponds to bit position 70 of the dividend. The
remainder sign is equal to the dividend sign unless the remainder is zero.}
\innta {
If $|$ dividend $|$ $>$= $|$ divisor $|$ or if the divisor = 0, division does not take
place. Instead, a divide check fault occurs, C(AQ) contains the dividend
magnitude in absolute, and the negative indicator reflects the dividend
sign.}



\begin{bytefield}{72}
\bitheader{0,1,70,71} \\
\bitbox{1}{s}
\bitbox{70}{divedent C(AA)}
\bitbox{1}{x} \\
\end{bytefield}

$\mathlarger{\mathlarger{\mathlarger{/}}}$

\begin{bytefield}{36}
\bitheader{0,1,35} \\
\bitbox{1}{s}
\bitbox{35}{divisor C(Y)}\\
\end{bytefield}

\noindent{yielding}

\begin{bytefield}{36}
\bitheader{0,1,35} \\
\bitbox{1}{s}
\bitbox{35}{quotient C(A)}\\
\end{bytefield}

\begin{bytefield}{36}
\bitheader{0,1,35} \\
\bitbox{1}{s}
\bitbox{35}{remainder C(Q)}\\
\end{bytefield}







\subsubsection{Fixed-Point Negate}

\ins {neg} {Negate A} {531 (0)}
\inbif
\insum {-C(A) $\rightarrow$ C(A) if C(A) $\neq$ 0}
\inmod {All, but none affect instruction execution.}
\inina
\ininZ {A}
\ininN {A}
\ininO {A}

\innte {The neg instruction changes the number in A to its negative (if $\neq$ 0). The
operation is performed by forming the twos complement of the string of 36
bits.}
\innta {
Attempted repetition with the rpl instruction causes an illegal procedure
fault.}





\ins {negl} {Negate Long} {533 (0)}
\inbif
\insum {-C(AQ) $\rightarrow$ C(AQ) if C(AQ) $\neq$ 0}
\inabn
\inina
\ininZ {AQ}
\ininN {AQ}
\ininO {AQ}
\innte {
The negl instruction changes the number in AQ to its negative (if $\neq$ 0).
The operation is performed by forming the twos complement of the string
of 72 bits.}
\inrpa









\subsubsection{Fixed-Point Comparison}

\ins {cmg} {Compare Magnitude} {405 (0)}
\inbif
\insum {$|$ C(A) $|$ :: $|$ C(Y) $|$}
\inall
\inina
\ininz {If $|$ C(A) $|$ = $|$ C(Y) $|$ , then ON; otherwise OFF}
\ininn {If $|$ C(A) $|$ $<$ $|$ C(Y) $|$ , then ON; otherwise OFF}



\ins {cmk} {Compare Masked} {211 (0)}
\inbif
\insum {For i = 0, 1, ..., 35}
\inull {C(Z)i = \~{}C(Q)i \& ( C(A)i $\oplus$ C(Y)i )}
\inall
\inina
\ininZ {Z}
\ininN {Z}
\innte {
The cmk instruction compares the contents of bit positions of A and Y for
identity that are not masked by a 1 in the corresponding bit position of Q.}
\innta {
The zero indicator is set ON if the comparison is successful for all bit
positions; i.e., if for all i = 0, 1, ..., 35 there is either: C(A) i = C(Y)i (the
identical case) or C(Q)i = 1 (the masked case); otherwise, the zero
indicator is set OFF.}
\innta {
The negative indicator is set ON if the comparison is unsuccessful for bit
position 0; i.e., if C(A)0 $\oplus$ C(Y)0 (they are nonidentical) as well as C(Q) 0 = 0
(they are unmasked); otherwise, the negative indicator is set OFF.}










\ins {cmpa} {Compare with A} {115 (0)}
\inbif
\insum {C(A) :: C(Y)}
\inall
\inina
\inull {The zero (Z), negative (N), and carry (C) indicators are set as follows:}
\textbf{\textsl{Algebraic Comparison (Signed Binary Operands)}}\\
\begin{tabular}{c c c l l}
\textit{\textbf{Z}} & 
\textit{\textbf{N}} & 
\textit{\textbf{C}} & 
\textit{\textbf{Relation}} & 
\textit{\textbf{Sign}} \\
0 & 0 & 0 & C(A) $>$ C(Y) & C(A)0 = 0, C(Y)0 = 1 \\
0 & 0 & 1 & C(A) $>$ C(Y) & C(A)0 = C(Y)0 \\
1 & 0 & 1 & C(A) = C(Y) & C(A)0 = C(Y)0 \\
0 & 1 & 0 & C(A) $<$ C(Y) & C(A)0 = C(Y)0 \\
0 & 1 & 1 & C(A) $<$ C(Y) & C(A)0 = 1, C(Y)0 = 0 \\
\end{tabular} \\
\textbf{\textsl{Logical Comparison (Unsigned Positive Binary Operands)}}\\
\begin{tabular}{c c l}
\textit{\textbf{Z}} & 
\textit{\textbf{C}} & 
\textit{\textbf{Relation}} \\
0 & 0 & C(A) $<$ C(Y) \\
1 & 1 & C(A) = C(Y) \\
0 & 1 & C(A) $>$ C(Y) \\
\end{tabular}






\ins {cmpaq} {Compare with AQ} {117 (0)}
\inbif
\insum {C(AQ) :: C(Y-pair)}
\indcs
\inina
\inull {The zero (Z), negative (N), and carry (C) indicators are set as follows:}
\textbf{\textsl{Algebraic Comparison (Signed Binary Operands)}}\\
\begin{tabular}{c c c l l}
\textit{\textbf{Z}} & 
\textit{\textbf{N}} & 
\textit{\textbf{C}} & 
\textit{\textbf{Relation}} & 
\textit{\textbf{Sign}} \\
0 & 0 & 0 & C(AQ) $>$ C(Y-pair) & C(AQ)0 = 0, C(Y-pair)0 = 1 \\
0 & 0 & 1 & C(AQ) $>$ C(Y-pair) & C(AQ)0 = C(Y-pair)0 \\
1 & 0 & 1 & C(AQ) = C(Y-pair) & C(AQ)0 = C(Y-pair)0 \\
0 & 1 & 0 & C(AQ) $<$ C(Y-pair) & C(AQ)0 = C(Y-pair)0 \\
0 & 1 & 1 & C(AQ) $<$ C(Y-pair) & C(AQ)0 = 1, C(Y-pair)0 = Q \\
\end{tabular} \\
\textit{\textbf{Logical Comparison (Unsigned Positive Binary Operands)}}\\
\begin{tabular}{c c l}
\textit{\textbf{Z}} & 
\textit{\textbf{C}} & 
\textit{\textbf{Relation}} \\
0 & 0 & C(Xn) $<$ C(Y)0,17 \\
1 & 1 & C(Xn) $=$ C(Y)0,17 \\
0 & 1 & C(Xn) $>$ C(Y)0,17 \\
\end{tabular}












\ins {cmpq} {Compare with Q} {116 (0)}
\inbif
\insum {C(Q) :: C(Y)}
\inall
\inina
\inull {The zero (Z), negative (N), and carry (C) indicators are set as follows:}
\textbf{\textsl{Algebraic Comparison (Signed Binary Operands)}}\\
\begin{tabular}{c c c l l}
\textit{\textbf{Z}} & 
\textit{\textbf{N}} & 
\textit{\textbf{C}} & 
\textit{\textbf{Relation}} & 
\textit{\textbf{Sign}} \\
0 & 0 & 0 & C(Q) $>$ C(Y) & C(Q)0 = 0, C(Y)0 = 1 \\
0 & 0 & 1 & C(Q) $>$ C(Y) & C(Q)0 = C(Y)0 \\
1 & 0 & 1 & C(Q) = C(Y) & C(Q)0 = C(Y)0 \\
0 & 1 & 0 & C(Q) $<$ C(Y) & C(Q)0 = C(Y)0 \\
0 & 1 & 1 & C(Q) $<$ C(Y) & C(Q)0 = 1, C(Y)0 = 0 \\
\end{tabular} \\
\textbf{\textsl{Logical Comparison (Unsigned Positive Binary Operands)}}\\
\begin{tabular}{c c l}
\textit{\textbf{Z}} & 
\textit{\textbf{C}} & 
\textit{\textbf{Relation}} \\
0 & 0 & C(Q) $<$ C(Y) \\
1 & 1 & C(Q) = C(Y) \\
0 & 1 & C(Q) $>$ C(Y) \\
\end{tabular}








\ins {cmpxn} {Compare with Index Register n} {10n (0)}
\inbif
\insum {For n = 0, 1, ..., or 7 as determined by operation code}
\inull {\hspace{1em}C(Xn) :: C(Y)0,17}
\incss
\inina
\textbf{\textsl{Algebraic Comparison (Signed Binary Operands)}}\\
\begin{tabular}{c c c l l}
\textit{\textbf{Z}} & 
\textit{\textbf{N}} & 
\textit{\textbf{C}} & 
\textit{\textbf{Relation}} & 
\textit{\textbf{Sign}} \\
0 & 0 & 0 & C(Xn) $>$ C(Y)0,17 & C(Xn)0 = 0, C(Y)0 = 1 \\
0 & 0 & 1 & C(Xn) $>$ C(Y)0,17 & C(Xn)0 = C(Y)0 \\
1 & 0 & 1 & C(Xn) = C(Y)0,17 & C(Xn)0 = C(Y)0 \\
0 & 1 & 0 & C(Xn) $<$ C(Y)0,17 & C(Xn)0 = C(Y)0 \\
0 & 1 & 1 & C(Xn) $<$ C(Y)0,17 & C(Xn)0 = 1, C(Y)0 = 0 \\
\end{tabular} \\
\textbf{\textsl{Logical Comparison (Unsigned Positive Binary Operands)}}\\
\begin{tabular}{c c l}
\textit{\textbf{Z}} & 
\textit{\textbf{C}} & 
\textit{\textbf{Relation}} \\
0 & 0 & C(Xn) $<$ C(Y)0,17 \\
1 & 1 & C(Xn) = C(Y)0,17 \\
0 & 1 & C(Xn) $>$ C(Y)0,17 \\
\end{tabular}




\ins {cwl} {Compare with Limits} {111 (0)}
\inbif
\insum {C(Y) :: closed interval [C(A);C(Q)]}
\inull {C(Y) :: C(Q)}
\inall
\inina
\ininz {If C(A) $<$= C(Y) $<$= C(Q) or C(A) $>$= C(Y) $>$= C(Q), then ON; otherwise OFF.}
\inull {The negative (N) and carry (C) indicators are set as follows:}
\begin{tabular}{c c l l}
\textit{\textbf{N}} & 
\textit{\textbf{C}} & 
\textit{\textbf{Relation}} & 
\textit{\textbf{Sign}} \\
0 & 0 & C(Q) $>$ C(Y) & C(Q)0 = 0, C(Y)0 = 1 \\
0 & 1 & C(Q) $>$= C(Y) & C(Q)0 = C(Y)0 \\
1 & 0 & C(Q) $<$ C(Y) & C(Q)0 = C(Y)0 \\
1 & 1 & C(Q) $<$ C(Y) & C(Q)0 = 1, C(Y)0 = Q \\
\end{tabular} \\

\innte {
The cwl instruction tests the value of C(Y) to determine if it is within the
range of values set by C(A) and C(Q). The comparison of C(Y) with C(Q)
locates C(Y) with respect to the interval if C(Y) is not contained within the
interval.}







\subsubsection{Fixed-Point Miscellaneous}

\ins {szn} {Set Zero and Negative Indicators} {234 (0)}
\inbif
\insum {Set indicators according to C(Y)}
\inall
\inina
\ininZ {Y}
\ininN {Y}




\ins {sznc} {Set Zero and Negative Indicators and Clear} {214 (0)}
\inbif
\insum {Set indicators according to C(Y)}
\inull {00\ldots0 $\rightarrow$ C(Y)}
\indcs
\inina
\ininZ {Y}
\ininN {Y}





\subsection{BOOLEAN OPERATION INSTRUCTIONS}

\subsubsection{Boolean And}

\ins {ana} {AND to A} {375 (0)}
\inbif
\insum {C(A)i \& C(Y)i $\rightarrow$ C(A)i for i = (0, 1, ..., 35)}
\inall
\inina
\ininZ {A}
\ininN {A}




\ins {anaq} {AND to AQ} {377(0)}
\inbif
\insum {C(AQ)i \& C(Y-pair)i $\rightarrow$ C(AQ)i for i = (0, 1, ..., 71)}
\indcs
\inina
\ininZ {AQ}
\ininN {AQ}



\ins {anq} {AND to Q} {376 (0)}
\inbif
\insum {C(Q)i \& C(Y)i $\rightarrow$ C(Q)i for i = (0, 1, ..., 35)}
\inall
\inina
\ininZ {Q}
\ininN {Q}








\ins {ansa} {AND to Storage A} {355 (0)}
\inbif
\insum {A} {C(A)i \& C(Y)i $\rightarrow$ C(Y)i for i = (0, 1, ..., 35)}
\indcs
\inina
\ininZ {Y}
\ininN {Y}
\inrpl



\ins {ansq} {AND to Storage Q} {356 (0)}
\inbif
\insum {C(Q)i \& C(Y)i $\rightarrow$ C(Y)i for i = (0, 1, ..., 35)}
\indcs
\inina
\ininZ  {Y}
\ininN {Y}
\inrpl





\ins {ansxn} {AND to Storage Index Register n} {34n (0)}
\inbif
\insum {For n = 0, 1, ..., or 7 as determined by operation code}
\inull {\hspace{1em}C(Xn)i \& C(Y)i $\rightarrow$ C(Y)i for i = (0, 1, ..., 17)}
\indcs
\inina
\ininz {If C(Y)\tsb{0,17i} = 0, then ON; otherwise OFF}
\ininN {Y}
\inrpl







\ins {anxn} {AND to Index Register n} {36n (0)}
\inbif
\insum {A}For n = 0, 1, ..., or 7 as determined by operation code
\inull {\hspace{1em}C(Xn)i \& C(Y)i $\rightarrow$ C(Xn)i for i = (0, 1, ..., 17)}
\incss
\inina
\ininZ {Xn}
\ininN {Xn}








\subsubsection{Boolean Or}

\ins {ora} {OR to A} {275 (0)}
\inbif
\insum {C(A)i $|$ C(Y)i $\rightarrow$ C(A)i for i = (0, 1, ..., 35)}
\inall
\inina
\ininZ {A}
\ininN {A}



\ins {oraq} {OR to AQ} {277 (0)}
\inbif
\insum {C(AQ)i $|$ C(Y-pair)i $\rightarrow$ C(AQ)i for i = (0, 1, ..., 71)}
\indcs
\inina
\ininZ {AQ}
\ininN {AQ}





\ins {orq} {OR to Q} {276 (0)}
\inbif
\insum {C(Q)i $|$ C(Y)i $\rightarrow$ C(Q)i for i = (0, 1, ..., 35)}
\inall
\inina
\ininZ {Q}
\ininN {Q}





\ins {orsa} {OR to Storage A} {255 (0)}
\inbif
\insum {C(A)i $|$ C(Y)i $\rightarrow$ C(Y)i for i = (0, 1, ..., 35)}
\indcs
\inina
\ininZ {Y}
\ininN {Y}
\inrpl








\ins {orsq} {OR to Storage Q} {256 (0)}
\inbif
\insum {C(Q)i $|$ C(Y)i $\rightarrow$ C(Y)i for i = (0, 1, ..., 35)}
\indcs
\inina
\ininZ {Y}
\ininN {Y}
\inrpl





\ins {orsxn} {OR to Storage Index Register n} {24n (0)}
\inbif
\insum {For n = 0, 1, ..., or 7 as determined by operation code}
\inull {\hspace{1em}C(Xn)i $|$ C(Y)i $\rightarrow$ C(Y)i for i = (0, 1, ..., 17)}
\indcs
\inina
\ininz {If C(Y)\tsp{0,17} = 0, then ON; otherwise OFF}
\ininN {Y}
\inrpl






\ins {orxn} {OR to Index Register n} {26n (0)}
\inbif
\insum {For n = 0, 1, ..., or 7 as determined by operation code}
\insum {\hspace{1em}C(Xn)i $|$ C(Y)i $\rightarrow$ C(Xn)i for i = (0, 1, ..., 17)}
\incss
\inina
\ininZ {Xn}
\ininN {Xn}





\subsubsection{Boolean Exclusive Or}




\ins {era} {EXCLUSIVE OR to A} {675 (0)}
\inbif
\insum {C(A)i $\oplus$ C(Y)i $\rightarrow$ C(A)i for i = (0, 1, ..., 35)}
\inall
\inina
\ininZ {A}
\ininN {A}



\ins {eraq} {EXCLUSIVE OR to AQ} {677 (0)}
\inbif
\insum {C(AQ)i $\oplus$ C(Y-pair)i $\rightarrow$ C(AQ)i for i = (0, 1, ..., 71)}
\indcs
\inina
\ininZ {AQ}
\ininN {AQ}








\ins {erq} {EXCLUSIVE OR to Q} {676 (0)}
\inbif
\insum {C(Q)i $\oplus$ C(Y)i $\rightarrow$ C(Q)i for i = (0, 1, ..., 35)}
\inall
\inina
\ininZ {Q}
\ininN {Q}






\ins {ersa} {EXCLUSIVE OR to Storage A} {655 (0)}
\inbif
\insum {C(A)i $\oplus$ C(Y)i $\rightarrow$ C(Y)i for i = (0, 1, ..., 35)}
\indcs
\inina
\ininZ {Y}
\ininN {Y}
\inrpl






\ins {ersq} {EXCLUSIVE OR to Storage Q} {656 (0)}
\inbif
\insum {C(Q)i $\oplus$ C(Y)i $\rightarrow$ C(Y)i for i = (0, 1, ..., 35)}
\indcs
\inina
\ininZ {Y}
\ininN {Y}
\inrpl








\ins {ersxn} {EXCLUSIVE OR to Storage Index Register n} {64n (0)}
\inbif
\insum {For n = 0, 1, ..., or 7 as determined by operation code}
\inull {\hspace {1em}C(Xn)i $\oplus$ C(Y)i $\rightarrow$ C(Y)i for i = (0, 1, ..., 17)}
\indcs
\inina
\ininz {If C(Y)\tsb{0,17} = 0, then ON; otherwise OFF}
\ininN {Y}
\inrpl





 
\ins {erxn} {EXCLUSIVE OR to Index Register n} {66n (0)}
\inbif
\insum {For n = 0, 1, ..., or 7 as determined by operation code}
\inull {\hspace{1em}C(Xn)i $\oplus$ C(Y)i $\rightarrow$ C(Xn)i for i = (0, 1, ..., 17)}
\incss
\inina
\ininZ {Xn}
\ininN {Xn}





\subsubsection{Boolean Comparative And}




\ins {cana} {Comparative AND with A} {315 (0)}
\inbif
\insum {C(Z)i = C(A)i \& C(Y)i for i = (0, 1, ..., 35)}
\inall
\inina
\ininZ {Z}
\ininN {Z}




 
\ins {canaq} {Comparative AND with AQ} {317 (0)}
\inbif
\insum {C(Z)i = C(AQ)i \& C(Y-pair)i for i = (0, 1, ..., 71)}
\indcs
\inina
\ininZ {Z}
\ininN {Z}






\ins {canq} {Comparative AND with Q} {316 (0)}
\inbif
\insum {C(Z)i = C(Q)i \& C(Y)i for i = (0, 1, ..., 35)}
\inall
\inina
\ininZ {Z}
\ininN {Z}
 




\ins {canxn} {Comparative AND with Index Register n} {30n (0)}
\inbif
\insum {For n = 0, 1, ..., or 7 as determined by operation code}
\inull {\hspace{1em}C(Z)i = C(Xn)i \& C(Y)i for i = (0, 1, ..., 17)}
\incss
\inina
\ininZ {Z}
\ininN {Z}




\subsubsection{Boolean Comparative Not}




\ins {cnaa} {Comparative NOT with A} {215 (0}
\inbif
\insum {C(Z)i = C(A)i \& \~{}C(Y)i for i = (0, 1, ..., 35)}
\inall
\inina
\ininZ {Z}
\ininN {Z}






\ins {cnaaq} {Comparative NOT with AQ} {217 (0)}
\inbif
\insum {C(Z)i = C (AQ)i \& \~{}C(Y-pair)i for i = (0, 1, ..., 71)}
\indcs
\inina
\ininZ {Z}
\ininN {Z}







\ins {cnaq} {Comparative NOT with Q} {216 (0)}
\inbif
\insum {C(Z)i = C(Q)i \& \~{}C(Y)i for i = (0, 1, ..., 35)}
\inall
\inina
\ininZ {Z}
\ininN {Z}







\ins {cnaxn} {Comparative NOT with Index Register n} {20n (0)}
\inbif
\insum {For n = 0, 1, ..., or 7 as determined by operation code}
\inull {\hspace{1em}C(Z)i = C(Xn)i \& \~{}C(Y)i for i = (0, 1, ..., 17)}
\incss
\inina
\ininZ {Z}
\ininN {Z}





\subsection{FLOATING-POINT ARITHMETIC INSTRUCTIONS}

\subsubsection{Floating-Point Data Movement Load}

\ins {dfld} {Double-Precision Floating Load} {433 (0)}
\inbif
\insum {C(Y-pair)0,7 $\rightarrow$ C(E)}
\inull {hspace{1em}C(Y-pair)8,71 $\rightarrow$ C(AQ)0,63}
\inull {hspace{1em}00...0 $\rightarrow$ C(AQ)64,71}
\indcs
\inina
\ininZ {AQ}
\ininN {AQ}







\ins {fld} {Floating Load} {431 (0)}
\inbif
\insum {C(Y)0,7 $\rightarrow$ C(E)}
\inull {hspace{1em}C(Y)8,35 $\rightarrow$ C(AQ)0,27}
\inull {hspace{1em} 00...0 $\rightarrow$ C(AQ)30,71}
\incss
\inina
\ininZ {AQ}
\ininN {AQ}







\subsubsection{Floating-Point Data Movement Store}








\ins {dfst} {Double-Precision Floating Store} {457 (0)}
\inbif
\insum {C(E) $\rightarrow$ C(Y-pair)0,7}
\inull {hspace{1em}C(AQ)0,63 $\rightarrow$ C(Y-pair)8,71}
\indcs
\innaf
\inrpl











\ins {dfstr} {Double-Precision Floating Store Rounded} {472 (0)}
\inbif
\insum {C(EAQ) rounded $\rightarrow$ C(Y-pair) (as in dfst)}
\indcs
\inina
\ininZ {Y-pair}
\ininn {If C(Y-pair)\tsb{8} = 1, then ON; otherwise OFF}
\ineou 
\innte {
The dfstr instruction performs a double-precision true round and
normalization on C(EAQ) as it is stored.}
\innta {
The definition of true round is located under the description of the frd
instruction.}
\innta {
The definition of normalization is located under the description of the fno
instruction.}
\innta {
Except for the precision of the stored result, the dfstr instruction is
identical to the fstr instruction.}
\inrpa



\ins {fst} {Floating Store} {455 (0)}
\inbif
\insum {C(E) $\rightarrow$ C(Y)0,7}
\inull {hspace{1em}C(A)0,27 $\rightarrow$ C(Y)8,35}
\indcs
\innaf
\inrpl
 




\ins {fstr} {Floating Store Rounded} {470 (0)}
\inbif
\insum {C(EAQ) rounded $\rightarrow$ C(Y) (as in fst)}
\indcs
\inina
\ininz {If C(Y) = floating point 0, then ON; otherwise OFF}
\ininn {If C(Y)\tsb{8} = 1, then ON; otherwise OFF}
\ineou 
\innte {
The fstr instruction performs a true round and normalization on C(EAQ)
as it is stored.}
\innta {
The definition of true round is located under the description of the frd
instruction.}
\innta {
The definition of normalization is located under the description of the fno
instruction.}
\inrpa




\subsubsection{Floating-Point Addition}

\ins {dfad} {Double-Precision Floating Add} {477 (0)}
\inbif
\insum {\textbf{(} C(EAQ) + C(Y-pair) \textbf{)} normalized $\rightarrow$ C(EAQ)}
\indcs
\inina
\ininZ {AQ}
\ininN {AQ}
\ineou 
\ininC {AQ}
 
\innte {
 The dfad instruction may be thought of as a dufa instruction followed by a
fno instruction. }
\innta {
The definition of normalization is located under the description of the fno
instruction.}
 




\ins {dufa} {Double-Precision Unnormalized Floating Add} {437 (0)}
\inbif
\insum {C(EAQ) + C(Y-pair) $\rightarrow$ C(EAQ)}
\indcs
\inina
\ininZ {AQ}
\ininN {AQ}
\ineou 
\ininC {AQ}
\innte { 
Except for the precision of the mantissa of the operand from main memory,
the dufa instruction is identical to the ufa instruction.}
 




\ins {fad} {Floating Add} {475 (0)}
\inbif
\insum {\textbf{(} C(EAQ) + C(Y)]textbf{)} normalized $\rightarrow$ C(EAQ)}
\incss
\inina
\ininZ {AQ}
\ininN {AQ}
\ineou 
\ininC {AQ}
\innte { 
The fad instruction may be thought of a an ufa instruction followed by a
fno instruction.}
\innta {
The definition of normalization is located under the description of the fno
instruction.}




\ins {ufa} {Unnormalized Floating Add} {435 (0)}
\inbif
\insum {C(EAQ) + C(Y) $\rightarrow$ C(EAQ)}
\incss
\inina
\ininZ {AQ}
\ininN {AQ}
\ineou 
\ininC {AQ}
 
% XXX manual line breaks
\innte {The ufa instruction is executed as follows:}
\innta {\hspace{1em}The mantissas are aligned by shifting the mantissa of the operand}
\innta {\hspace{1em}having the algebraically smaller exponent to the right the number of}
\innta {\hspace{1em}places equal to the absolute value of the difference in the two}
\innta {\hspace{1em}exponents. Bits shifted beyond the bit position equivalent to AQ71 are}
\innta {\hspace{1em}lost.}
\innta {\hspace{1em}The algebraically larger exponent replaces C(E).}
\innta {\hspace{1em}The sum of the mantissas replaces C(AQ).}
\innta {\hspace{1em}If an overflow occurs during addition, then;}
\innta {\hspace{2em}C(AQ) are shifted one place to the right.}
\innta {\hspace{2em}C(AQ)0 is inverted to restore the sign.}
\innta {\hspace{2em}C(E) is increased by one.}






\subsubsection{Floating-Point Subtraction}

\ins {dfsb} {Double-Precision Floating Subtract} {577 (0)}
\inbif
\insum {\textbf{(} C(EAQ) -- C(Y-pair)\textbf{)} normalized $\rightarrow$ C(EAQ)}
\indcs
\inina
\ininZ {AQ}
\ininN {AQ}
\ineou 
\ininC {AQ}
\innta {
The dfsb instruction is identical to the dfad instruction with the exception
that the twos complement of the mantissa of the operand from main
memory is used.}




\ins {dufs} {Double-Precision Unnormalized Floating Subtract} {537 (0)}
\inbif
\insum {C(EAQ) - C(Y-pair) $\rightarrow$ C(EAQ)}
\indcs
\inina
\ininZ {AQ}
\ininN {AQ}
\ineou 
\ininC {AQ}
\innte {
Except for the precision of the mantissa of the operand from main memory,
the dufs instruction is identical with the ufs instruction.}





\ins {fsb} {Floating Subtract} {575 (0)}
\inbif
\insum {\textbf{(} C(EAQ) -- C(Y) \textbf{)} normalized $\rightarrow$ C(EAQ)}}
\incss
\inina
\ininZ {AQ}
\ininN {AQ}
\ineou 
\ininC {AQ}
\innte {
The fsb instruction may be thought of as an ufs instruction followed by a
fno instruction.}
\innta {
The definition of normalization is located under the description of the fno
instruction.}




\ins {ufs} {Unnormalized Floating Subtract} {535 (0)}
\inbif
\insum {C(EAQ) - C(Y) $\rightarrow$ C(EAQ)}
\incss
\inina
\ininZ {AQ}
\ininN {AQ}
\ineou 
\ininC {AQ}
\innte {
The ufs instruction is identical to the ufa instruction with the exception
that the twos complement of the mantissa of the operand from main
memory is used.}




\subsubsection{Floating-Point Multiplication}

\ins {dfmp} {Double-Precision Floating Multiply} {463 (0)}
\inbif
\insum {( C(EAQ) $\times$ C(Y-Pair) ) normalized $\rightarrow$ C(EAQ)}
\indcs
\inina
\ininZ {AQ}
\ininN {AQ}
\ineou 
\innte {
The dfmp instruction may be thought of as a dufm instruction followed by a
fno instruction.}
\innta {
The definition of normalization is located under the description of the fno
instruction.}




\ins {dufm} {Double-Precision Unnormalized Floating Multiply} {423 (0)}
\inbif
\insum {C(EAQ) $\times$ C(Y-pair) $\rightarrow$ C(EAQ)}
\indcs
\inina
\ininZ {AQ}
\ininN {AQ}
\ineou 
\innte {
Except for the precision of the mantissa of the operand from main memory,
the dufm instruction is identical to the ufm instruction.}






\ins {fmp} {Floating Multiply} {461 (0)}
\inbif
\insum {( C(EAQ) $\times$ C(Y) ) normalized $\rightarrow$ C(EAQ)}
\incss
\inina
\ininZ {AQ}
\ininN {AQ}
\ineou 
\innte {
The fmp instruction may be thought of as a ufm instruction followed by a
fno instruction.}
\innta {
The definition of normalization is located under the description of the fno
instruction.
}




\ins {ufm} {Unnormalized Floating Multiply} {421 (0)}
\inbif
\insum {C(EAQ) $\times$ C(Y) $\rightarrow$ C(EAQ)}
\incss
\inina
\ininZ {AQ}
\ininN {AQ}
\ineou 
\innte {
The ufm instruction is executed as follows:}
\innta {
\hspace{1em}C(E) + C(Y)0,7 $\rightarrow$ C(E)}
\innta {
\hspace{1em}\textbf{(} C(AQ) $\times$ C(Y)8,35 \textbf{)0},71 $\rightarrow$ C(AQ)}
\innta {
A normalization is performed only in the case of both factor mantissas
being 100...0 which is the twos complement approximation to the decimal
value -1.0.}
\innta {
The definition of normalization is located under the description of the fno
instruction.}

\subsubsection{Floating-Point Division}

\ins {dfdi} {Double-Precision Floating Divide Inverted} {527 (0)}
\inbif
\insum {C(Y-pair) / C(EAQ) $\rightarrow$ C(EAQ)}
\indcs
\inina
\inull {\textbf{\textsl{If division takes place:}}}
\ininZ {AQ}
\ininN {AQ}
\inull {\textbf{\textsl{If no division takes place:}}}
\ininz {If divisor mantissa = 0, then ON; otherwise OFF}
\ininn {If dividend $<$ 0, then ON; otherwise OFF}
\ineou 
\innte {
Except for the interchange of the roles of the operands, the execution of
the dfdi instruction is identical to the execution of the dfdv instruction.\\
& If the divisor mantissa C(AQ) is zero, the division does not take place.
Instead, a divide check fault occurs and all registers remain unchanged.}





\ins {dfdv} {Double-Precision Floating Divide} {567 (0)}
\inbif
\insum {C(EAQ) / C(Y-pair) $\rightarrow$ C(EAQ)}
\indcs
\inina
\inull {\textbf{\textsl{If division takes place:}}}
\ininZ {AQ}
\ininN {AQ}
\inull {\textbf{\textsl{If no division takes place:}}}
\ininz {If divisor mantissa = 0, then ON; otherwise OFF}
\ininn {If dividend $<$ 0, then ON; otherwise OFF}
\ineou 
\innte {
The dfdv instruction is executed as follows: \\
& The dividend mantissa C(AQ) is shifted right and the dividend exponent \\
& \hspace{1em}C(E) increased accordingly until \\
& \hspace{1em}$|$ C(AQ)0,63 $|$ $<$ $|$ C(Y-pair)8,71 $|$ \\
& \hspace{1em}C(E) - C(Y-pair)0,7 $\rightarrow$ C(E) \\
& \hspace{1em}C(AQ) / C(Y-pair)8,71 $\rightarrow$ C(AQ)0,63 \\
& \hspace{1em}00\ldots0 $\rightarrow$ C(Q)64,71 \\
& If the divisor mantissa C(Y-pair)8,71 is zero after alignment, the division
does not take place. Instead, a divide check fault occurs, C(AQ) contains
the dividend magnitude, and the negative indicator reflects the dividend
sign.}







\ins {fdi} {Floating Divide Inverted} {525 (0)}
\inbif
\insum {C(Y) / C(EAQ) $\rightarrow$ C(EA)}
\inull {00\ldots0 $\rightarrow$ C(Q)}
\incss
\inina
\inull {\textbf{\textsl{If division takes place:}}}
\ininZ {A}
\ininN {A}
\inull {\textbf{\textsl{If no division takes place:}}}
\ininz {If divisor mantissa = 0, then ON; otherwise OFF}
\ininn {If dividend $<$ 0, then ON; otherwise OFF}
\ineou 
\innte {
Except for the interchange of roles of the operands, the execution of the
fdi instruction is identical to the execution of the fdv instruction.\\
& If the divisor mantissa C(AQ) is zero, the division does not take place.
Instead, a divide check fault occurs and all the registers remain
unchanged.}



\ins {fdv} {Floating Divide} {565 (0)}
\inbif
\insum {C(EAQ) /C(Y) $\rightarrow$ C(EA)}
\inull {00\ldots0 $\rightarrow$ C(Q)}
\incss
\inina
\inull {\textbf{\textsl{If division takes place:}}}
\ininZ {A}
\ininN {A}
\inull {\textbf{\textsl{If no division takes place:}}}
\ininz {If divisor mantissa = 0, then ON; otherwise OFF}
\ininn {If dividend $<$ 0, then ON; otherwise OFF}
\ineou 
\innte {
The fdv instruction is executed as follows: \\
& The dividend mantissa C(AQ) is shifted right and the dividend exponent
C(E) increased accordingly until \\
& \hspace{1em}$|$ C(AQ)0,27 $|$ $<$ $|$ C(Y)8,35 $|$ \\
& \hspace{1em}C(E) - C(Y)0,7 $\rightarrow$ C(E) \\
& \hspace{1em}C(AQ) / C(Y)8,35 $\rightarrow$ C(A) \\
& \hspace{1em}00...0 $\rightarrow$ C(Q) \\
& If the divisor mantissa C(Y)8,35 is zero after alignment, the division does
not take place. Instead, a divide check fault occurs, C(AQ) contains the
dividend magnitude, and the negative indicator reflects the dividend sign.}



\subsubsection{Floating-Point Negate}

%= fneg
%= Floating Negate
%= 513 (0)

\inbif

\insum {-C(EAQ) normalized $\rightarrow$ C(EAQ)}
\inabn
\inina
\ininZ {AQ}
\ininN {AQ}
\ineou 
%= NOTES:
%= This instruction changes the number in C(EAQ) to its normalized negative
%= (if C(AQ) $\neq$ 0). The operation is executed by first forming the twos
%= complement of C(AQ), and then normalizing C(EAQ).
%= Even if originally C(EAQ) were normalized, an exponent overflow can still
%= occur, namely when C(E) = +127 and C(AQ) = 100...0 which is the twos
%= complement approximation for the decimal value -1.0.
%= The definition of normalization may be found under the description of the
%= fno instruction.
%= Attempted repetition with the rpl instruction causes an illegal procedure
%= fault.

\subsubsection{Floating-Point Normalize}

%= fno
%= Floating Normalize
%= 573 (0)

\inbif
\insum {C(EAQ) normalized $\rightarrow$ C(EAQ)}
\inabn
\inina
\ininz {If C(EAQ) = floating point 0, then ON; otherwise OFF}
\ininN {AQ}
\ineou 
\inino {Set OFF}
%= NOTES:
%= The fno instruction normalizes the number in C(EAQ) if C(AQ) $\neq$ 0 and the
%= overflow indicator is OFF.
%= A normalized floating number is defined as one whose mantissa lies in the
%= interval [0.5,1.0] such that
%= 0.5 $<$= $|$ C(AQ) $|$ $<$ 1.0
%= which, in turn, requires that C(AQ)0 $\neq$ C(AQ)1.
%= If the overflow indicator is ON, then C(AQ) is shifted one place to the right,
%= C(AQ)0 is inverted to reconstitute the actual sign, and the overflow
%= indicator is set OFF. This action makes the fno instruction useful in
%= correcting overflows that occur with fixed point numbers.
%= Normalization is performed by shifting C(AQ)1,71 one place to the left and
%= reducing C(E) by 1, repeatedly, until the conditions for C(AQ)0 and C(AQ)1
%= are met. Bits shifted out of AQ1 are lost.
%= If C(AQ) = 0, then C(E) is set to -128 and the zero indicator is set ON.
%= Attempted repetition with the rpl instruction causes an illegal procedure
%= fault.

\subsubsection{Floating-Point Round}

%= dfrd
%= Double-Precision Floating Round

\inbif
\insum {C(EAQ) rounded to 64 bits $\rightarrow$ C(EAQ)}
\inull {0 $\rightarrow$ C(AQ)65,71}
\inabn
\inina
\ininz {If C(EAQ) = floating point 0, then ON; otherwise OFF}
\ininN {AQ}
\ineou 
%= NOTES:
%= The dfrd instruction is identical to the frd instruction except that the
%= rounding constant used is (11...1)65,71 instead of (11...1)29,71.
%= Attempted repetition with the rpl instruction causes an illegal procedure
%= fault





%= frd
%= Floating Round

\inbif
\insum {C(EAQ) rounded to 28 bits $\rightarrow$ C(EAQ)}
\inull {0 $\rightarrow$ C(AQ)29,71}
\inabn
\inina
\ininz {If C(EAQ) = floating point 0, then ON; otherwise OFF}
\ininN {AQ}
\ineou 
%= NOTES:
%= If C(AQ) $\neq$ 0, the frd instruction performs a true round to a precision of 28
%= bits and a normalization on C(EAQ).
%= A true round is a rounding operation such that the sum of the result of
%= applying the operation to two numbers of equal magnitude but opposite
%= sign is exactly zero.
%= The frd instruction is executed as follows:
%= C(AQ) + (11...1)29,71 $\rightarrow$ C(AQ)
%= If C(AQ)0 = 0, then a carry is added at AQ71
%= If overflow occurs, C(AQ) is shifted one place to the right and C(E) is
%= increased by 1.
%= If overflow does not occur, C(EAQ) is normalized.
%= If C(AQ) = 0, C(E) is set to -128 and the zero indicator is set ON.
%= Attempted repetition with the rpl instruction causes an illegal procedure
%= fault.
%= \end{flushleft}

\subsubsection{Floating-Point Compare}

%= dfcmg
%= Double-Precision Floating Compare Magnitude

\inbif
\insum {C(E) :: C(Y-pair)0,7}
\inull {$|$ C(AQ)0,63 $|$ :: $|$ C(Y-pair)8,71 $|$}
\indcs
\inina
\ininz {If $|$ C(EAQ) $|$ = $|$ C(Y-pair) $|$ , then ON; otherwise OFF}
\ininn {If $|$ C(EAQ) $|$ $<$ $|$ C(Y-pair) $|$ , then ON; otherwise OFF}

%= NOTES:
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= dfcmp
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= The dfcmg instruction is identical to the dfcmp instruction except that the
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= magnitudes of the mantissas are compared instead of the algebraic values.
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Double-Precision Floating Compare
%= \end{flushleft}
%= 
%= 
%= 

\inbif
\insum {C(E) :: C(Y-pair)0,7}
\inull {C(AQ)0,63 :: C(Y-pair)8,71}
\indcs
\inina
\ininz {If C(EAQ) = C(Y-pair), then ON; otherwise OFF}
\ininn {If C(EAQ) $<$ C(Y-pair), then ON; otherwise OFF}

%= NOTES:
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= fcmg
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= The dfcmp instruction is identical to the fcmp instruction except for the
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= precision of the mantissas actually compared.
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Floating Compare Magnitude
%= \end{flushleft}
%= 
%= 
%= 

\inbif
\insum {C(E) :: C(Y)0,7}
\inull {$|$ C(AQ)0,27 $|$ :: $|$ C(Y)8,35 $|$}
\incss
\inina
\ininz {If $|$ C(EAQ) $|$ = $|$ C(Y) $|$ , then ON; otherwise OFF}
\ininn {If $|$ C(EAQ) $|$ $<$ $|$ C(Y) $|$ , then ON; otherwise OFF}

%= NOTES:
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= The fcmg instruction is identical to the fcmp instruction except that the
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= magnitudes of the mantissas are compared instead of the algebraic values.
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= \newpage
%= fcmp
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Floating Compare
%= \end{flushleft}
%= 
%= 
%= 

\inbif
\insum {C(E) :: C(Y)0,7}
\inull {C(AQ)0,27 :: C(Y)8,35}
\incss
\inina
\ininz {If C(EAQ) = C(Y), then ON; otherwise OFF}
\ininz {If C(EAQ) $<$ C(Y), then ON; otherwise OFF}

%= NOTES:
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= The fcmp instruction is executed as follows:
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= The mantissas are aligned by shifting the mantissa of the operand with
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= the algebraically smaller exponent to the right the number of places
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= equal to the difference in the two exponents.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= The aligned mantissas are compared and the indicators set accordingly.
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= \newpage

\subsubsection{Floating-Point Miscellaneous}

%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= ade
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Add to Exponent
%= \end{flushleft}
%= 
%= 
%= 

\inbif
\insum {C(E) + C(Y)0,7 $\rightarrow$ C(E)}
\incss
\inina
\ininz {Set OFF}
\ininn {Set OFF}
\ineou 




%= fszn
%= Floating Set Zero and Negative Indicators
\inbif
\insum {Set indicators according to C(Y)}
\incss
\inina
\ininz {If C(Y)\tsb{8,35} = 0, then ON; otherwise OFF}
\ininn {If C(Y)\tsb{8} = 1, then ON; otherwise OFF}






%= lde
%= Load Exponent
\inbif
\insum {C(Y)0,7 $\rightarrow$ C(E)}
\incss
\inina
\ininz {Set OFF}
\ininn {Set OFF}

%= ste
%= Store Exponent
\inbif
\insum {C(E) $\rightarrow$ C(Y)0,7}
\inull {00\ldots0 $\rightarrow$ C(Y)8,17}
\indcs
\innaf




\subsection{TRANSFER INSTRUCTIONS}

%= call6
%= Call (Using PR6 and PR7)
%= 713 (0)
\inbif
\insum {If C(TPR.TRR) $<$ C(PPR.PRR) then}
\inull {\hspace{1em}C(DSBR.STACK) $||$ C(TPR.TRR) $\rightarrow$ C(PR7.SNR)}
\inull {If C(TPR.TRR) = C(PPR.PRR) then C(PR6.SNR) $\rightarrow$ C(PR7.SNR)}
\inull {\hspace{1em}C(TPR.TRR) $\rightarrow$ C(PR7.RNR)}
\inull {If C(TPR.TRR) = 0 then C(SDW.P) $\rightarrow$ C(PPR.P);}
\inull {\hspace{1em}otherwise 0 $\rightarrow$ C(PPR.P)}
\inull {00\ldots0 $\rightarrow$ C(PR7.WORDNO)}
\inull {00\ldots0 $\rightarrow$ C(PR7.BITNO)}
\inull {C(TPR.TRR) $\rightarrow$ C(PPR.PRR)}
\inull {C(TPR.TSR) $\rightarrow$ C(PPR.PSR)}
\inull {C(TPR.CA) $\rightarrow$ C(PPR.IC)}
\indcs
\innaf
%= NOTES:
%= See Section 3 for descriptions of the various registers and Section 8 for a
%= flowchart of their role in address preparation.
%= 
%= If C(TPR.TRR) $>$ C(PPR.PRR), an access violation fault (outward call)
%= occurs and the call6 instruction is not executed.
%= 
%= If the call6 instruction is executed with the processor in absolute mode
%= with bit 29 of the instruction word set OFF and without indirection through
%= an ITP or ITS pair, then:
%= the appending mode is entered for the address preparation of the
%= call6 operand address and is retained if the instruction executes
%= successfully,
%= and the effective segment number generated for the SDW fetch and
%= subsequent loading into C(TPR.TSR) is equal to C(PPR.PSR) and may
%= be undefined in absolute mode,
%= and the effective ring number loaded into C(TPR.TRR) prior to the SDW
%= fetch is equal to C(PPR.PRR) (which is 0 in absolute mode) implying
%= that the access violation checks for outward call and bad outward call
%= are ineffective and that an access violation (out of call brackets) will
%= occur if C(SDW.R1) $\neq$ 0.
%= Attempted repetition with the rpt, rpd, or rpl instructions causes an
%= illegal procedure fault.




%= ret
%= Return
%= 630 (0)
\inbif
\insum {C(Y)0,17 $\rightarrow$ C(PPR.IC)}
\inull {C(Y)18,31 $\rightarrow$ C(IR)}
\indcs
\inina

%= Parity mask
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= If C(Y)27 = 1, and the processor is in absolute or mask privileged mode,
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= then ON; otherwise OFF. This indicator is not affected in the normal or
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= BAR modes.
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Not BAR mode
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Can be set OFF but not ON by the ret instruction
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Absolute mode
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Can be set OFF but not ON by the ret instruction
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= All other
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= indicators
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= If corresponding bit in C(Y) is 1, then ON; otherwise, OFF
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= NOTES:
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= The relation between C(Y)18,31 and the indicators is given in Table 4-5
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= earlier in this section.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= The tally runout indicator reflects C(Y)25 regardless of what address
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= modification is performed on the ret instruction.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= The ret instruction may be thought of as a ldi instruction followed by a
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= transfer to location C(Y)0,17.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= Attempted repetition with the rpt, rpd, or rpl instructions causes an
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= illegal procedure fault.
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= rtcd
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Return Control Double
%= \end{flushleft}
%= 
%= 
%= 

\inbif
\insum {C(Y-pair)3,17 $\rightarrow$ C(PPR.PSR)}
\inull {Maximum of}
\inull {\hspace{1em}C(Y-pair)18,20; C(TPR.TRR); C(SDW.R1) $\rightarrow$ C(PPR.PRR)}
\inull {C(Y-pair)36,53 $\rightarrow$ C(PPR.IC)}
\inull {If C(PPR.PRR) = 0 then C(SDW.P) $\rightarrow$ C(PPR.P);}
\inull {\hspace{1em}otherwise 0 $\rightarrow$ C(PPR.P)}
\inull {C(PPR.PRR) $\rightarrow$ C(PRn.RNR) for n = (0, 1, ..., 7)}

\indcs

%= INDICATORS:
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= None affected
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= NOTES:
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= See Section 3 for descriptions of the various registers and Section 8 for a
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= flowchart of their role in address preparation.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= If an access violation fault occurs when fetching the SDW for the Y-pair,
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= the C(PPR.PSR) and C(PPR.PRR) are not altered.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= If the rtcd instruction is executed with the processor in absolute mode
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= with bit 29 of the instruction word set OFF and without indirection through
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= an ITP or ITS pair, then:
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= appending mode is entered for address preparation for the rtcd
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= operand and is retained if the instruction executes successfully,
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= and the effective segment number generated for the SDW fetch and
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= subsequent loading into C(TPR.TSR) is equal to C(PPR.PSR) and may
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= be undefined in absolute mode,
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= \newpage
%= and the effective ring number loaded into C(TPR.TRR) prior to the SDW
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= fetch is equal to C(PPR.PRR) (which is 0 in absolute mode) implying
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= that control is always transferred into ring 0.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= Attempted repetition with the rpt, rpd, or rpl instructions causes an
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= illegal procedure fault.
%= \end{flushleft}



\ins {teo} {Transfer on Exponent Overflow} {614 (0)}
\inbif
\insum {If exponent overflow indicator ON then}
\inull {\hspace{1em}C(TPR.CA) $\rightarrow$ C(PPR.IC)}
\inull {\hspace{1em}C(TPR.TSR) $\rightarrow$ C(PPR.PSR)}
\inull {otherwise, no change to C(PPR)}
\indcs
\inina
\inlbl{\hspace{1em}Exponent}{Set OFF}
\inlbl{\hspace{1em}overflow}{}
\inrrr





\ins {teu} {Transfer on Exponent Underflow} {615 (0)}
\inbif
\insum {If exponent underflow indicator ON then}
\inull {\hspace{1em}C(TPR.CA) $\rightarrow$ C(PPR.IC)}
\inull {\hspace{1em}C(TPR.TSR) $\rightarrow$ C(PPR.PSR)}
\inull {otherwise, no change to C(PPR)}
\indcs
\inina
\inlbl{\hspace{1em}Exponent}{Set OFF}
\inlbl{\hspace{1em}underflow}{}
\inrrr

\ins {tmi} {Transfer on Minus} {604 (0)}
\inbif
\insum {If negative indicator ON then}
\inull {\hspace{1em}C(TPR.CA) $\rightarrow$ C(PPR.IC)}
\inull {\hspace{1em}C(TPR.TSR) $\rightarrow$ C(PPR.PSR)}
\inull {otherwise, no change to C(PPR)}
\indcs
\innaf
%= NOTES:
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Attempted repetition with the rpt, rpd, or rpl instructions causes an
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= illegal procedure fault.
%= \end{flushleft}
%= 
%= 
%= 




%= tmoz
%= Transfer on Minus or Zero
%= 604 (1)

\inbif

\insum {If negative or zero indicator ON then}
\inull {\hspace{1em}C(TPR.CA) $\rightarrow$ C(PPR.IC)}
\inull {\hspace{1em}C(TPR.TSR) $\rightarrow$ C(PPR.PSR)}
\inull {otherwise, no change to C(PPR)}
\indcs

%= INDICATORS:
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= None affected
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= NOTES:
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Attempted repetition with the rpt, rpd, or rpl instructions causes an
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= illegal procedure fault.
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= tnc
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Transfer on No Carry
%= \end{flushleft}
%= 
%= 
%= 
%= 602 (0)

\inbif

\insum {If carry indicator OFF then}
\inull {\hspace{1em}C(TPR.CA) $\rightarrow$ C(PPR.IC)}
\inull {\hspace{1em}C(TPR.TSR) $\rightarrow$ C(PPR.PSR)}
\inull {otherwise, no change to C(PPR)}
\indcs

%= INDICATORS:
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= None affected
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= NOTES:
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Attempted repetition with the rpt, rpd, or rpl instructions causes an
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= illegal procedure fault.
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= tnz
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= FORMAT:
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Transfer on Nonzero
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= Basic instruction format (see Figure 4-1).
%= \end{flushleft}
%= 
%= 
%= 
%= 601 (0)
%= 
%= 
%= 
%= \begin{flushleft}
%= \newpage
\insum {If zero indicator OFF then}
\inull {\hspace{1em}C(TPR.CA) $\rightarrow$ C(PPR.IC)}
\inull {\hspace{1em}C(TPR.TSR) $\rightarrow$ C(PPR.PSR)}
\inull {otherwise, no change to C(PPR)}
\indcs
\innaf
%= NOTES:
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Attempted repetition with the rpt, rpd, or rpl instructions causes an
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= illegal procedure fault.
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= tov
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Transfer on Overflow
%= \end{flushleft}
%= 
%= 
%= 
%= 617 (0)

\inbif

\insum {If overflow indicator ON then}
\inull {\hspace{1em}C(TPR.CA) $\rightarrow$ C(PPR.IC)}
\inull {\hspace{1em}C(TPR.TSR) $\rightarrow$ C(PPR.PSR)}
\inull {otherwise, no change to C(PPR)}
\indcs
\inina
\inino {Set OFF}

%= NOTES:
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= tpl
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Attempted repetition with the rpt, rpd, or rpl instructions causes an
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= illegal procedure fault.
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Transfer on Plus
%= \end{flushleft}
%= 
%= 
%= 
%= 605 (0)

\inbif

\insum {If negative indicator OFF, then}
\inull {\hspace{1em}C(TPR.CA) $\rightarrow$ C(PPR.IC)}
\inull {\hspace{1em}C(TPR.TSR) $\rightarrow$ C(PPR.PSR)}
\inull {otherwise, no change to C(PPR)}
\indcs
\innaf
%= NOTES:
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Attempted repetition with the rpt, rpd, or rpl instructions causes an
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= illegal procedure fault.
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= tpnz
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= FORMAT:
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Transfer on Plus and Nonzero
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= Basic instruction format (see Figure 4-1).
%= \end{flushleft}
%= 
%= 
%= 
%= 605 (1)
%= 
%= 
%= 
%= \begin{flushleft}
%= \newpage
\insum {If negative and zero indicators are OFF then}
\inull {\hspace{1em}C(TPR.CA) $\rightarrow$ C(PPR.IC)}
\inull {\hspace{1em}C(TPR.TSR) $\rightarrow$ C(PPR.PSR)}
\inull {otherwise, no change to C(PPR)}
\indcs
\innaf
%= NOTES:
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Attempted repetition with the rpt, rpd, or rpl instructions causes an
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= illegal procedure fault.
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= tra
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Transfer Unconditionally
%= \end{flushleft}
%= 
%= 
%= 
%= 710 (0)

\inbif

\insum {C(TPR.CA) $\rightarrow$ C(PPR.IC)}
\inull {C(TPR.TSR) $\rightarrow$ C(PPR.PSR)}
\indcs
\innaf
%= NOTES:
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Attempted repetition with the rpt, rpd, or rpl instructions causes an
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= illegal procedure fault.
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= trc
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Transfer on Carry
%= \end{flushleft}
%= 
%= 
%= 
%= 603 (0)

\inbif

\insum {If carry indicator ON then}
\inull {\hspace{1em}C(TPR.CA) $\rightarrow$ C(PPR.IC)}
\inull {\hspace{1em}C(TPR.TSR) $\rightarrow$ C(PPR.PSR)}
\inull {otherwise, no change to C(PPR)}
\indcs
\innaf
%= NOTES:
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Attempted repetition with the rpt, rpd, or rpl instructions causes an
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= illegal procedure fault.
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= trtf
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Transfer on Truncation Indicator OFF
%= \end{flushleft}
%= 
%= 
%= 

\inbif

\insum {If truncation indicator OFF then}
\inull {\hspace{1em}C(TPR.CA) $\rightarrow$ C(PPR.IC)}
\inull {\hspace{1em}C(TPR.TSR) $\rightarrow$ C(PPR.PSR)}
\inull {otherwise, no change to C(PPR)}
\indcs
\innaf
%= NOTES:
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Attempted repetition with the rpt, rpd, or rpl instructions causes an
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= illegal procedure fault.
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= trtn
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Transfer on Truncation Indicator ON
%= \end{flushleft}
%= 
%= 
%= 
%= 600 (1)

\inbif
\insum {If truncation indicator ON then}
\inull {\hspace{1em}C(TPR.CA) $\rightarrow$ C(PPR.IC)}
\inull {\hspace{1em}C(TPR.TSR) $\rightarrow$ C(PPR.PSR)}
\inull {otherwise, no change to C(PPR)}
\indcs
\inina
\intru {Set OFF}
%= NOTES:
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Set OFF
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= Attempted repetition with the rpt, rpd, or rpl instructions causes an
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= illegal procedure fault.
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= tsp0
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Transfer and Set Pointer Register 0
%= \end{flushleft}
%= 
%= 
%= 
%= 270 (0)
%= 
%= 
%= 
%= \begin{flushleft}
%= tsp1
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Transfer and Set Pointer Register 1
%= \end{flushleft}
%= 
%= 
%= 
%= 271 (0)
%= 
%= 
%= 
%= \begin{flushleft}
%= tsp2
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Transfer and Set Pointer Register 2
%= \end{flushleft}
%= 
%= 
%= 
%= 272 (0)
%= 
%= 
%= 
%= \begin{flushleft}
%= tsp3
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Transfer and Set Pointer Register 3
%= \end{flushleft}
%= 
%= 
%= 
%= 273 (0)
%= 
%= 
%= 
%= \begin{flushleft}
%= tsp4
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Transfer and Set Pointer Register 4
%= \end{flushleft}
%= 
%= 
%= 
%= 670 (0)
%= 
%= 
%= 
%= \begin{flushleft}
%= tsp5
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Transfer and Set Pointer Register 5
%= \end{flushleft}
%= 
%= 
%= 
%= 671 (0)
%= 
%= 
%= 
%= \begin{flushleft}
%= tsp6
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Transfer and Set Pointer Register 6
%= \end{flushleft}
%= 
%= 
%= 
%= 672 (0)
%= 
%= 
%= 
%= \begin{flushleft}
%= tsp7
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Transfer and Set Pointer Register 7
%= \end{flushleft}
%= 
%= 
%= 
%= 673 (0)
%= 
%= 
%= 

\inbif
\insum {For n = 0, 1, ..., or 7 as determined by operation code}
\inull {\hspace{1em}C(PPR.PRR) $\rightarrow$ C(PRn.RNR)}
\inull {\hspace{1em}C(PPR.PSR) $\rightarrow$ C(PRn.SNR)}
\inull {\hspace{1em}C(PPR.IC) + 1 $\rightarrow$ C(PRn.WORDNO)}
\inull {\hspace{1em}00\ldots0 $\rightarrow$ C(PRn.BITNO)}
\inull {C(TPR.CA) $\rightarrow$ C(PPR.IC)}
\inull {C(TPR.TSR) $\rightarrow$ C(PPR.PSR)}
\indcs
\innaf
%= NOTES:
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Attempted repetition with the rpt, rpd, or rpl instructions causes an
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= illegal procedure fault.
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= tss
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Transfer and Set Slave
%= \end{flushleft}
%= 
%= 
%= 
%= 715 (0)

\inbif
\insum {C(TPR.CA) + (BAR base) $\rightarrow$ C(PPR.IC)}
\inull {C(TPR.TSR) $\rightarrow$ C(PPR.PSR)}
\indcs
\inina
\inbar {Set OFF (see notes below)}
\inlbl {\hspace{1em}Absolute mode} {Set OFF}
%= NOTES:
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= If the tss instruction is executed with the processor not in BAR mode the
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= not BAR mode indicator is set OFF to enable subsequent addressing in the
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= BAR mode. The base address register (BAR) is used in the address
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= preparation of the transfer, and the BAR will be used in address
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= preparation for all subsequent instructions until a fault or interrupt occurs.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= If the tss instruction is executed with the not BAR mode indicator already
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= OFF, it functions as a tra instruction and no indicators are changed.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= If C(TPR.CA) $>$= (BAR bound) the transfer does not take place. Instead, a
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= store fault (out of bounds) occurs.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= Attempted repetition with the rpt, rpd, or rpl instructions causes an
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= illegal procedure fault.
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= tsxn
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Transfer and Set Index Register n
%= \end{flushleft}
%= 
%= 
%= 
%= 70n (0)

\inbif

\insum {For n = 0, 1, ..., or 7 as determined by operation code}
\inull {\hspace{1em}C(PPR.IC) + 1 $\rightarrow$ C(Xn)}
\inull {C(TPR.CA) $\rightarrow$ C(PPR.IC)}
\inull {C(TPR.TSR) $\rightarrow$ C(PPR.PSR)}
\indcs
\innaf
%= NOTES:
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Attempted repetition with the rpt, rpd, or rpl instructions causes an
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= illegal procedure fault.
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= \newpage
%= ttf
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Transfer on Tally Runout Indicator OFF
%= \end{flushleft}
%= 
%= 
%= 
%= 607 (0)

\inbif
\insum {If tally runout indicator OFF then}
\inull {\hspace{1em}C(TPR.CA) $\rightarrow$ C(PPR.IC)}
\inull {\hspace{1em}C(TPR.TSR) $\rightarrow$ C(PPR.PSR)}
\inull {otherwise, no change to C(PPR)}
\indcs
\innaf
%= NOTES:
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Attempted repetition with the rpt, rpd, or rpl instructions causes an
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= illegal procedure fault.
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= ttn
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Transfer on Tally Runout Indicator ON
%= \end{flushleft}
%= 
%= 
%= 
%= 606 (1)

\inbif

\insum {If tally runout indicator ON then}
\inull {\hspace{1em}C(TPR.CA) $\rightarrow$ C(PPR.IC)}
\inull {\hspace{1em}C(TPR.TSR) $\rightarrow$ C(PPR.PSR)}
\inull {otherwise, no change to C(PPR)}
\indcs
\innaf
%= NOTES:
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Attempted repetition with the rpt, rpd, or rpl instructions causes an
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= illegal procedure fault.
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= tze
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Transfer on Zero
%= \end{flushleft}
%= 
%= 
%= 
%= 600 (0)

\inbif

\insum {If zero indicator ON then}
\inull {\hspace{1em}C(TPR.CA) $\rightarrow$ C(PPR.IC)}
\inull {\hspace{1em}C(TPR.TSR) $\rightarrow$ C(PPR.PSR)}
\inull {otherwise, no change to C(PPR)}
\indcs
\innaf
%= NOTES:
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Attempted repetition with the rpt, rpd, or rpl instructions causes an
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= illegal procedure fault.
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= \newpage

\subsection{POINTER REGISTER INSTRUCTIONS}

%= \end{flushleft}
%= 
%= \begin{flushleft}

\subsubsection{Pointer Register Data Movement Load}

%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= easp0
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Effective Address to Segment Number of PR0
%= \end{flushleft}
%= 
%= 
%= 
%= 311 (0)
%= 
%= 
%= 
%= \begin{flushleft}
%= easp1
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Effective Address to Segment Number of PR1
%= \end{flushleft}
%= 
%= 
%= 
%= 310 (1)
%= 
%= 
%= 
%= \begin{flushleft}
%= easp2
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Effective Address to Segment Number of PR2
%= \end{flushleft}
%= 
%= 
%= 
%= 313 (0)
%= 
%= 
%= 
%= \begin{flushleft}
%= easp3
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Effective Address to Segment Number of PR3
%= \end{flushleft}
%= 
%= 
%= 
%= 312 (1)
%= 
%= 
%= 
%= \begin{flushleft}
%= easp4
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Effective Address to Segment Number of PR4
%= \end{flushleft}
%= 
%= 
%= 
%= 331 (0)
%= 
%= 
%= 
%= \begin{flushleft}
%= easp5
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Effective Address to Segment Number of PR5
%= \end{flushleft}
%= 
%= 
%= 
%= 330 (1)
%= 
%= 
%= 
%= \begin{flushleft}
%= easp6
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Effective Address to Segment Number of PR6
%= \end{flushleft}
%= 
%= 
%= 
%= 333 (0)
%= 
%= 
%= 
%= \begin{flushleft}
%= easp7
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Effective Address to Segment Number of PR7
%= \end{flushleft}
%= 
%= 
%= 
%= 332 (1)
%= 
%= 
%= 

\inbif

\insum {For n = 0, 1, ..., or 7 as determined by operation code}
\inull {\hspace{1em}C(TPR.CA) $\rightarrow$ C(PRn.SNR)}
\indcs
\innaf
%= NOTES:
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Attempted execution in BAR mode causes an illegal procedure fault.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= Attempted repetition with the rpt, rpd, or rpl instructions causes an
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= illegal procedure fault.
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= eawp0
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Effective Address to Word/Bit Number of PR0
%= \end{flushleft}
%= 
%= 
%= 
%= 310 (0)
%= 
%= 
%= 
%= \begin{flushleft}
%= eawp1
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Effective Address to Word/Bit Number of PR1
%= \end{flushleft}
%= 
%= 
%= 
%= 311 (1)
%= 
%= 
%= 
%= \begin{flushleft}
%= eawp2
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Effective Address to Word/Bit Number of PR2
%= \end{flushleft}
%= 
%= 
%= 
%= 312 (0)
%= 
%= 
%= 
%= \begin{flushleft}
%= eawp3
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Effective Address to Word/Bit Number of PR3
%= \end{flushleft}
%= 
%= 
%= 
%= 313 (1)
%= 
%= 
%= 
%= \begin{flushleft}
%= eawp4
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Effective to Word/Bit Number of PR4 Address
%= \end{flushleft}
%= 
%= 
%= 
%= 330 (0)
%= 
%= 
%= 
%= \begin{flushleft}
%= eawp5
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Effective Address to Word/Bit Number of PR5
%= \end{flushleft}
%= 
%= 
%= 
%= 331 (1)
%= 
%= 
%= 
%= \begin{flushleft}
%= \newpage
%= eawp6
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Effective Address to Word/Bit Number of PR6
%= \end{flushleft}
%= 
%= 
%= 
%= 332 (0)
%= 
%= 
%= 
%= \begin{flushleft}
%= eawp7
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Effective Address to Word/Bit Number of PR7
%= \end{flushleft}
%= 
%= 
%= 
%= 333 (1)
%= 
%= 
%= 

\inbif
\insum {For n = 0, 1, ..., or 7 as determined by operation code}
\inull {\hspace{1em}C(TPR.CA) $\rightarrow$ C(PRn.WORDNO)}
\inull {\hspace{1em}C(TPR.TBR) $\rightarrow$ C(PRn.BITNO)}
\indcs
\innaf
%= NOTES:
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Attempted execution in BAR mode causes an illegal procedure fault.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= Attempted repetition with the rpt, rpd, or rpl instructions causes an
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= illegal procedure fault.
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= epbp0
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Effective Pointer at Base to PR0
%= \end{flushleft}
%= 
%= 
%= 
%= 350 (1)
%= 
%= 
%= 
%= \begin{flushleft}
%= epbp1
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Effective Pointer at Base to PR1
%= \end{flushleft}
%= 
%= 
%= 
%= 351 (0)
%= 
%= 
%= 
%= \begin{flushleft}
%= epbp2
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Effective Pointer at Base to PR2
%= \end{flushleft}
%= 
%= 
%= 
%= 352 (1)
%= 
%= 
%= 
%= \begin{flushleft}
%= epbp3
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Effective Pointer at Base to PR3
%= \end{flushleft}
%= 
%= 
%= 
%= 353 (0)
%= 
%= 
%= 
%= \begin{flushleft}
%= epbp4
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Effective Pointer at Base to PR4
%= \end{flushleft}
%= 
%= 
%= 
%= 370 (1)
%= 
%= 
%= 
%= \begin{flushleft}
%= epbp5
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Effective Pointer at Base to PR5
%= \end{flushleft}
%= 
%= 
%= 
%= 371 (0)
%= 
%= 
%= 
%= \begin{flushleft}
%= epbp6
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Effective Pointer at Base to PR6
%= \end{flushleft}
%= 
%= 
%= 
%= 372 (1)
%= 
%= 
%= 
%= \begin{flushleft}
%= epbp7
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Effective Pointer at Base to PR7
%= \end{flushleft}
%= 
%= 
%= 
%= 373 (0)
%= 
%= 
%= 

\inbif

\insum {For n = 0, 1, ..., or 7 as determined by operation code}
\inull {\hspace{1em}C(TPR.TRR) $\rightarrow$ C(PRn.RNR)}
\inull {\hspace{1em}C(TPR.TSR) $\rightarrow$ C(PRn.SNR)}
\inull {\hspace{1em}00\ldots0 $\rightarrow$ C(PRn.WORDNO)}
\inull {\hspace{1em}0000$\rightarrow$ C(PRn.BITNO)}
\indcs
\innaf
%= NOTES:
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Attempted execution in BAR mode causes an illegal procedure fault.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= Attempted repetition with the rpt, rpd, or rpl instructions causes an
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= illegal procedure fault.
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= \newpage
%= epp0
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Effective Pointer to Pointer Register 0
%= \end{flushleft}
%= 
%= 
%= 
%= 350 (0)
%= 
%= 
%= 
%= \begin{flushleft}
%= epp1
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Effective Pointer to Pointer Register 1
%= \end{flushleft}
%= 
%= 
%= 
%= 351 (1)
%= 
%= 
%= 
%= \begin{flushleft}
%= epp2
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Effective Pointer to Pointer Register 2
%= \end{flushleft}
%= 
%= 
%= 
%= 352 (0)
%= 
%= 
%= 
%= \begin{flushleft}
%= epp3
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Effective Pointer to Pointer Register 3
%= \end{flushleft}
%= 
%= 
%= 
%= 353 (1)
%= 
%= 
%= 
%= \begin{flushleft}
%= epp4
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Effective Pointer to Pointer Register 4
%= \end{flushleft}
%= 
%= 
%= 
%= 370 (0)
%= 
%= 
%= 
%= \begin{flushleft}
%= epp5
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Effective Pointer to Pointer Register 5
%= \end{flushleft}
%= 
%= 
%= 
%= 371 (1)
%= 
%= 
%= 
%= \begin{flushleft}
%= epp6
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Effective Pointer to Pointer Register 6
%= \end{flushleft}
%= 
%= 
%= 
%= 372 (0)
%= 
%= 
%= 
%= \begin{flushleft}
%= epp7
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Effective Pointer to Pointer Register 7
%= \end{flushleft}
%= 
%= 
%= 
%= 373 (1)
%= 
%= 
%= 

\inbif
\insum {For n = 0, 1, ..., or 7 as determined by operation code}
\inull {\hspace{1em}C(TPR.TRR) $\rightarrow$ C(PRn.RNR)}
\inull {\hspace{1em}C(TPR.TSR) $\rightarrow$ C(PRn.SNR)}
\inull {\hspace{1em}C(TPR.CA) $\rightarrow$ C(PRn.WORDNO)}
\inull {\hspace{1em}C(TPR.TBR) $\rightarrow$ C(PRn.BITNO)}
\indcs
\innaf
%= NOTES:
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Attempted execution in BAR mode causes an illegal procedure fault.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= Attempted repetition with the rpt, rpd, or rpl instructions causes an
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= illegal procedure fault.
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= lpri
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Load Pointer Registers from ITS Pairs
%= \end{flushleft}
%= 
%= 
%= 
%= 173 (0)

\inbif
\insum {For n = 0, 1, ..., 7}
\inull {\hspace{1em}Y-pair = Y-block16 + 2n}
\inull {\hspace{1em}Maximum of}
\inull {\hspace{2em}C(Y-pair)18,20; C(SDW.R1); C(TPR.TRR) $\rightarrow$ C(PRn.RNR)}
\inull {\hspace{1em}C(Y-pair)3,17 $\rightarrow$ C(PRn.SNR)}
\inull {\hspace{1em}C(Y-pair)36,53 $\rightarrow$ C(PRn.WORDNO)}
\inull {\hspace{1em}C(Y-pair)57,62 $\rightarrow$ C(PRn.BITNO)}
\indcs
\innaf
%= NOTES:
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Starting at location Y-block16, the contents of eight word pairs (in ITS pair
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= format) replace the contents of pointer registers 0 through 7 as shown.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= Since C(TPR.TRR) and C(SDW.R1) are both equal to zero in absolute mode,
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= C(Y-pair)18,20 are loaded into PRn.RNR in absolute mode.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= Attempted execution in BAR mode causes an illegal procedure fault.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= Attempted repetition with the rpt, rpd, or rpl instructions causes an
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= illegal procedure fault.
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= lprpn
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Load Pointer Register n Packed
%= \end{flushleft}
%= 
%= 
%= 
%= 76n (0)

\inbif
\insum {For n = 0, 1, ..., or 7 as determined by operation code}
\inull {\hspace{1em}C(TPR.TRR) $\rightarrow$ C(PRn.RNR)}
\inull {\hspace{1em}If C(Y)0,1 $\neq$ 11, then}
\inull {\hspace{2em}C(Y)0,5 $\rightarrow$ C(PRn.BITNO);}
\inull {\hspace{1em}otherwise, generate command fault}
\inull {\hspace{1em}If C(Y)6,17 = ll...1, then 111 $\rightarrow$ C(PRn.SNR)0,2}
\inull {\hspace{1em}otherwise, 000 $\rightarrow$ C(PRn.SNR)0,2}
\inull {\hspace{1em}C(Y)6,17 $\rightarrow$ C(PRn.SNR)3,14}
\inull {\hspace{1em}C(Y)18,35 $\rightarrow$ C(PRn.WORDNO)}
\indcs
\innaf
%= NOTES:
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Binary 1s in C(Y)0,1 correspond to an illegal BITNO, that is, a bit position
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= beyond the extent of C(Y). Detection of these bits causes a command fault.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= Attempted execution in BAR mode causes an illegal procedure fault.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= Attempted repetition with the rpt, rpd, or rpl instructions causes an
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= illegal procedure fault.
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= \newpage

\subsubsection{Pointer Register Data Movement Store}

%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= spbp0
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Store Segment Base Pointer of PR0
%= \end{flushleft}
%= 
%= 
%= 
%= 250 (1)
%= 
%= 
%= 
%= \begin{flushleft}
%= spbp1
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Store Segment Base Pointer of PR1
%= \end{flushleft}
%= 
%= 
%= 
%= 251 (0)
%= 
%= 
%= 
%= \begin{flushleft}
%= spbp2
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Store Segment Base Pointer of PR2
%= \end{flushleft}
%= 
%= 
%= 
%= 252 (1)
%= 
%= 
%= 
%= \begin{flushleft}
%= spbp3
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Store Segment Base Pointer of PR3
%= \end{flushleft}
%= 
%= 
%= 
%= 253 (0)
%= 
%= 
%= 
%= \begin{flushleft}
%= spbp4
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Store Segment Base Pointer of PR4
%= \end{flushleft}
%= 
%= 
%= 
%= 650 (1)
%= 
%= 
%= 
%= \begin{flushleft}
%= spbp5
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Store Segment Base Pointer of PR5
%= \end{flushleft}
%= 
%= 
%= 
%= 651 (0)
%= 
%= 
%= 
%= \begin{flushleft}
%= spbp6
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Store Segment Base Pointer of PR6
%= \end{flushleft}
%= 
%= 
%= 
%= 652 (1)
%= 
%= 
%= 
%= \begin{flushleft}
%= spbp7
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Store Segment Base Pointer of PR7
%= \end{flushleft}
%= 
%= 
%= 
%= 653 (0)
%= 
%= 
%= 

\inbif
\insum {For n = 0, 1, ..., or 7 as determined by operation code}
\inull {\hspace{1em}C(PRn.SNR) $\rightarrow$ C(Y-pair)3,17}
\inull {\hspace{1em}C(PRn.RNR) $\rightarrow$ C(Y-pair)18,20}
\inull {000 $\rightarrow$ C(Y-pair)0,2}
\inull {00\ldots0 $\rightarrow$ C(Y-pair)21,29}
\inull {(43)8 $\rightarrow$ C(Y-pair)30,35}
\inull {00\ldots0 $\rightarrow$ C(Y-pair)36,71}
\indcs
\innaf
%= NOTES:
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Attempted execution in BAR mode causes an illegal procedure fault.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= Attempted repetition with the rpt, rpd, or rpl instructions causes an
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= illegal procedure fault.
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= spri
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Store Pointer Registers as ITS Pairs
%= \end{flushleft}
%= 
%= 
%= 
%= 254 (0)

\inbif

\insum {For n = 0, 1, ..., 7}
\inull {\hspace{1em}Y-pair = Y-block16 + 2n}
\inull {\hspace{1em}000 $\rightarrow$ C(Y-pair)0,2}
\inull {\hspace{1em}C(PRn.SNR) $\rightarrow$ C(Y-pair)3,17}
\inull {\hspace{1em}C(PRn.RNR) $\rightarrow$ C(Y-pair)18,20}
\inull {\hspace{1em}00\ldots0 $\rightarrow$ C(Y-pair)21,29}
\inull {\hspace{1em}(43)8 $\rightarrow$ C(Y-pair)30,35}
\inull {\hspace{1em}C(PRn.WORDNO) $\rightarrow$ C(Y-pair)36,53}
\inull {\hspace{1em}000 $\rightarrow$ C(Y-pair)54,56}
\inull {\hspace{1em}C(PRn.BITNO) $\rightarrow$ C(Y-pair)57,62}
\inull {\hspace{1em}00\ldots0 $\rightarrow$ C(Y-pair)63,71}
\indcs
\innaf

%= NOTES:
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Starting at location Y-block16, the contents of pointer registers 0 through
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= 7 replace the contents of eight word pairs (in ITS pair format).
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= Attempted execution in BAR mode causes an illegal procedure fault.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= Attempted repetition with the rpt, rpd, or rpl instructions causes an
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= illegal procedure fault.
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= spri0
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Store Pointer Register 0 as ITS Pair
%= \end{flushleft}
%= 
%= 
%= 
%= 250 (0)
%= 
%= 
%= 
%= \begin{flushleft}
%= spri1
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Store Pointer Register 1 as ITS Pair
%= \end{flushleft}
%= 
%= 
%= 
%= 251 (1)
%= 
%= 
%= 
%= \begin{flushleft}
%= spri2
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Store Pointer Register 2 as ITS Pair
%= \end{flushleft}
%= 
%= 
%= 
%= 252 (0)
%= 
%= 
%= 
%= \begin{flushleft}
%= spri3
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Store Pointer Register 3 as ITS Pair
%= \end{flushleft}
%= 
%= 
%= 
%= 253 (1)
%= 
%= 
%= 
%= \begin{flushleft}
%= spri4
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Store Pointer Register 4 as ITS Pair
%= \end{flushleft}
%= 
%= 
%= 
%= 650 (0)
%= 
%= 
%= 
%= \begin{flushleft}
%= spri5
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Store Pointer Register 5 as ITS Pair
%= \end{flushleft}
%= 
%= 
%= 
%= 651 (1)
%= 
%= 
%= 
%= \begin{flushleft}
%= spri6
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Store Pointer Register 6 as ITS Pair
%= \end{flushleft}
%= 
%= 
%= 
%= 652 (0)
%= 
%= 
%= 
%= \begin{flushleft}
%= spri7
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Store Pointer Register 7 as ITS Pair
%= \end{flushleft}
%= 
%= 
%= 
%= 653 (1)
%= 
%= 
%= 

\inbif

\insum {For n = 0, 1, ..., or 7 as determined by operation code}
\inull {\hspace{1em}000 $\rightarrow$ C(Y-pair)0,2}
\inull {\hspace{1em}C(PRn.SNR) $\rightarrow$ C(Y-pair)3,17}
\inull {\hspace{1em}C(PRn.RNR) $\rightarrow$ C(Y-pair)18,20}
\inull {\hspace{1em}00...0 $\rightarrow$ C(Y-pair)21,29}
\inull {\hspace{1em}(43)8 $\rightarrow$ C(Y-pair)30,35}
\inull {\hspace{1em}C(PRn.WORDNO) $\rightarrow$ C(Y-pair)36,53}
\inull {\hspace{1em}000 $\rightarrow$ C(Y-pair)54,56}
\inull {\hspace{1em}C(PRn.BITNO) $\rightarrow$ C(Y-pair)57,62}
\inull {\hspace{1em}00...0 $\rightarrow$ C(Y-pair)63,71}
\indcs
\innaf
%= NOTES:
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Attempted execution in BAR mode causes an illegal procedure fault.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= Attempted repetition with the rpt, rpd, or rpl instructions causes an
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= illegal procedure fault.
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= sprpn
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Store Pointer Register n Packed
%= \end{flushleft}
%= 
%= 
%= 
%= 54n (0

\inbif

\insum {For n = 0, 1, ..., or 7 as determined by operation code}
\inull {\hspace{1em}C(PRn.BITNO) $\rightarrow$ C(Y)0,5}
\inull {\hspace{1em}C(PRn.SNR)3,14 $\rightarrow$ C(Y)6,17}
\inull {\hspace{1em}C(PRn.WORDNO) $\rightarrow$ C(Y)18,35}
\indcs
\innaf
%= NOTES:
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= If C(PRn.SNR)0,2 are nonzero, and C(PRn.SNR) $\neq$ 11...1, then a store fault
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= (illegal pointer) will occur and C(Y) will not be changed.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= Attempted execution in BAR mode causes an illegal procedure fault.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= Attempted repetition with the rpt, rpd, or rpl instructions causes an
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= illegal procedure fault.
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= \newpage

\subsubsection{Pointer Register Address Arithmetic}

%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= adwp0
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Add to Word Number of Pointer Register 0
%= \end{flushleft}
%= 
%= 
%= 
%= 050 (0)
%= 
%= 
%= 
%= \begin{flushleft}
%= adwp1
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Add to Word Number of Pointer Register 1
%= \end{flushleft}
%= 
%= 
%= 
%= 051 (0)
%= 
%= 
%= 
%= \begin{flushleft}
%= adwp2
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Add to Word Number of Pointer Register 2
%= \end{flushleft}
%= 
%= 
%= 
%= 052 (0)
%= 
%= 
%= 
%= \begin{flushleft}
%= adwp3
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Add to Word Number of Pointer Register 3
%= \end{flushleft}
%= 
%= 
%= 
%= 053 (0)
%= 
%= 
%= 
%= \begin{flushleft}
%= adwp4
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Add to Word Number of Pointer Register 4
%= \end{flushleft}
%= 
%= 
%= 
%= 150 (0)
%= 
%= 
%= 
%= \begin{flushleft}
%= adwp5
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Add to Word Number of Pointer Register 5
%= \end{flushleft}
%= 
%= 
%= 
%= 151 (0)
%= 
%= 
%= 
%= \begin{flushleft}
%= adwp6
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Add to Word Number of Pointer Register 6
%= \end{flushleft}
%= 
%= 
%= 
%= 152 (0)
%= 
%= 
%= 
%= \begin{flushleft}
%= adwp7
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Add to Word Number of Pointer Register 7
%= \end{flushleft}
%= 
%= 
%= 
%= 153 (0)
%= 
%= 
%= 

\inbif

\insum {For n = 0, 1, ..., or 7 as determined by operation code}
\inull {\hspace{1em}C(Y)0,17 + C(PRn.WORDNO) $\rightarrow$ C(PRn.WORDNO)}
\inull {\hspace{1em}00\ldots0 $\rightarrow$ C(PRn.BITNO)}
%= 
%= 
%= \begin{flushleft}
%= MODIFICATIONS:
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= All except dl, ci, sc, scr

\cac {I wonder if this is a typo; is du missing here? This is the only instruction with this particular modification.}

%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= INDICATORS:
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= None affected
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= NOTES:
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Attempted execution in BAR mode causes an illegal procedure fault.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= Attempted repetition with the rpt, rpd, or rpl instructions causes an
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= illegal procedure fault.
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= \newpage

\subsubsection{Pointer Register Miscellaneous}

%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= epaq
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Effective Pointer to AQ
%= \end{flushleft}
%= 
%= 
%= 
%= 213 (0)

\inbif
\insum {000 $\rightarrow$ C(AQ)0,2}
\inull {C(TPR.TSR) $\rightarrow$ C(AQ)3,17}
\inull {00\ldots.0 $\rightarrow$ C(AQ)18,32}
\inull {C(TPR.TRR) $\rightarrow$ C(AQ)33,35}
\inull {C(TPR.CA) $\rightarrow$ C(AQ)36,53}
\inull {00\ldots.0 $\rightarrow$ C(AQ)54,65}
\inull {C(TPR.TBR) $\rightarrow$ C(AQ)66,71}
\indcs
\inina
\ininZ (AQ)
\innte {Attempted execution in BAR mode causes an illegal procedure fault.}
\innta {
Attempted repetition with the rpt, rpd, or rpl instructions causes an
illegal procedure fault.}

\subsection{MISCELLANEOUS INSTRUCTIONS}

%= \end{flushleft}
%= 
%= \begin{flushleft}

\subsubsection{Calendar Clock}

%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= rccl
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Read Calendar Clock
%= \end{flushleft}
%= 
%= 
%= 
%= 633 (0)

\inbif

\insum {00\ldots0 $\rightarrow$ C(AQ)0,19}
\inull {C(calendar clock) $\rightarrow$ C(AQ)20,71}
\indcs
\innaf
%= NOTES:
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= C(TPR.CA)0,2 (C(TPR.CA)1,2 for the DPS 8M processor) specify which
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= processor port (i.e., which system controller) is to be used. The contents of
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= the clock in the designated system controller replace the contents of the
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= AQ-register
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= Attempted execution in BAR mode causes an illegal procedure fault.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= Attempted repetition with the rpt, rpd, or rpl instructions causes an
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= illegal procedure fault.
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= \newpage

\subsubsection{Derail}

%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= drl
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Derail
%= \end{flushleft}
%= 
%= 
%= 
%= 002 (0)
%= 
%= 
%= 

\inbif
\insum {
Causes a fault which fetches and executes, in absolute mode, the
instruction pair at main memory location C+(14)8. The value of C is
obtained from the FAULT VECTOR switches on the processor
configuration panel.}
\inabn
\innaf
%= NOTES:
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Except for the different constant used for fetching the instruction pair
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= from main memory, the drl instruction is identical to the mme instruction.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= Attempted repetition with the rpt, rpd, or rpl instructions causes an
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= illegal procedure fault.
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= \newpage

\subsubsection{Execute}

%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= xec
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Execute
%= \end{flushleft}
%= 
%= 
%= 
%= 716 (0)
%= 
%= 
%= 

\inbif
\insum {Fetch and execute the instruction in C(Y)}
\indcs
\innaf
%= NOTES:
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= The xec instruction itself does not affect any indicator. However, the
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= execution of the instruction from C(Y) may affect indicators.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= If the execution of the instruction from C(Y) modifies C(PPR.IC), then a
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= transfer of control occurs; otherwise, the next instruction to be executed is
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= fetched from C(PPR.IC)+1.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= To execute a rpd instruction, the xec instruction must be in an odd
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= location. The instruction pair repeated is that instruction pair at C(PPR.IC)
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= +1, that is, the instruction pair immediately following the xec instruction.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= C(PPR.IC) is adjusted during the execution of the repeated instruction pair
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= so that the next instruction fetched for execution is from the first word
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= following the repeated instruction pair.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= EIS multiword instructions may be executed with the xec instruction but
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= the required operand descriptors must be located immediately after the
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= xec instruction, that is, starting at C(PPR.IC)+1. C(PPR.IC) is adjusted
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= during execution of the EIS multiword instruction so that the next
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= instruction fetched for execution is from the first word following the EIS
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= operand descriptors.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= Attempted repetition with the rpt, rpd, or rpl instructions causes an
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= illegal procedure fault.
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= xed
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Execute Double
%= \end{flushleft}
%= 
%= 
%= 
%= 717 (0)
%= 
%= 
%= 

\inbif
\insum {Fetch and execute the instruction pair at C(Y-pair)}
\indcs
\innaf
%= NOTES:
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= The xed instruction itself does not affect any indicator. However, the
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= execution of the instruction pair from C(Y-pair) may affect indicators.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= The even instruction from C(Y-pair) must not alter C(Y-pair)36,71, and must
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= not be another xed instruction.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= If the execution of the instruction pair from C(Y-pair) alters C(PPR.IC),
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= then a transfer of control occurs; otherwise, the next instruction to be
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= executed is fetched from C(PPR.IC)+1. If the even instruction from C(Ypair) alters C(PPR.IC), then the transfer of control is effective immediately
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= and the odd instruction is not executed.
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= \newpage
%= To execute an instruction pair having an rpd instruction as the odd
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= instruction, the xed instruction must be located at an odd address. The
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= instruction pair repeated is that instruction pair at C PPR.IC)+1, that is,
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= the instruction pair immediately following the xed instruction. C(PPR.IC)
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= is adjusted during the execution of the repeated instruction pair so the the
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= next instruction fetched for execution is from the first word following the
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= repeated instruction pair.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= The instruction pair at C(Y-pair) may cause any of the processor defined
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= fault conditions, but only the directed faults (0,1,2,3) and the access
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= violation fault may be restarted successfully by the hardware. Note that
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= the software induced fault tag (1,2,3) faults cannot be properly restarted.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= An attempt to execute an EIS multiword instruction causes an illegal
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= procedure fault.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= Attempted repetition with the rpt, rpd, or rpl instructions causes an
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= illegal procedure fault.
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= \newpage

\subsubsection{Master Mode Entry}

%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= mme
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Master Mode Entry
%= \end{flushleft}
%= 
%= 
%= 
%= 001 (0)
%= 
%= 
%= 

\inbif
\insum {
Causes a fault that fetches and executes, in absolute mode, the instruction
pair at main memory location C+4. The value of C is obtained from the
FAULT VECTOR switches on the processor configuration panel.}
\inabn
\innaf
%= NOTES:
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Execution of the mme instruction implies the following conditions:
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= During the execution of the mme instruction and the two instructions
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= fetched, the processor is temporarily in absolute mode independent of
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= the value of the absolute mode indicator. The processor stays in
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= absolute mode if the absolute mode indicator is ON after the execution
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= of the instructions.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= The instruction at C+4 must not alter the contents of main memory
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= location C+5, and must not be an xed instruction.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= If the contents of the instruction counter (PPR.IC) are changed during
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= execution of the instruction pair at C+4, the next instruction is fetched
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= from the modified C(PPR.IC); otherwise, the next instruction is fetched
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= from C(PPR.IC)+1.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= If the instruction at C+4 alters C(PPR.IC), then this transfer of control
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= is effective immediately, and the instruction at C+5 is not executed.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= Attempted repetition with the rpt, rpd, or rpl instructions causes an
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= illegal procedure fault.
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= mme2
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Master Mode Entry 2
%= \end{flushleft}
%= 
%= 
%= 
%= 004 (0)
%= 
%= 
%= 

\inbif
\insum {
Causes a fault that fetches and executes, in absolute mode, the instruction
pair at main memory location C+(52)8. The value of C is obtained from the
FAULT VECTOR switches on the processor configuration panel.}
\inabn
\innaf
%= NOTES:
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Attempted execution in BAR mode causes an illegal procedure fault.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= Except for the different constant used for fetching the instruction pair
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= from main memory, the mme2 instruction is identical to the mme instruction.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= Attempted repetition with the rpt, rpd, or rpl instructions causes an
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= illegal procedure fault.
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= \newpage
%= mme3
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Master Mode Entry 3
%= \end{flushleft}
%= 
%= 
%= 
%= 005 (0)
%= 
%= 
%= 

\inbif
\insum {
Causes a fault that fetches and executes, in absolute mode, the instruction
pair at main memory location C+(54)8. The value of C is obtained from the
FAULT VECTOR switches on the processor configuration panel.}
\inabn
\innaf
%= NOTES:
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Attempted execution in BAR mode causes an illegal procedure fault.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= Except for the different constant used for fetching the instruction pair
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= from main memory, the mme3 instruction is identical to the mme instruction.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= Attempted repetition with the rpt, rpd, or rpl instructions causes an
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= illegal procedure fault.
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= mme4
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Master Mode Entry 4
%= \end{flushleft}
%= 
%= 
%= 
%= 007 (0)
%= 
%= 
%= 

\inbif
\insum {
Causes a fault that fetches and executes, in absolute mode, the instruction
pair at main memory location C+(56)8. The value of C is obtained from the
FAULT VECTOR switches on the processor configuration panel.}
\inabn
\innaf
%= NOTES:
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Attempted execution in BAR mode causes an illegal procedure fault.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= Except for the different constant used for fetching the instruction pair
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= from main memory, the mme4 instruction is identical to the mme instruction.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= Attempted repetition with the rpt, rpd, or rpl instructions causes an
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= illegal procedure fault.
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= \newpage

\subsubsection{No Operation}

%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= nop
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= No Operation
%= \end{flushleft}
%= 
%= 
%= 
%= 011 (0)
%= 
%= 
%= 

\inbif
\insum {No operation takes place}
\inall
\inind {None affected (except as noted below)}
%= NOTES:
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= No operation takes place but address preparation is performed according
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= to the specified modifier, if any. If modification other than du or dl is
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= used, the computed addresses generated may cause faults.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= The use of indirect then tally modifiers causes changes in the address and
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= tally fields of the referenced indirect words and the tally runout indicator
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= may be set ON as a result.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= Attempted repetition with the rpt, rpd, or rpl instructions causes an
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= illegal procedure fault.
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= puls1
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Pulse One
%= \end{flushleft}
%= 
%= 
%= 
%= 012 (0)
%= 
%= 
%= 

\inbif
\insum {No operation takes place}
\inall
\inind {None affected (except as noted below)}
%= NOTES:
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= The puls1 instruction is identical to the nop instruction except that it
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= causes certain unique synchronizing signals to appear in the processor
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= logic circuitry.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= Attempted repetition with the rpt, rpd, or rpl instructions causes an
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= illegal procedure fault.
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= puls2
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Pulse Two
%= \end{flushleft}
%= 
%= 
%= 
%= 013 (0)
%= 
%= 
%= 

\inbif
\insum {No operation takes place}
\inall
\inind {None affected (except as noted below)}
%= NOTES:
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= The puls2 instruction is identical to the nop instruction except that it
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= causes certain unique synchronizing signals to appear in the processor
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= logic circuitry.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= Attempted repetition with the rpt, rpd, or rpl instructions causes an
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= illegal procedure fault.
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= \newpage

\subsubsection{Repeat}

%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= rpd
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Repeat Double
%= \end{flushleft}
%= 
%= 
%= 
%= 560 (0)
%= 
%= 
%= 
%= \begin{flushleft}
%= FORMAT:
%= \end{flushleft}
%= 
%= 0
%= 
%= 0
%= 
%= 
%= 
%= 0 0 0 1 1
%= 
%= 7 8 9 0 1
%= 
%= \begin{flushleft}
%= TALLY
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= A B C
%= \end{flushleft}
%= 
%= 
%= 
%= 1 1
%= 
%= 7 8
%= 
%= \begin{flushleft}
%= Term. Cond.
%= \end{flushleft}
%= 
%= 
%= 
%= 8 1 1 1
%= 
%= 
%= 
%= 2 2 2 2 3
%= 
%= 6 7 8 9 0
%= 
%= (560)8
%= 
%= 
%= 
%= 7
%= 
%= 
%= 
%= 0 1 0
%= 
%= 
%= 
%= 3
%= 
%= 5
%= 
%= \begin{flushleft}
%= DELTA
%= \end{flushleft}
%= 
%= 
%= 
%= 9 1 1 1
%= 
%= 
%= 
%= 6
%= 
%= 
%= 
%= \begin{flushleft}
%= Figure 4-9. Repeat Double (rpd) Instruction Word Format
%= \end{flushleft}
%= 
%= \begin{flushleft}
\insum {
Execute the pair of instructions at C(PPR.IC)+1 either a specified number
of times or until a specified termination condition is met.}
\inmod {None}
\inina

%= Tally runout
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= If C(X0)0,7 = 0 at termination, then ON; otherwise, OFF
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= All other
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= indicators
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= None affected. However, the execution of the repeated instructions may
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= affect indicators.
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= NOTES:
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= The rpd instruction must be located in an odd main memory location
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= except when accessed via the xec or xed instructions, in which case the
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= xec or xed instruction must itself be in an odd main memory location.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= Both repeated instructions must use R or RI modifiers and only X1, X2, ...,
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= X7 are permitted. For the purposes of this description, the even repeated
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= instruction shall use X-even and the odd repeated instruction shall use Xodd. X-even and X-odd may be the same register.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= If C = 1, then C(rpd instruction word )0,17 $\rightarrow$ C(X0); otherwise, C(X0) is
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= unchanged prior to execution.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= The termination condition and tally fields of C(X0) control the repetition of
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= the instruction pair. An initial tally of zero is interpreted as 256.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= The repetition cycle consists of the following steps:
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= a. Execute the pair of repeated instructions
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= b. C(X0)0,7 - 1 $\rightarrow$ C(X0)0,7
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= Modify C(X-even) and C(X-odd) as described below.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= c. If C(X0)0,7 = 0, then set the tally runout indicator ON and terminate.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= d. If a terminate condition has been met, then set the tally runout indicator
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= OFF and terminate.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= e. Go to step a.
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= \newpage
%= If a fault occurs during the execution of the instruction pair, the repetition
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= loop is terminated and control passes to the instruction pair associated
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= with the fault according to the conditions for the fault. C(X0), C(X-even),
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= and C(X-odd) are not updated for the repetition cycle in which the fault
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= occurs. Note in particular that certain faults occurring during execution of
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= the even instruction preclude the execution of the odd instruction for the
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= faulting repetition cycle.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= EIS multiword instructions cannot be repeated. All other instructions may
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= be repeated except as noted for individual instructions or those that
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= explicitly alter C(X0).
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= The computed addresses, y-even and y-odd, of the operands (in the case of
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= R modification) or indirect words (in the case of RI modification) are
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= determined as follows:
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= For the first execution of the repeated instruction pair:
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= C(C(PPR.IC)+ 1)0,17 + C(X-even) $\rightarrow$ y-even, y-even $\rightarrow$ C(X-even)
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= C(C(PPR.IC)+2)0,17 + C(X-odd) $\rightarrow$ y-odd, y-odd $\rightarrow$ C(X-odd)
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= For all successive executions of the repeated instruction pair:
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= if C(X0)8 = 1, then C(X-even) + Delta $\rightarrow$ y-even,
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= y-even $\rightarrow$ C(X-even);
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= otherwise, C(X-even) $\rightarrow$ y-even
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= if C(X0)9 = 1, then C(X-odd) + Delta $\rightarrow$ y-odd,
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= y-odd $\rightarrow$ C(X-odd);
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= otherwise, C(X-odd) $\rightarrow$ y-odd
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= C(X0)8,9 correspond to control bits A and B, respectively, of the rpd
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= instruction word.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= In the case of RI modification, only one indirect reference is made per
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= repeated execution. The TAG field of the indirect word is not interpreted.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= The indirect word is treated as though it had R modification with R = N.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= The bit configuration in C(X0)11,17 defines the conditions for which the
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= repetition loop is terminated. The terminate conditions are examined at
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= the completion of execution of the odd instruction. If more than one
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= condition is specified, the repeat terminates if any of the specified
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= conditions are met.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= Bit 17 = 0
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Ignore all overflows. Do not set the overflow indicator and
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= inhibit the overflow fault.
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Bit 17 = 1
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Process overflows. If the overflow mask indicator is ON,
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= then set the overflow indicator and terminate; otherwise,
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= cause an overflow fault.
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Bit 16 = 1
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Terminate if the carry indicator is OFF.
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Bit 15 = 1
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Terminate if the carry indicator is ON.
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Bit 14 = 1
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Terminate if the negative indicator is OFF.
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Bit 13 = 1
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Terminate if the negative indicator is ON.
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Bit 12 = 1
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Terminate if the zero indicator is OFF.
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Bit 11 = 1
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Terminate if the zero indicator is ON.
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= At the time of termination:
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= C(X0)0,7 contain the tally residue; that is, the number of repeats
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= remaining until a tally runout would have occurred.
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= \newpage
%= If the rpd instruction is interrupted (by any fault) before termination,
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= the tally runout indicator is OFF.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= C(X-even) and C(X-odd) contain the computed addresses of the next
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= operands or indirect words that would have been used had the
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= repetition loop not terminated.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= Attempted repetition with the rpt, rpd, or rpl instructions causes an
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= illegal procedure fault.
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= rpl
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Repeat Link
%= \end{flushleft}
%= 
%= 
%= 
%= 500 (0)
%= 
%= 
%= 
%= \begin{flushleft}
%= FORMAT:
%= \end{flushleft}
%= 
%= 0
%= 
%= 0
%= 
%= 
%= 
%= 0 0 0 1 1
%= 
%= 7 8 9 0 1
%= 
%= \begin{flushleft}
%= TALLY
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= 0 0 C
%= \end{flushleft}
%= 
%= 8
%= 
%= 
%= 
%= 1 1
%= 
%= 7 8
%= 
%= \begin{flushleft}
%= Term. Cond.
%= \end{flushleft}
%= 
%= 
%= 
%= 2 1
%= 
%= 
%= 
%= 2 2 2 2 3
%= 
%= 6 7 8 9 0
%= 
%= (500)8
%= 
%= 
%= 
%= 7
%= 
%= 
%= 
%= 3
%= 
%= 5
%= 
%= 
%= 
%= 0 1 0 0 0 0 0 0 0
%= 
%= 9 1 1 1
%= 
%= 
%= 
%= 6
%= 
%= 
%= 
%= \begin{flushleft}
%= Figure 4-10. Repeat Link (rpl) Instruction Word Format
%= \end{flushleft}
%= 
%= \begin{flushleft}
\insum {
Execute the instruction at C(PPR.IC)+1 either a specified number of times
or until a specified termination condition is met.}
\inmod {None}
\inina

%= Tally runout
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= If C(X0)0,7 = 0 or link address C(Y)0,17 = 0 at runout termination, then ON;
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= otherwise OFF.
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= All other
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= indicators
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= None affected. However, the execution of the repeated instruction may
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= affect indicators.
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= NOTES:
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= The repeated instruction must use an R modifier and only X1, X2, ..., X7
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= are permitted.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= For the purposes of this description, the repeated
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= instruction shall use Xn.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= If C = 1, then C(rpl instruction word)0,17 $\rightarrow$ C(X0); otherwise, C(X0) is
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= unchanged prior to execution.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= The termination condition and tally fields of C(X0) control the repetition of
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= the instruction. An initial tally of zero is interpreted as 256.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= The repetition cycle consists of the following steps:
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= a. Execute the repeated instruction
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= b. C(X0)0,7 - 1 $\rightarrow$ C(X0)0,7
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= Modify C(Xn) as described below.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= c. If C(X0)0,7 = 0 or C(Y)0,17 = 0, then set the tally runout indicator ON
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= and terminate.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= d. If a terminate condition has been met, then set the tally runout indicator
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= OFF and terminate.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= e. Go to step a.
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= \newpage
%= If a fault occurs during the execution of the instruction, the repetition loop
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= is terminated and control passes to the instruction pair associated with the
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= fault according to the conditions for the fault. C(X0) and C(Xn) are not
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= updated for the repetition cycle in which the fault occurs.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= EIS multiword instructions cannot be repeated. All other instructions may
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= be repeated except as noted for individual instructions or those that
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= explicitly alter C(X0) or explicitly alter the link address, C(Y)0,17.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= The computed address, y, of the operand is determined as follows:
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= For the first execution of the repeated instruction:
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= C(C(PPR.IC)+1)0,17 + C(Xn) $\rightarrow$ y, y $\rightarrow$ C(Xn)
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= For all successive executions of the repeated instruction:
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= C(Xn) $\rightarrow$ y
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= if C(Y)0,17 $\neq$ 0, then C (y)0,17 $\rightarrow$ C(Xn);
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= otherwise, no change to C(Xn)
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= C(Y)0,17 is known as the link address and is the computed address of the
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= next entry in a threaded list of operands to be referenced by the repeated
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= instruction.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= The operand is formed as:
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= (00...0)0,17 $||$ C(Y)18,p
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= where p is 35 for single precision operands and 71 for double precision
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= operands.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= The bit configuration in C(X0)11,17 and the link address, C(Y)0,17 define the
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= conditions for which the repetition loop is terminated. The terminate
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= conditions are examined at the completion of execution of the instruction.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= If more than one condition is specified, the repeat terminates if any of the
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= specified conditions are met.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= C(Y)0,17 = 0
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Set the tally runout indicator ON and terminate.
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Bit 17 = 0
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Ignore all overflows. Do not set the overflow indicator
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= and inhibit the overflow fault.
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Bit 17 = 1
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Process overflows. If the overflow mask indicator is ON,
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= then set the overflow indicator and terminate; otherwise,
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= cause an overflow fault.
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Bit 16 = 1
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Terminate if the carry indicator is OFF.
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Bit 15 = 1
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Terminate if the carry indicator is ON.
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Bit 14 = 1
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Terminate if the negative indicator is OFF.
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Bit 13 = 1
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Terminate if the negative indicator is ON.
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Bit 12 = 1
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Terminate if the zero indicator is OFF.
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Bit 11 = 1
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Terminate if the zero indicator is ON.
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= At the time of termination:
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= C(X0)0,7 contain the tally residue; that is, the number of repeats
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= remaining until a tally runout would have occurred.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= If the rpl instruction is interrupted (by any fault) before termination,
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= the tally runout indicator is OFF.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= C(Xn) contain the last link address, that is, the computed address of the
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= list word containing the last operand and the next link address.
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= \newpage
%= Attempted repetition with the rpt, rpd, or rpl instructions causes an
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= illegal procedure fault.
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= rpt
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Repeat
%= \end{flushleft}
%= 
%= 
%= 
%= 520 (0)
%= 
%= 
%= 
%= \begin{flushleft}
%= FORMAT:
%= \end{flushleft}
%= 
%= 0
%= 
%= 0
%= 
%= 
%= 
%= 0 0 0 1 1
%= 
%= 7 8 9 0 1
%= 
%= \begin{flushleft}
%= TALLY
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= 0 0 C
%= \end{flushleft}
%= 
%= 8
%= 
%= 
%= 
%= 1 1
%= 
%= 7 8
%= 
%= \begin{flushleft}
%= Term. Cond.
%= \end{flushleft}
%= 
%= 
%= 
%= 2 1
%= 
%= 
%= 
%= 2 2 2 2 3
%= 
%= 6 7 8 9 0
%= 
%= (520)8
%= 
%= 
%= 
%= 7
%= 
%= 
%= 
%= 0 1 0
%= 
%= 9 1 1 1
%= 
%= 
%= 
%= 3
%= 
%= 5
%= 
%= \begin{flushleft}
%= DELTA
%= \end{flushleft}
%= 
%= 6
%= 
%= 
%= 
%= \begin{flushleft}
%= Figure 4-11. Repeat (rpt) Instruction Word Format
%= \end{flushleft}
%= 
%= \begin{flushleft}
\insum {
Execute the instruction at C(PPR.IC)+1 either a specified number of times
or until a specified termination condition is met.}
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= MODIFICATIONS:
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= None
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}

\inina

%= Tally runout
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= If C(X0)0,7 = 0 at termination, then ON; otherwise, OFF
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= All other
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= indicators
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= None affected. However, the execution of the repeated instruction may
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= affect indicators.
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= NOTES:
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= The repeated instruction must use an R or RI modifier and only X1, X2, ...,
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= X7 are permitted. For the purposes of this description, the repeated
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= instruction shall use Xn.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= If C = 1, then C(rpt instruction word)0,17 $\rightarrow$ C(X0); otherwise, C(X0)
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= unchanged prior to execution.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= The termination condition and tally fields of C(X0) control the repetition of
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= the instruction. An initial tally of zero is interpreted as 256.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= The repetition cycle consists of the following steps:
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= a. Execute the repeated instruction
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= b. C(X0)0,7 - 1 $\rightarrow$ C(X0)0,7
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= Modify C(Xn) as described below
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= c. If C(X0)0,7 = 0, then set the tally runout indicator ON and terminate
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= d. If a terminate condition has been met, then set the tally runout indicator
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= OFF and terminate
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= e. Go to step a
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= If a fault occurs during the execution of the instruction, the repetition loop
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= is terminated and control passes to the instruction pair associated with the
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= fault according to the conditions for the fault. C(X0) and C(Xn) are not
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= updated for the repetition cycle in which the fault occurs.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= EIS multiword instructions cannot be repeated. All other instructions may
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= be repeated except as noted for individual instructions or those that
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= explicitly alter C(X0) or explicitly alter the instruction pair containing the
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= repeated instruction.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= The computed address, y, of the operand (in the case of R modification) or
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= indirect word (in the case of RI modification) is determined as follows:
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= \newpage
%= For the first execution of the repeated instruction:
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= C(C(PPR.IC)+1)0,17 + C(Xn) $\rightarrow$ y, y $\rightarrow$ C(Xn)
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= For all successive executions of the repeated instruction:
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= C(Xn) + Delta $\rightarrow$ y, y $\rightarrow$ C(Xn);
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= In the case of RI modification, only one indirect reference is made per
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= repeated execution. The TAG field of the indirect word is not interpreted.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= The indirect word is treated as though it had R modification with R = N.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= The bit configuration in C(X0)11,17 defines the conditions for which the
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= repetition loop is terminated. The terminate conditions are examined at
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= the completion of execution of the instruction. If more than one condition
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= is specified, the repeat terminates if any of the specified conditions are
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= met. overflow indicator and inhibit the overflow fault.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= Bit 17 = 0
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Ignore all overflows. Do not set the overflow indicator and
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= inhibit the overflow fault.
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Bit 17 = 1
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Process overflows. If the overflow mask indicator is ON,
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= then set the overflow indicator and terminate; otherwise,
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= cause an overflow fault.
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Bit 16 = 1
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Terminate if the carry indicator is OFF.
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Bit 15 = 1
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Terminate if the carry indicator is ON.
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Bit 14 = 1
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Terminate if the negative indicator is OFF.
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Bit 13 = 1
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Terminate if the negative indicator is ON.
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Bit 12 = 1
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Terminate if the zero indicator is OFF.
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Bit 11 = 1
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Terminate if the zero indicator is ON.
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= At the time of termination:
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= C(X0)0,7 contain the tally residue; that is, the number of repeats
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= remaining until a tally runout would have occurred.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= If the rpt instruction is interrupted (by any fault) before termination,
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= the tally runout indicator is OFF.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= C(Xn) contain the computed address of the next operand or indirect
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= word that would have been used had the repetition loop not
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= terminated.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= Attempted repetition with the rpt, rpd, or rpl instructions causes an
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= illegal procedure fault.
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= \newpage

\subsubsection{Ring Alarm Register}

%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= sra
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Store Ring Alarm
%= \end{flushleft}
%= 
%= 
%= 
%= 754 (1)

\inbif

\insum {00...0 $\rightarrow$ C(Y)0,32}
\inull {C(RALR) $\rightarrow$ C(Y)33,35}
\indcs
\innaf
%= NOTES:
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Attempted execution in BAR mode causes an illegal procedure fault.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= Attempted repetition with the rpt, rpd, or rpl instructions causes an
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= illegal procedure fault.
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= \newpage

\subsubsection{Store Base Address Register}

%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= sbar
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Store Base Address Register
%= \end{flushleft}
%= 
%= 
%= 
%= 550 (0)

\inbif
\insum {C(BAR) $\rightarrow$ C(Y)0,17}
\indcs
\innaf

\subsubsection{Translation}

%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= bcd
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Binary to Binary-Coded-Decimal
%= \end{flushleft}
%= 
%= 
%= 
%= 505 (0)

\inbif
\insum {Shift C(A) left three positions}
\inull {$|$ C(A) $|$ / C(Y) $\rightarrow$ 4-bit quotient plus remainder}
\inull {Shift C(Q) left six positions}
\inull {4-bit quotient $\rightarrow$ C(Q)32,35}
\inull {remainder $\rightarrow$ C(A)}
\incss
\inina
\ininZ {A}
\ininn {If C(A)\tsb{0} = 1 before execution, then ON; otherwise OFF}

%= NOTES:
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= The bcd instruction carries out one step in an algorithm for the conversion
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= of a binary number to a string of Binary-Coded-Decimal (BCD) digits. The
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= algorithm requires the repeated short division of the binary number or last
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= remainder by a set of constants = 8**i x 10**(n-i) for i = 1, 2, ..., n with n
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= being defined by:
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= 10**(n-1) $<$= $|$ $<$binary number$>$ $|$ $<$= 10**n - 1.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= The values in the table that follows are the conversion constants to be used
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= with the bcd instruction. Each vertical column represents the set of
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= constants to be used depending on the initial value of the binary number to
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= be converted. The instruction is executed once per digit while traversing
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= the appropriate column from top to bottom.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= An alternate use of the table for conversion involves the use of the
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= constants in the row corresponding to conversion step 1. If, after each
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= execution, the contents of the accumulator are shifted right 3 positions, the
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= constants in the first row, starting at the appropriate column, may be used
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= while traversing the row from left to right.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= Because there is a limit on range, a full 36-bit word cannot be converted.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= The largest binary number that may be converted correctly is 2**33 - 1
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= yielding ten decimal digits.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= Attempted repetition with the rpl instruction causes an illegal procedure
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= fault.
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= \newpage
%= For 10**(n-1) $<$= $|$ C(A) $|$ $<$= 10**n - 1 and n =
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Step
%= \end{flushleft}
%= 
%= 
%= 
%= 10
%= 
%= 
%= 
%= 9
%= 
%= 
%= 
%= 8
%= 
%= 
%= 
%= 7
%= 
%= 
%= 
%= 6
%= 
%= 
%= 
%= 5
%= 
%= 
%= 
%= 1
%= 
%= 2
%= 
%= 3
%= 
%= 4
%= 
%= 5
%= 
%= 6
%= 
%= 7
%= 
%= 8
%= 
%= 9
%= 
%= 10
%= 
%= 
%= 
%= 8000000000
%= 
%= 6400000000
%= 
%= 5120000000
%= 
%= 4096000000
%= 
%= 3276800000
%= 
%= 2621440000
%= 
%= 2097152000
%= 
%= 1677721600
%= 
%= 1342177280
%= 
%= 1073741824
%= 
%= 
%= 
%= 800000000
%= 
%= 640000000
%= 
%= 512000000
%= 
%= 409600000
%= 
%= 327680000
%= 
%= 262144000
%= 
%= 209715200
%= 
%= 167772160
%= 
%= 134217728
%= 
%= 
%= 
%= 80000000
%= 
%= 64000000
%= 
%= 51200000
%= 
%= 40960000
%= 
%= 32768000
%= 
%= 26214400
%= 
%= 20971520
%= 
%= 16777216
%= 
%= 
%= 
%= 8000000
%= 
%= 6400000
%= 
%= 5120000
%= 
%= 4096000
%= 
%= 3276800
%= 
%= 2621440
%= 
%= 2097152
%= 
%= 
%= 
%= 800000
%= 
%= 640000
%= 
%= 512000
%= 
%= 409600
%= 
%= 327680
%= 
%= 262144
%= 
%= 
%= 
%= 80000
%= 
%= 64000
%= 
%= 51200
%= 
%= 40960
%= 
%= 32768
%= 
%= 
%= 
%= \begin{flushleft}
%= gtb
%= \end{flushleft}
%= 
%= 
%= 
%= 4
%= 
%= 
%= 

\inbif
\insum {C(A) is converted from Gray Code to a 36-bit binary number}
\inmod {None}
\inina
\ininN {A}
%= NOTES:
%= \end{flushleft}
%= 
%= 
%= 
%= 2
%= 
%= 
%= 
%= 8000 800 80
%= 
%= 6400 640 64
%= 
%= 5120 512
%= 
%= 4096
%= 
%= 
%= 
%= \begin{flushleft}
%= Gray to Binary
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Zero
%= \end{flushleft}
%= 
%= 
%= 
%= 3
%= 
%= 
%= 
%= 1
%= 
%= 8
%= 
%= 
%= 
%= 774 (0)
%= 
%= 
%= 
%= \begin{flushleft}
%= This conversion is defined by the following algorithm:
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= C(A)0 $\rightarrow$ C(A)0
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= C(A)i $\oplus$ C(A)i-1 $\rightarrow$ C(A)i for i = 1, 2, ..., 35
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= Attempted repetition with the rpl instruction causes an illegal procedure
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= fault.
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= \newpage

\subsection{REGISTER LOAD}

%= \end{flushleft}
%= 
%= \begin{flushleft}
%= lbar
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Load Base Address Register
%= \end{flushleft}
%= 
%= 
%= 
%= 230 (0)
%= 
%= 
%= 

\inbif
\insum {C(Y)0,17 $\rightarrow$ C(BAR)}
\incss
\innaf
%= NOTES:
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Attempted repetition with the rpt, rpd, or rpl instructions causes an
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= illegal procedure fault.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= Attempted execution in BAR mode causes a illegal procedure fault.
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= \newpage

\subsection{PRIVILEGED INSTRUCTIONS}

%= \end{flushleft}
%= 
%= \begin{flushleft}

\subsubsection{Privileged - Register Load}

%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= lcpr
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Load Central Processor Register
%= \end{flushleft}
%= 
%= 
%= 
%= 674 (0)
%= 
%= 
%= 

\inbif
\insum {Load selected register as noted}
%= MODIFICATIONS:
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= None. The instruction word TAG field is used for register selection as
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= follows:
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= C(TAG)
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Data and Register(s)
%= \end{flushleft}
%= 
%= 
%= 
%= 02
%= 
%= 
%= 
%= \begin{flushleft}
%= C(Y) $\rightarrow$ C(cache mode register)
%= \end{flushleft}
%= 
%= 
%= 
%= 04
%= 
%= 
%= 
%= \begin{flushleft}
%= C(Y) $\rightarrow$ C(mode register)
%= \end{flushleft}
%= 
%= 
%= 
%= 03
%= 
%= 
%= 
%= \begin{flushleft}
%= DPS/L68 processors:
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= 00...0 $\rightarrow$ C(CU, OU, DU, and APU history register)0,71
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= DPS 8M processors:
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= 00...0 $\rightarrow$ C(CU, OU/DU, APU \#1 and APU \#2 history
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= register)0,71
%= \end{flushleft}
%= 
%= 
%= 
%= 07
%= 
%= 
%= 
%= \begin{flushleft}
%= DPS/L68 processors:
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= 11...1 $\rightarrow$ C(CU, OU, DU, and APU history register)0,71
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= DPS 8M processors:
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= 11...1 $\rightarrow$ C(CU, OU/DU, APU \#1 and APU \#2 history
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= register)0,71
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= INDICATORS:
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= None affected
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= NOTES:
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= See Section 3 for descriptions and use of the various registers.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= For TAG values 03 and 07, the history register loaded is selected by the
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= current value of a cyclic counter for each unit. All four cyclic counters are
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= advanced by one count for each execution of the instruction.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= Use of TAG values other than those defined above causes an illegal
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= procedure fault.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= Attempted execution in normal or BAR modes causes a illegal procedure
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= fault.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= Attempted repetition with the rpt, rpd, or rpl instructions causes an illegal
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= procedure fault.
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= ldbr
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= FORMAT:
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Load Descriptor Segment Base Register
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= Basic instruction format (see Figure 4-1).
%= \end{flushleft}
%= 
%= 
%= 
%= 232 (0)
%= 
%= 
%= 
%= \begin{flushleft}
%= \newpage
\insum {If SDWAM is enabled, then}
\inull {\hspace{1em}0 $\rightarrow$ C(SDWAM(i).FULL) for i = 0, 1, ..., 15}
\inull {\hspace{1em}i $\rightarrow$ C(SDWAM(i).USE) for i = 0, 1, ..., 15}
\inull {If PTWAM is enabled, then}
\inull {\hspace{1em}0 $\rightarrow$ C(PTWAM(i).FULL) for i = 0, 1, ..., 15}
\inull {\hspace{1em}i $\rightarrow$ C(PTWAM(i).USE) for i = 0, 1, ..., 15}
\inull {If cache is enabled, reset all cache column and level full flags}
\inull {C(Y-pair)0,23 $\rightarrow$ C(DSBR.ADDR)}
\inull {C(Y-pair)37,50 $\rightarrow$ C(DSBR.BOUND)}
\inull {C(Y-pair)55 $\rightarrow$ C(DSBR.U)}
\inull {C(Y-pair)60,71 $\rightarrow$ C(DSBR.STACK)}
\indcs
\innaf
%= NOTES:
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= The associative memories and cache are cleared (full indicators reset) if
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= they are enabled.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= See Section 3 and Section 5 for descriptions and use of the SDWAM,
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= PTWAM, and DSBR
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= Attempted execution in normal or BAR modes causes an illegal procedure
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= fault.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= Attempted repetition with the rpt, rpd, or rpl instructions causes an
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= illegal procedure fault.
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= ldt
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Load Timer Register
%= \end{flushleft}
%= 
%= 
%= 
%= 637 (0)
%= 
%= 
%= 

\inbif
\insum {C(Y)0,26 $\rightarrow$ C(TR)}
\incss
\innaf
%= NOTES:
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Attempted execution in normal or BAR modes causes a illegal procedure
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= fault.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= Attempted repetition with the rpt, rpd, or rpl instructions causes an
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= illegal procedure fault.
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= lptp
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= FORMAT:
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Load Page Table Pointers
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= Basic instruction format (see Figure 4-1).
%= \end{flushleft}
%= 
%= 
%= 
%= 257 (1)
%= 
%= 
%= 
%= \begin{flushleft}
%= \newpage
\insum {For i = 0, 1, ..., 15}
\inull {\hspace{1em}m = C(PTWAM(i).USE)}
\inull {\hspace{1em}C(Y-block16+m)0,14 $\rightarrow$ C(PTWAM(m).POINTER)}
\inull {\hspace{1em}C(Y-block16+m)15,26 $\rightarrow$ C(PTWAM(m).PAGE)}
\inull {\hspace{1em}C(Y-block16+m)27 $\rightarrow$ C(PTWAM(m).F)}
\indcs
\innaf
%= NOTES:
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= The associative memory is ignored (forced to {``}no match'') during address
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= preparation.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= See Section 3 and Section 5 for description and use of the PTWAM.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= This instruction is not available on the DPS 8M processor and attempted
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= execution on a DPS 8M processor causes an illegal procedure fault.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= Attempted execution in normal or BAR modes causes an illegal procedure
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= fault.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= Attempted repetition with the rpt, rpd, or rpl instructions causes an
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= illegal procedure fault.
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= lptr
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Load Page Table Registers
%= \end{flushleft}
%= 
%= 
%= 
%= 173 (1)

\inbif

\insum {For i = 0, 1, ..., 15}
\inull {\hspace{1em}m = C(PTWAM(i).USE)}
\inull {\hspace{1em}C(Y-block16+m)0,17 $\rightarrow$ C(PTWAM(m).ADDR)}
\inull {\hspace{1em}C(Y-block16+m)29 $\rightarrow$ C(PTWAM(m).M)}
\indcs
\innaf
%= NOTES:
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= The associative memory is ignored (forced to {``}no match'') during address
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= preparation.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= See Section 3 and Section 5 for description and use of the PTWAM.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= Attempted execution in normal or BAR modes causes an illegal procedure
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= fault.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= This instruction is not available on the DPS 8M processor and attempted
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= execution on a DPS 8M processor produces an illegal procedure fault.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= Attempted repetition with the rpt, rpd, or rpl instructions causes an
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= illegal procedure fault.
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= lra
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Load Ring Alarm Register
%= \end{flushleft}
%= 
%= 
%= 

\inbif
\insum {C(Y)33,35 $\rightarrow$ C(RALR)}
\indcs
\innaf
%= NOTES:
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Attempted execution in normal or BAR modes causes an illegal procedure
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= fault.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= Attempted repetition with the rpt, rpd, or rpl instructions causes an
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= illegal procedure fault.
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= lsdp
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Load Segment Descriptor Pointers
%= \end{flushleft}
%= 
%= 
%= 
%= 257 (0)
\inbif
\insum {For i = 0, 1, ..., 15}
\inull {\hspace{1em}m = C(SDWAM(i).USE)}
\inull {\hspace{1em}C(Y-block16+m)0,14 $\rightarrow$ C(SDWAM(m).POINTER)}
\inull {\hspace{1em}C(Y-block16+m)17 $\rightarrow$ C(SDWAM(m).P)}
\indcs
\innaf
%= NOTES:
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= The associative memory is ignored (forced to {``}no match'') during address
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= preparation.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= See Section 3 and Section 5 for description and use of the SDWAM.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= This instruction is not available on the DPS 8M processor and attempted
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= execution on a DPS 8M processor produces an illegal procedure fault.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= Attempted execution in normal or BAR modes causes an illegal procedure
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= fault.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= Attempted repetition with the rpt, rpd, or rpl instructions causes an
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= illegal procedure fault.
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= lsdr
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Load Segment Descriptor Registers
%= \end{flushleft}
%= 
%= 
%= 
%= 232 (1)

\inbif
\insum {For i = 0, 1, ..., 15}
\inull {\hspace{1em}m = C(SDWAM(i).USE)}
\inull {\hspace{1em}Y-pair = Y-block32 + 2m}
\inull {\hspace{1em}C(Y-pair)0,23 $\rightarrow$ C(SDWAM(m).ADDR)}
\inull {\hspace{1em}C(Y-pair)24,32 $\rightarrow$ C(SDWAM(m).R1, R2, R3)}
\inull {\hspace{1em}C(Y-pair)37,50 $\rightarrow$ C(SDWAM(m).BOUND)}
\inull {\hspace{1em}C(Y-pair)52,57 $\rightarrow$ C(SDWAM(m).R, E, W, P, U, G, C)}
\inull {\hspace{1em}C(Y-pair)58,71 $\rightarrow$ C(SDWAM(m).CL)}
\indcs
\innaf
%= NOTES:
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= The associative memory is ignored (forced to {``}no-match'') during address
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= preparation.
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= \newpage
%= See Section 3 and Section 5 for description and use of the SDWAM.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= This instruction is not available on the DPS 8M processor and attempted
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= execution on a DPS 8M processor produces an illegal procedure fault.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= Attempted execution in normal or BAR modes causes an illegal procedure
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= fault.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= Attempted repetition with the rpt, rpd, or rpl instructions causes an
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= illegal procedure fault.
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= rcu
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Restore Control Unit
%= \end{flushleft}
%= 
%= 
%= 

\inbif
\insum {C(Y-block8) words 0 to 7 $\rightarrow$ (control unit data)}
\indcs
\innaf
%= NOTES:
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= See Section 3 for description and use of control unit data.
%= \end{flushleft}
%= 
%= 
%= 
%= 613 (0)
%= 
%= 
%= 
%= \begin{flushleft}
%= Attempted execution in normal or BAR modes causes an illegal procedure
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= fault.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= Attempted repetition with the rpt, rpd, or rpl instructions causes an
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= illegal procedure fault.
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= \newpage

\subsubsection{Privileged - Register Store}

%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= scpr
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Store Central Processor Register
%= \end{flushleft}
%= 
%= 
%= 
%= 452 (0)
%= 
%= 
%= 

\inbif
\insum {Store selected register as noted}
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= MODIFICATIONS:
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= None. The instruction word TAG field is used for register selection word
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= as follows:
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= C(TAG)
%= \end{flushleft}
%= 
%= 00
%= 
%= 
%= 
%= \begin{flushleft}
%= MEANING
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= DPS/L68 processor:
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= C(APU history register) $\rightarrow$ C(Y-pair)
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= DPS 8M processor:
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= C(APU history register \#1) $\rightarrow$ C(Y-pair)
%= \end{flushleft}
%= 
%= 
%= 
%= 01
%= 
%= 
%= 
%= \begin{flushleft}
%= C(fault register) $\rightarrow$ C(Y-pair)0,35
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= 00...0 $\rightarrow$ C(Y-pair)36,71
%= \end{flushleft}
%= 
%= 
%= 
%= 06
%= 
%= 
%= 
%= \begin{flushleft}
%= C(mode register) $\rightarrow$ C(Y-pair)0,35
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= C(cache mode register) $\rightarrow$ C(Y-pair)36,71
%= \end{flushleft}
%= 
%= 
%= 
%= 10
%= 
%= 
%= 
%= \begin{flushleft}
%= DPS/L68 processor:
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= C(DU history register) $\rightarrow$ C(Y-pair)
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= DPS 8M processor:
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= C(APU history register \#2) $\rightarrow$ C(Y-pair)
%= \end{flushleft}
%= 
%= 
%= 
%= 20
%= 
%= 
%= 
%= \begin{flushleft}
%= C(CU history register) $\rightarrow$ C(Y-pair)
%= \end{flushleft}
%= 
%= 
%= 
%= 40
%= 
%= 
%= 
%= \begin{flushleft}
%= DPS/L68 processor
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= C(OU history register) $\rightarrow$ C(Y-pair)
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= DPS 8M processor:
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= C(OU/DU history register) $\rightarrow$ C(Y-pair)
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= INDICATORS:
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= None affected
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= NOTES:
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= See Section 3 for description and use of the various registers.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= The TAG field values shown are octal.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= For TAG values 00, 10, 20, and 40, the history register stored is selected
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= by the current value of a cyclic counter for each unit. The individual cyclic
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= counters are advanced by one count for each execution of the instruction.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= The use of TAG values other than those defined above causes an illegal
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= procedure fault.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= Attempted execution in normal or BAR modes causes an illegal procedure
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= fault.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= Attempted repetition with the rpt, rpd, or rpl instructions causes an
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= illegal procedure fault.
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= \newpage
%= scu
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Store Control Unit
%= \end{flushleft}
%= 
%= 
%= 

\inbif

\insum {(control unit data) $\rightarrow$ C(Y-block8)}
\indcs

%= INDICATORS:
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= None affected
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= NOTES:
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= See Section 3 for description and use of control unit data.
%= \end{flushleft}
%= 
%= 
%= 
%= 657 (0)
%= 
%= 
%= 
%= \begin{flushleft}
%= The scu instruction safe-stores control information required to service a
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= fault or interrupt. The control unit data is not, in general, valid at any time
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= except when safe-stored by the first of the pair of instructions associated
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= with the fault or interrupt.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= Attempted execution in normal or BAR modes causes an illegal procedure
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= fault.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= Attempted repetition with the rpt, rpd, or rpl instructions causes an
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= illegal procedure fault.
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= sdbr
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Store Descriptor Segment Base Register
%= \end{flushleft}
%= 
%= 
%= 
%= 154 (0)

\inbif

\insum {C(DSBR.ADDR) $\rightarrow$ C(Y-pair)0,23}
\inull {00...0 $\rightarrow$ C(Y-pair)24,36}
\inull {C(DSBR.BOUND) $\rightarrow$ C(Y-pair)37,50}
\inull {0000 $\rightarrow$ C(Y-pair)51,54}
\inull {C(DSBR.U) $\rightarrow$ C(Y-pair)55}
\inull {000 $\rightarrow$ C(Y-pair)56,59}
\inull {C(DSBR.STACK) $\rightarrow$ C(Y-pair)60,71}
\indcs
\innaf
%= NOTES:
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= C(DSBR) are unchanged.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= See Section 3 and Section 5 for description and use of the DSBR
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= Attempted execution in normal or BAR modes causes an illegal procedure
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= fault.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= Attempted repetition with the rpt, rpd, or rpl instructions causes an
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= illegal procedure fault.
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= sptp
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= FORMAT:
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Store Page Table Pointers
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= Basic instruction format (see Figure 4-1).
%= \end{flushleft}
%= 
%= 
%= 
%= 557 (1)
%= 
%= 
%= 
%= \begin{flushleft}
%= \newpage
\insum {DPS/L68 processors:}
\inull {\hspace{1em}For i = 0, 1, ..., 15}
\inull {\hspace{2em}C(PTWAM(i).POINTER) $\rightarrow$ C(Y-block16+i)0,14}
\inull {\hspace{2em}C(PTWAM(i).PAGE) $\rightarrow$ C(Y-block16+i)15,26}
\inull {\hspace{2em}C(PTWAM(i).F) $\rightarrow$ C(Y-block16+i)27}
\inull {\hspace{2em}0000 $\rightarrow$ C(Y-block16+i)8,31}
\inull {\hspace{2em}C(PTWAM(i).USE) $\rightarrow$ C(Y-block16+i)32,35}
\inull {DPS 8M processors:}
\inull {\hspace{1em}This instruction stores 16 words from the selected level (j) of the}
\inull {\hspace{1em}directory of the Page Table Word associative memory. There are four}
\inull {\hspace{1em}levels.}
\inull {\hspace{1em}Level j is selected by C(TPR.CA)12,13}
\inull {\hspace{1em}For i = 0, 1, ..., 15}
\inull {\hspace{2em}C(PTWAM(i,j).POINTER) $\rightarrow$ C(Y-block16+i)0,14}
\inull {\hspace{2em}C(PTWAM(i,j).PAGENO) $\rightarrow$ C(Y-block16+i)15,22}
\inull {\hspace{2em}0000 $\rightarrow$ C(Y-block16+i)23,26}
\inull {\hspace{2em}C(PTWAM(i,j).F) $\rightarrow$ C(Y-block16+i)27}
\inull {\hspace{2em}00 $\rightarrow$ C(Y-block16+i)28,29}
\inull {\hspace{2em}C(PTWAM(i,j).LRU) $\rightarrow$ C(Y-block16+i)30,35}
\indcs
\innaf
%= NOTES:
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= The contents of the associative memory remain unchanged.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= The associative memory is ignored (forced to {``}no match'') during address
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= preparation.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= See Section 3 and Section 5 for description and use of the PTWAM.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= Attempted execution in normal or BAR modes causes an illegal procedure
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= fault.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= Attempted repetition with the rpt, rpd, or rpl instructions causes an
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= illegal procedure fault.
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= sptr
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Store Page Table Registers
%= \end{flushleft}
%= 
%= 
%= 
%= 154 (1)

\inbif
\insum {DPS/L68 processors:}
\inull {\hspace{1em}For i = 0, 1, ..., 15}
\inull {\hspace{2em}C(PTWAM(i).ADDR) $\rightarrow$ C(Y-block16+i)0,17}
\inull {\hspace{2em}00...0 $\rightarrow$ C(Y-block16+i)18,28}
\inull {\hspace{2em}C(PTWAM(i).M) $\rightarrow$ C(Y-block16+i)29}
\inull {\hspace{2em}00...0 $\rightarrow$ C(Y-block16+i)30,35}
\inull {DPS 8M processors:}
\inull {\hspace{1em}This instruction stores 16 words from the selected level (j) of the}
\inull {\hspace{1em}contents of the Page Table Word associative memory. There are four}
\inull {\hspace{1em}levels.}
\inull {\hspace{1em}Level j is selected by C(TPR.CA)12,13}
\inull {\hspace{1em}For i = 0, 1, ..., 15}
\inull {\hspace{2em}C(PTWAM(i,j).PAGE ADDR) $\rightarrow$ C(Y-block16+1)0,13}
\inull {\hspace{2em}00...0 $\rightarrow$ C(Y-block16+i)14,28}
\inull {\hspace{2em}C(PTWAM(i,j).M $\rightarrow$ C(Y-block16+i)29}
\inull {\hspace{2em}000000 $\rightarrow$ C(Y-block16+i)30,3}
\indcs
\innaf
%= NOTES:
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= The contents of the associative memory are unchanged.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= The associative memory is ignored (forced to {``}no match'') during address
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= preparation.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= See Section 3 and Section 5 for description and use of the PTWAM.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= Attempted execution in normal or BAR modes causes an illegal procedure
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= fault.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= Attempted repetition with the rpt, rpd, or rpl instructions causes an
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= illegal procedure fault.
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= ssdp
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Store Segment Descriptor Pointers
%= \end{flushleft}
%= 
%= 
%= 
%= 557 (0)

\inbif
\insum {DPS/L68 processors:}
\inull {\hspace{1em}For i = 0, 1, ..., 15}
\inull {\hspace{2em}C(SDWAM(i).POINTER) $\rightarrow$ C(Y-block16+i)0,14}
\inull {\hspace{3em}00...0 $\rightarrow$ C(Y-block16+i)15,26}
\inull {\hspace{3em}C(SDWAM(i).F) $\rightarrow$ C(Y-block16+i)27}
\inull {\hspace{3em}0000 $\rightarrow$ C(Y-block16+i)28,31}
\inull {\hspace{3em}C(SDWAM(i).USE) $\rightarrow$ C(Y-block16+i)32,35}
\inull {DPS 8M processors:}
\inull {\hspace{1em}This instruction stores 16 words from the selected level (j) of the}
\inull {\hspace{1em}directory of the Segment Descriptor Word associative memory. There}
\inull {\hspace{1em}are four levels.}
\inull {\hspace{1em}Level j is selected by C(TPR.CA)12,13}
\inull {\hspace{1em}For i = 0, 1, ..., 15}
\inull {\hspace{2em}C(SDWAM(i,j).POINTER) $\rightarrow$ C(Y-block16+i)0,14}
\inull {\hspace{2em}00...0 $\rightarrow$ C(Y-block16+i)15,26}
\inull {\hspace{2em}C(SDWAM(i,j).F) $\rightarrow$ C(Y-block16+i)27}
\inull {\hspace{2em}00 $\rightarrow$ C(Y-block16+i)28,29}
\inull {\hspace{2em}C(SDWAM(i,j).LRU) $\rightarrow$ C(Y-block16+i)30,35}
\indcs
\innaf
%= NOTES:
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= The contents of the associative memory are unchanged.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= The associative memory is ignored (forced to {``}no match'') during address
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= preparation.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= See Section 3 and Section 5 for description and use of the SDWAM.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= Attempted execution in normal or BAR modes causes an illegal procedure
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= fault.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= Attempted repetition with the rpt, rpd, or rpl instructions causes an
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= illegal procedure fault.
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= ssdr
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Store Segment Descriptor Registers
%= \end{flushleft}
%= 
%= 
%= 
%= 254 (1)

\inbif

\insum {DPS/L68 processors:}
\inull {\hspace{1em}For i = 0, 1, ..., 15}
\inull {\hspace{2em}Y-pair = Y-block32 + 2i}
\inull {\hspace{2em}C(SDWAM(i).ADDR) $\rightarrow$ C(Y-pair)0,23}
\inull {\hspace{2em}C(SDWAM(i).R1, R2, R3) $\rightarrow$ C(Y-pair)24,32}
\inull {\hspace{2em}0000 $\rightarrow$ C(Y-pair)33,36}
\inull {\hspace{2em}C(SDWAM(i).BOUND) $\rightarrow$ C(Y-pair)37,50}
\inull {\hspace{2em}C(SDWAM(i).R, E, P, U, G, C) $\rightarrow$ C(Y-pair)51,57}
\inull {\hspace{2em}C(SDWAM(i).CL) $\rightarrow$ C(Y-pair)58,71}
\inull {DPS 8M processors:}
\inull {\hspace{1em}This instruction stores 16 double-words from the selected level (j) of}
\inull {\hspace{1em}the directory of the Segment Descriptor Word associative memory.}
\inull {\hspace{1em}There are four levels.}
\inull {\hspace{1em}Level j is selected by C(TPR.CA)11,12}
\inull {\hspace{1em}For i = 0, 1, ..., 15}
\inull {\hspace{2em}C(SDWAM(i,j).ADDR) $\rightarrow$ (Y-block32+i)0,23}
\inull {\hspace{2em}C(SDWAM(i,j).R1,R2,R3) $\rightarrow$ C(Y-block32+i)24,32}
\inull {\hspace{2em}000 $\rightarrow$ C(Y-block32+i)33,35}
\inull {\hspace{2em}0 $\rightarrow$ C(Y-block32+i)36}
\inull {\hspace{2em}C(SDWAM(i,j).BOUND) $\rightarrow$ C(Y-block32+i)37,50}
\inull {\hspace{2em}C(SDWAM(i,j).R,E,W,P,U,G,C) $\rightarrow$ C(Y-block32+i)51,57}
\inull {\hspace{2em}C(SDWAM(i,j.).CALL LIMIT) $\rightarrow$ C(Y-block32+i)58,71}
\indcs
\innaf
%= NOTES:
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= The contents of the associative memory are unchanged.
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= \newpage
%= The associative memory is ignored (forced to {``}no match'') during address
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= preparation.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= See Section 3 and Section 5 for description and use of the SDWAM.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= Attempted execution in normal or BAR modes causes an illegal procedure
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= fault.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= Attempted repetition with the rpt, rpd, or rpl instructions causes an
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= illegal procedure fault.
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= \newpage

\subsubsection{Privileged - Clear Associative Memory}

%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= camp
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Clear Associative Memory Pages
%= \end{flushleft}
%= 
%= 
%= 
%= 532 (1)

\inbif
\insum {DPS/L68 processors:}
\inull {\hspace{1em}For i = 0, 1, ..., 15}
\inull {\hspace{2em}0 $\rightarrow$ C(PTWAM(i).F)}
\inull {\hspace{2em}(i) $\rightarrow$ C(PTWAM(i).USE)}
\inull {DPS 8M processors:}
\inull {\hspace{1em}If the associative memory is enabled}
\inull {\hspace{2em}0 $\rightarrow$ C(PTWAM.F)}
\inull {\hspace{2em}C(PTWAM.LRU) is initialized for all PTWAM registers}
\indcs
\innaf
%= NOTES:
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= DPS/L68 processors:
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= The full/empty bit of each PTWAM register is set to 0, and the usage
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= counters (PTWAM.USE) are set to their pre-assigned values of 0
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= through 15. The remainder of C PTWAM(i)) is unchanged .
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= The execution of this instruction enables the PTWAM if it is disabled
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= and C(TPR.CA)16,17 = 10.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= The execution of this instruction disables the PTWAM if C(TPR.CA)16,17
%= \end{flushleft}
%= 
%= = 01.
%= 
%= \begin{flushleft}
%= If C(TPR.CA)15 = 1, a selective clear of cache is executed. Any cache
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= block for which the upper 14 bits of the directory entry equal
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= C(PTWAM(i).ADDR)0,13 will have its full/empty bit set to empty.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= DPS 8M processors:
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= The full/empty bit of cache PTWAM register is set to zero and the LRU
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= counters are initialized. The remainder of the contents of the registers
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= are unchanged. If the associative memory is disabled, F and LRU are
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= unchanged.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= C(TPR.CA)16,17 control disabling or enabling the associative memory.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= This may be done to either or both halves.
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= C(TPR.CA)13,14
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Selection
%= \end{flushleft}
%= 
%= 
%= 
%= 00
%= 
%= 
%= 
%= \begin{flushleft}
%= both halves
%= \end{flushleft}
%= 
%= 
%= 
%= 01
%= 
%= 
%= 
%= \begin{flushleft}
%= lower half, levels C \& D
%= \end{flushleft}
%= 
%= 
%= 
%= 10
%= 
%= 
%= 
%= \begin{flushleft}
%= upper half, levels A \& B
%= \end{flushleft}
%= 
%= 
%= 
%= 11
%= 
%= 
%= 
%= \begin{flushleft}
%= both halves
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= The selected portion of the associative memory is
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= -disabled if C(TPR.CA)16,17 = 01
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= -enabled if C(TPR.CA)16,17 = 10
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= \newpage
%= If the associative memory is disabled, the execution of two instructions
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= are required to first enable and then clear it.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= C(TPR.CA)15 has no effect on the DPS 8M cache. On previous Multics
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= processors this bit enabled selective cache clearing (see above).
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= All processors:
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= See Section 3 and Section 5 for description and use of the PTWAM.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= Attempted execution in normal or BAR modes causes an illegal
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= procedure fault.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= Attempted repetition with the rpt, rpd, or rpl instructions causes an
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= illegal procedure fault.
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= cams
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Clear Associative Memory Segments
%= \end{flushleft}
%= 
%= 
%= 
%= 532 (0)

\inbif
\insum {DPS/L68 processors:}
\inull {\hspace{1em}For i = 0, 1, ..., 15}
\inull {\hspace{2em}0 $\rightarrow$ C(SDWAM(i).F)}
\inull {\hspace{2em}(i) $\rightarrow$ C(SDWAM(i).USE)}
\inull {DPS 8M processors:}
\inull {\hspace{1em}If the associative memory is enabled}
\inull {\hspace{2em}0 $\rightarrow$ C(SDWAM.F)}
\inull {\hspace{2em}C(SDWAM.LRU) is initialized for all PTWAM registers}
\indcs
\innaf
%= NOTES:
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= DPS/L68 processors:
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= The full/empty bit of each SDWAM register is set to zero, and the usage
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= counters (SDWAM.USE) are initialized to their pre-assigned values of 0
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= through 15. The remainder of C(SDWAM(i)) are unchanged.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= The execution of this instruction enables the SDWAM if it is disabled
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= and C(TPR.CA)16,17 = 10.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= The execution of this instruction disables the SDWAM if C(TPR.CA)16,17
%= \end{flushleft}
%= 
%= = 01.
%= 
%= \begin{flushleft}
%= The execution of this instruction sets the full/empty bits of all cache
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= blocks to empty if C(TPR.CA)15 = 1.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= DPS 8M processors:
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= The full/empty bit of each SDWAM register is set to zero and the LRU
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= counters are initialized. The remainder of the contents of the registers
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= are unchanged. If the associative memory is disabled, F and LRU are
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= unchanged.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= C(TPR.CA)16,17 control disabling or enabling the associative memory.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= This may be done to either or both halves.
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= C(TPR.CA)13,14
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Selection
%= \end{flushleft}
%= 
%= 
%= 
%= 00
%= 
%= 
%= 
%= \begin{flushleft}
%= Both halves
%= \end{flushleft}
%= 
%= 
%= 
%= 01
%= 
%= 
%= 
%= \begin{flushleft}
%= Lower half levels C \& D
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= \newpage
%= C(TPR.CA)13,14
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Selection
%= \end{flushleft}
%= 
%= 
%= 
%= 10
%= 
%= 
%= 
%= \begin{flushleft}
%= Upper half, levels A \& B
%= \end{flushleft}
%= 
%= 
%= 
%= 11
%= 
%= 
%= 
%= \begin{flushleft}
%= Both halves
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= The selected portion of the associative memory is
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= -disabled if C(TPR.CA)16,17 = 01
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= -enabled if C(TPR.CA)16,17 = 10
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= If the associative memory is disabled, the execution of two instructions
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= are required to first enable and then clear it.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= C(TPR.CA)15 has no effect on the DPS 8M cache. On previous Multics
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= processors this bit enabled a full cache clear (see above).
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= All processors:
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= See Section 3 and Section 5 for description and use of the SDWAM.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= Attempted execution in normal or BAR modes causes an illegal
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= procedure fault.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= Attempted repetition with the rpt, rpd, or rpl instructions causes an
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= illegal procedure fault.
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= \newpage

\subsubsection{Privileged - Configuration and Status}

%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= rmcm
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Read Memory Controller Mask Register
%= \end{flushleft}
%= 
%= 
%= 
%= 233 (0)

\inbif
\insum {For the selected system controller (see NOTES):}
\inull {\hspace{1em}If the processor has a mask register assigned, then}
\inull {\hspace{2em}C(assigned mask register) $\rightarrow$ C(AQ)}
\inull {\hspace{1em}otherwise, 00...0 $\rightarrow$ C(AQ)}
\indcs
\inina
\ininZ {AQ}
\ininN {AQ}

%= NOTES:
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= The contents of the mask register remain unchanged.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= C(TPR.CA)0,2 (C(TPR.CA)1,2 for the DPS 8M processor) specify which
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= processor port (i.e., which system controller) is used.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= Attempted execution in normal or BAR modes causes an illegal procedure
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= fault.
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= rscr
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Read System Controller Register
%= \end{flushleft}
%= 
%= 
%= 
%= 413 (0)
%= 
%= 
%= 

\inbif

\insum {
The final computed address, C(TPR.CA), is used to select a system
controller and the function to be performed as follows:}
%= 
%= 
%= 
%= \begin{flushleft}
%= Effective Address Function
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= y0000x
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= C(system controller mode register) $\rightarrow$ C(AQ)
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= y0001x
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= C(system controller configuration switches) $\rightarrow$ C(AQ)
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= y0002x
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= C(mask register assigned to port 0) $\rightarrow$ C(AQ)
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= y0012x
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= C(mask register assigned to port 1) $\rightarrow$ C(AQ)
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= y0022x
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= C(mask register assigned to port 2) $\rightarrow$ C(AQ)
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= y0032x
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= C(mask register assigned to port 3) $\rightarrow$ C(AQ)
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= y0042x
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= C(mask register assigned to port 4) $\rightarrow$ C(AQ)
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= y0052x
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= C(mask register assigned to port 5) $\rightarrow$ C(AQ)
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= y0062x
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= C(mask register assigned to port 6) $\rightarrow$ C(AQ)
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= y0072x
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= C(mask register assigned to port 7) $\rightarrow$ C(AQ)
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= y0003x
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= C(interrupt cells) $\rightarrow$ C(AQ)
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= y0004x
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= or
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= y0005x
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= C(calendar clock) $\rightarrow$ C(AQ)
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= \newpage
%= Effective Address Function
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= y0006x
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= or
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= y0007x
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= where:
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= C(store unit mode register) $\rightarrow$ C(AQ)
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= y = value of C(TPR.CA)0,2 (C(TPR.CA)1,2 for the DPS
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= 8M processor) used to select the system controller
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= x = any octal digit
%= \end{flushleft}
%= 
%= 
%= 

\indcs
\innaf
%= NOTES:
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= See Section 3 for description and use of the various registers.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= For computed addresses y0006x and y0007x, store unit selection is done
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= by the normal address decoding function of the system controller.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= Attempted execution in normal or BAR modes causes an illegal procedure
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= fault.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= Attempted repetition with the rpl instruction causes an illegal procedure
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= fault.
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= rsw
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Read Switches
%= \end{flushleft}
%= 
%= 
%= 
%= 231 (0)
%= 
%= 
%= 

\inbif
\insum {
The final computed address, C(TPR.CA), is used to select certain processor
switches whose settings are read into the A-register.}
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= The switches selected are as follows:
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Effective Address Function
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= xxxxx0
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= C(data switches) $\rightarrow$ C(A)
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= xxxxxl
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= C(configuration switches for ports A, B, C, D)
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= $\rightarrow$ C(A)
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= xxxxx2
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= DPS/L68 processors:
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= 00...0 $\rightarrow$ C(A)0,5
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= C(fault base switches) $\rightarrow$ C(A)6,12
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= 00...0 $\rightarrow$ C(A)13,22
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= C(processor ID) $\rightarrow$ C(A )23,33
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= C(processor number switches) $\rightarrow$ C(A)34,35
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= DPS 8M processors:
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= C(Port interface, Ports A-D) $\rightarrow$ C(A)0,3
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= 01 $\rightarrow$ C(A)4,5
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= C(Fault base switches) $\rightarrow$ C(A)6,12
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= 1 $\rightarrow$ C(A)13
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= 0000 $\rightarrow$ C(A)14,17
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= 111 $\rightarrow$ C(A)18,20
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= 00 $\rightarrow$ C(A)21,22
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= \newpage
%= Effective Address Function
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= 1 $\rightarrow$ C(A)23
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= C(Processor mode sw) $\rightarrow$ C(A)24
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= 1 $\rightarrow$ C(A)25
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= 000 $\rightarrow$ C(A)26,28
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= C(Processor speed) $\rightarrow$ C (A)29,32
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= C(Processor number switches) $\rightarrow$ C(A)33,35
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= xxxxx3
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= C(configuration switches for ports E, F, G, H)
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= $\rightarrow$ C(A) (DPS/L68 processors only)
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= xxxxx4
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= 00...0 $\rightarrow$ C(A)0,12
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= C(port interlace and size switches) $\rightarrow$ C(A)13,28
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= 00...0 $\rightarrow$ C(A)29,35
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= (DPS/L68 processors only)
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= where:
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= x = any octal digit
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= MODIFICATIONS:
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= All, but none affect instruction execution.
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}

\inina
\ininZ {A}
%= 
%= 
%= 
%= \begin{flushleft}
\ininN {A}
%= 
%= 
%= 
%= \begin{flushleft}
%= NOTES:
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= See Section 3 for description and use of the various registers.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= Attempted execution in normal or BAR modes causes an illegal procedure
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= fault.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= Attempted repetition with the rpt, rpd, or rpl instructions causes an
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= illegal procedure fault.
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= \newpage

\subsubsection{Privileged -- System Control}

%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= cioc
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Connect I/O Channel
%= \end{flushleft}
%= 
%= 
%= 
%= 015 (0)
%= 
%= 
%= 

\inbif
\insum {
The system controller addressed by Y (i.e., contains the word at Y) sends a
connect signal to the port specified by C(Y)33,35.}
\indcs
\innaf
%= NOTES:
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Attempted execution in normal or BAR modes causes an illegal procedure
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= fault.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= Attempted repetition with the rpt, rpd, or rpl instructions causes an
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= illegal procedure fault.
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= smcm
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Set Memory Controller Mask Register
%= \end{flushleft}
%= 
%= 
%= 
%= 553 (0)

\inbif

\insum {For the selected system controller:}
\inull {\hspace{1em}If the processor has a mask register assigned, then}
\inull {\hspace{2em}C(AQ) $\rightarrow$ C(assigned mask register)}
\inull {\hspace{1em}otherwise a store fault (not control) occurs.}
\indcs
\innaf
%= NOTES:
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= C(TPR.CA)0,2 (C(TPR.CA)1,2 on the DPS 8M processor) specify which
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= processor port (i.e., which system controller) is used.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= Attempted execution in normal or BAR modes causes an illegal procedure
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= fault.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= Attempted repetition with the rpl instruction causes an illegal procedure
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= fault.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= If the SCU is a 4MW type SCU, the illegal action code 1000 (Not Control
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= Port) is not used.
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= smic
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Set Memory Controller interrupt Cells
%= \end{flushleft}
%= 
%= 
%= 
%= 451 (0)

\inbif

\insum {For i = 0, 1, ..., 15 and C(A)35 = 0:}
\inull {\hspace{1em}if C(A)i = 1, then set interrupt cell i ON}
\inull {\hspace{1em}For i = 0, 1, ..., 15 and C(A)35 = 1:}
\inull {\hspace{1em}if C(A)i = 1, then set interrupt cell 16+i ON}
\indcs
\innaf
%= NOTES:
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= C(TPR.CA)0,2 (C(TPR.CA)1,2 on a DPS 8M processor) specify which
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= processor port (i.e., which system controller) is used.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= If the processor has no assigned mask register in the selected system
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= controller, a store fault (not control) occurs.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= If the SCU is a 4MW type SCU, the illegal action code 1000 (Not Control
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= Port) is not used.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= Attempted execution in normal or BAR modes causes an illegal procedure
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= fault.
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= sscr
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Set System Controller Register
%= \end{flushleft}
%= 
%= 
%= 
%= 057 (0)
%= 
%= 
%= 

\inbif
\insum {
The final computed address, C(TPR.CA), is used to select a system
controller and the function to be performed as follows:}

%= \begin{flushleft}
%= Effective Address Function
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= y0000x
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= C(AQ) $\rightarrow$ C(system controller mode register)
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= y0001x
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= C(AQ) $\rightarrow$ system controller configuration register
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= (4WM SCU only)
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= y0002x
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= C(AQ) $\rightarrow$C(mask register assigned to port 0)
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= y0012x
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= C(AQ) $\rightarrow$C(mask register assigned to port 1)
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= y0022x
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= C(AQ) $\rightarrow$C(mask register assigned to port 2)
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= y0032x
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= C(AQ) $\rightarrow$C(mask register assigned to port 3)
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= y0042x
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= C(AQ) $\rightarrow$C(mask register assigned to port 4)
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= y0052x
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= C(AQ) $\rightarrow$C(mask register assigned to port 5)
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= y0062x
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= C(AQ) $\rightarrow$C(mask register assigned to port 6)
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= y0072x
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= C(AQ) $\rightarrow$C(mask register assigned to port 7)
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= y0003x
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= C(AQ)0,15 $\rightarrow$ C(interrupt cells 0-15)
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= C(AQ)36,51 $\rightarrow$ C(interrupt cells 16-31)
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= y0004x
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= or
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= y0005x
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= C(AQ) $\rightarrow$ (calendar clock)
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= (for 4MW SCU only)
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= y0006x
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= or
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= y0007x
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= C(AQ) $\rightarrow$ C(store unit mode register)
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= where:
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= y = value of C(TPR.CA)0,2 (C(TPR.CA)1,2 on the DPS
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= 8M processor) used to select the system controller
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= x = any octal digit
%= \end{flushleft}
%= 
%= 
%= 

\indcs

%= INDICATORS:
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= None affected
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= NOTES:
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= If the processor does not have a mask register assigned in the selected
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= system controller, a store fault (not control) occurs.
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= \newpage
%= For computed addresses y0006x and y0007x, store unit selection is done
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= by the normal address decoding function of the system controller.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= See Section 3 for description and use of the various registers.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= Attempted execution in normal or BAR modes causes an illegal procedure
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= fault.
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= \newpage

\subsubsection{Privileged - Miscellaneous}

%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= absa
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Absolute Address to A-Register
%= \end{flushleft}
%= 
%= 
%= 
%= 212 (0)

\inbif
\insum {Final main memory address, Y $\rightarrow$ C(A)0,23}
\inull {00...0 $\rightarrow$ C(A)24,35}
\indcs
\inina
\ininZ {A}
\ininN {A}
%= NOTES:
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= If the absa instruction is executed in absolute mode, C(A) will be
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= undefined.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= Attempted execution in normal or BAR modes causes an illegal procedure
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= fault.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= Attempted repetition with the rpt, rpd, or rpl instructions causes an
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= illegal procedure fault.
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= dis
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Delay Until Interrupt Signal
%= \end{flushleft}
%= 
%= 
%= 
%= 616 (0)
%= 
%= 
%= 

\inbif

\insum {
No operation takes place, and the processor does not continue with the
next instruction; it waits for a external interrupt signal.}
\inabn
\innaf
%= NOTES:
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Attempted execution in normal or BAR modes causes an illegal procedure
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= fault.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= Attempted repetition with the rpt, rpd, or rpl instructions causes an
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= illegal procedure fault.
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= \newpage

\subsection{EXTENDED INSTRUCTION SET (EIS)}

%= \end{flushleft}
%= 
%= \begin{flushleft}

\subsubsection{EIS - Address Register Load}

%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= aarn
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Alphanumeric Descriptor to Address Register n
%= \end{flushleft}
%= 
%= 
%= 
%= 56n (1)

\inbif
\insum {For n = 0, 1, ..., or 7 as determined by operation code}
\inull {\hspace{1em}C(Y)0,17 $\rightarrow$ C(ARn.WORDNO)}
\inull {\hspace{1em}If C(Y)21,22 = 00 (TA code = 0), then}
\inull {\hspace{2em}C(Y)18,19 $\rightarrow$ C(ARn.CHAR)}
\inull {\hspace{2em}0000 $\rightarrow$ C(ARn.BITNO)}
\inull {\hspace{1em}If C(Y)21,22 = 0l (TA code = 1), then}
\inull {\hspace{2em}(6 * C(Y)18,20) / 9 $\rightarrow$ C(ARn.CHAR)}
\inull {\hspace{2em}(6 * C(Y)18,20)mod9 $\rightarrow$ C(ARn.BITNO)}
\inull {\hspace{1em}If C(Y)21,22 = 10 (TA code = 2), then}
\inull {\hspace{2em}C(Y)18,20 / 2 $\rightarrow$ C(ARn.CHAR)}
\inull {\hspace{2em}4 * (C(Y)18,20)mod2 + 1 $\rightarrow$ C(ARn.BITNO)}
\indcs
\innaf
%= NOTES:
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= An alphanumeric descriptor is fetched from Y and C(Y)21,22 (TA field) is
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= examined to determine the data type described.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= If TA = 0 (9-bit data), then C(Y) 18,19 goes to C(ARn.CHAR) and zeros fill
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= C(ARn.BITNO).
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= If TA = 1 (6-bit data) or TA = 2 (4-bit data), C(Y) 18,20 is appropriately
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= translated into an equivalent character and bit position that goes to
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= C(ARn.CHAR) and C(ARn.BITNO) .
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= If C(Y)21,22 = 11 (TA code = 3) an illegal procedure fault occurs.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= If C(Y)23 = 1 an illegal procedure fault occurs.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= If C (Y)21,22 = 00 (TA code = 0) and C(Y)20 = 1 an illegal procedure fault
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= occurs.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= If C(Y)21,22 = 01 (TA code = 1) and C(Y)18,20 = 110 or 111 an illegal
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= procedure fault occurs.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= Attempted repetition with the rpt, rpd, or rpl instructions causes an
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= illegal procedure fault.
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= larn
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= FORMAT:
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Load Address Register n
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= EIS single-word instruction format (see Figure 4-1).
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= 76n (1)
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= \newpage
\insum {For n = 0, 1, ..., or 7 as determined by operation code}
\inull {\hspace{1em}C(Y)0,23 $\rightarrow$ C(ARn)}
\indcs
\innaf
%= NOTES:
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Attempted repetition with the rpt, rpd, or rpl instructions causes an
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= illegal procedure fault.
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= lareg
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Load Address Registers
%= \end{flushleft}
%= 
%= 
%= 
%= 463 (1)

\infmt {EIS single-word instruction format (see Figure \ref{f4.1}).}
\insum {For i = 0, 1, ..., 7}
\inull {\hspace{1em}C(Y-block8+i)0,23 $\rightarrow$ C(ARi)}
\indcs
\innaf
%= NOTES:
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Attempted repetition with the rpt, rpd, or rpl instructions causes an
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= illegal procedure fault.
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= lpl
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Load Pointers and Lengths
%= \end{flushleft}
%= 
%= 
%= 467 (1)
 
\infmt {EIS single-word instruction format (see Figure \ref{f4.1}).}
\insum {C(Y-block8) $\rightarrow$ C(decimal unit data)}
\indcs
\innaf
%= NOTES:
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= See Section 3 for description and use of decimal unit data .
%= \end{flushleft}
%= 
%= 
%= 
%= 
%= 
%= 
%= \begin{flushleft}
%= Attempted repetition with the rpt, rpd, or rpl instructions causes an
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= illegal procedure fault.
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= narn
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Numeric Descriptor to Address Register n
%= \end{flushleft}
%= 
%= 
%= 
%= 66n (1)

\infmt {EIS single-word instruction format (see Figure \ref{f4.1}).}
 
\insum {For n = 0, 1, ..., or 7 as determined by operation code}
\inull {\hspace{1em}C(Y)0,17 $\rightarrow$ C(ARn.WORDNO)}
\inull {\hspace{1em}If C(Y)21 = 0 (TN code = 0), then}
\inull {\hspace{2em}C(Y)18,20 $\rightarrow$ C(ARn.CHAR)}
\inull {\hspace{2em}0000 $\rightarrow$ C(ARn.BITNO)}
\inull {\hspace{1em}If C(Y)21 = 1 (TN code = 1), then}
\inull {\hspace{2em}(C(Y)18,20) / 2 $\rightarrow$ C(ARn.CHAR)}
\inull {\hspace{2em}4 * (C(Y)18,20)mod2 + 1 $\rightarrow$ C(ARn.BITNO)}
\indcs
\innaf
%= NOTES:
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= A numeric descriptor is fetched from Y and C(Y)21 (TN bit) is examined.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= If TN = 0 (9-bit data), then C(Y)18,19 goes to C(ARn.CHAR) and zeros fill
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= C(ARn.BITNO).
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= If TN = 1 (4-bit data), C(Y) is appropriately translated to an equivalent
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= character and bit position that goes to C(ARn.CHAR) and C(ARn.BITNO).
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= If C(Y)21 = 0 (TN code = 0) and C(Y)20 = 1 an illegal procedure fault
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= occurs.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= Attempted repetition with the rpt, rpd, or rpl instructions causes an
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= illegal procedure fault.
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= \newpage

\subsubsection{EIS - Address Register Store}

%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= aran
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Address Register n to Alphanumeric Descriptor
%= \end{flushleft}
%= 
%= 
%= 
%= 54n (1)

\infmt {EIS single-word instruction format (see Figure \ref{f4.1}).}

\insum {For n = 0, 1, ..., or 7 as determined by operation code}
\inull {\hspace{1em}C(ARn.WORDNO) $\rightarrow$ C(Y)0,17}
\inull {\hspace{1em}If C(Y)21,22 = 00 (TA code = 0), then}
\inull {\hspace{2em}C(ARn.CHAR) $\rightarrow$ C(Y)18,19}
\inull {\hspace{2em}0 $\rightarrow$ C(Y)20}
\inull {\hspace{1em}If C(Y)21,22 = 0l (TA code = 1), then}
\inull {\hspace{2em}(9 * C(ARn.CHAR) + C(ARn.BITNO)) / 6 $\rightarrow$ C(Y)18,20}
\inull {\hspace{1em}If C(Y)21,22 = 10 (TA code = 2), then}
\inull {\hspace{2em}(9 * C(ARn.CHAR) + C(ARn.BITNO) -- 1) / 4 $\rightarrow$ C(Y)18,20}
\indcs
\innaf
%= NOTES:
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= This instruction is the inverse of the aarn instruction.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= The alphanumeric descriptor is fetched from Y and C(Y)21,22 (TA field) is
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= examined to determine the data type described.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= If TA = 0 (9-bit data), C(ARn.CHAR) goes to C(Y)18,19.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= If TA = 1 (6-bit data) or TA = 2 (4-bit data), C(ARn.CHAR) and
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= C(ARn.BITNO) are translated to an equivalent character position that goes
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= to C(Y)18,20.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= If C(Y)21,22 = 11 (TA code = 3) or C(Y)23 = 1 (unused bit), an illegal
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= procedure fault occurs.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= Attempted repetition with the rpt, rpd, or rpl instructions causes an
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= illegal procedure fault.
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= arnn
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Address Register n to Numeric Descriptor
%= \end{flushleft}
%= 
%= 
%= 
%= 64n (1)

\infmt {EIS single-word instruction format (see Figure \ref{f4.1}).}

\insum {For n = 0, 1, ..., or 7 as determined by operation code}
\inull {\hspace{1em}C(ARn.WORDNO) $\rightarrow$ C(Y)0,17}
\inull {\hspace{1em}If C(Y)21 = 0 (TN code = 0), then}
\inull {\hspace{2em}C(ARn.CHAR) $\rightarrow$ C(Y)18,19}
\inull {\hspace{2em}0 $\rightarrow$ C(Y)20}
\inull {\hspace{1em}If C(Y)21 = 1 (TN code = 1), then}
\inull {\hspace{2em}(9 * C(ARn.CHAR) + C(ARn.BITNO) -- 1) / 4 $\rightarrow$ C(Y)18,20}
\indcs
\innaf
%= NOTES:
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= This instruction is the inverse of the narn instruction.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= The numeric descriptor is fetched from Y and C(Y)21 (TN bit) is examined.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= If TN = 0 (9-bit data), then C(ARn.CHAR) goes to C(Y)18,19.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= If TN = 1 (4-bit data), then C(ARn.CHAR) and C(ARn.BITNO) are
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= translated to an equivalent character position that goes to C(Y)18,20.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= Attempted repetition with the rpt, rpd, or rpl instructions causes an
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= illegal procedure fault.
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= sarn
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Store Address Register n
%= \end{flushleft}
%= 
%= 
%= 
%= 74n (1)

\infmt {EIS single-word instruction format (see Figure \ref{f4.1}).}
\insum {For n = 0, 1, ..., or 7 as determined by operation code}
\inull {\hspace{1em}C(ARn) $\rightarrow$ C(Y)0,23}
\inull {\hspace{1em}C(Y)24,35 $\rightarrow$ unchanged}
\indcs
\innaf
%= NOTES:
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Attempted repetition with the rpt, rpd, or rpl instructions causes an
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= illegal procedure fault.
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= sareg
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Store Address Registers
%= \end{flushleft}
%= 
%= 
%= 
%= 443 (1)

\infmt {EIS single-word instruction format (see Figure \ref{f4.1}).}

\insum {For i = 0, 1, ..., 7}
\inull {\hspace{1em}C(ARi) $\rightarrow$ C(Y-block8+i)0,23}
\inull {\hspace{1em}00...0 $\rightarrow$ C(Y-block8+i)24,35}
\indcs
\innaf
%= NOTES:
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Attempted repetition with the rpt, rpd, or rpl instructions causes an
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= illegal procedure fault.
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= spl
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Store Pointers and Lengths
%= \end{flushleft}
%= 
%= 
%= 

\infmt {EIS single-word instruction format (see Figure \ref{f4.1}).}
\insum {C(decimal unit data) $\rightarrow$ C(Y-block8)}
\indcs
\innaf
%= NOTES:
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= See Section 3 for description and use of decimal unit data .
%= \end{flushleft}
%= 
%= 
%= 
%= 447 (1)
%= 
%= 
%= 
%= \begin{flushleft}
%= \newpage
%= Attempted repetition with the rpt, rpd, or rpl instructions causes an
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= illegal procedure fault.
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= \newpage

\subsubsection{EIS - Address Register Special Arithmetic}

%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= a4bd
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Add 4-bit Displacement to Address Register
%= \end{flushleft}
%= 
%= 
%= 
%= 502 (1)
%= 
%= 
%= 
%= \begin{flushleft}
%= FORMAT:
%= \end{flushleft}
%= 
%= 0
%= 
%= 0
%= 
%= 
%= 
%= 0 0
%= 
%= 2 3
%= 
%= 
%= 
%= 1 1
%= 
%= 7 8
%= 
%= 
%= 
%= \begin{flushleft}
%= ARn
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= ADDRESS
%= \end{flushleft}
%= 
%= 3
%= 
%= 
%= 
%= 2 2 2 3 3 3
%= 
%= 7 8 9 0 1 2
%= 
%= \begin{flushleft}
%= OPCODE
%= \end{flushleft}
%= 
%= 
%= 
%= 15
%= 
%= 
%= 
%= \begin{flushleft}
%= I A 0 0
%= \end{flushleft}
%= 
%= 10 1 1
%= 
%= 
%= 
%= 3
%= 
%= 5
%= 
%= \begin{flushleft}
%= REG
%= \end{flushleft}
%= 
%= 
%= 
%= 2
%= 
%= 
%= 
%= 4
%= 
%= 
%= 
%= \begin{flushleft}
%= Figure 4-12. EIS Address Register Special Arithmetic Instruction Format
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= ARn
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Number of address register selected
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= ADDRESS
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Literal word displacement value
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= OPCODE
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Instruction operation code
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= I
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Interrupt inhibit bit
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= A
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Use address register contents flag
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= REG
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Any register modification except du, dl, ic
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= ALM Coding Format:
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= For A = 0,
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= a4bdx
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= PRn$|$offset,modifier
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= For A = 1,
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= a4bd
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= PRn$|$offset,modifier
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
\insum {If A = 0, then}
\inull {\hspace{1em}ADDRESS + C(REG) / 4 $\rightarrow$ C(ARn.WORDNO)}
\inull {\hspace{1em}C(REG)mod4 $\rightarrow$ C(ARn.CHAR)}
\inull {\hspace{1em}4 * C(REG)mod2 + 1 $\rightarrow$ C(ARn.BITNO)}
\inull {If A = 1, then}
\inull {\hspace{1em}C(ARn.WORDNO) + ADDRESS + (9 * C(ARn.CHAR)}
\inull {\hspace{2em}+ 4 * C(REG) + C(ARn.BITNO)) / 36 $\rightarrow$ C(ARn.WORDNO)}
\inull {\hspace{1em}((9 * C(ARn.CHAR) + 4 * C(REG) +}
\inull {\hspace{2em}C(ARn.BITNO))mod36) / 9 $\rightarrow$ C(ARn.CHAR)}
\inull {\hspace{1em}4 * (C(ARn.CHAR) + 2 * C(REG) +}
\inull {\hspace{2em}C(ARn.BITNO) / 4)mod2 + 1 $\rightarrow$ C(ARn.BITNO)}

%= MODIFICATIONS:
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= None except au, qu, al, ql, xn
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
\innaf
%= NOTES:
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= The steps described in SUMMARY define special 4-bit addition arithmetic
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= for
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= ADDRESS,
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= C(REG),
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= C(ARn.WORDNO),
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= C(ARn.CHAR),
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= and
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= C(ARn.BITNO).
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= \newpage
%= C(REG) is always treated as a count of 4-bit characters.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= The use of an address register is inherent; the value of bit 29 in the
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= instruction word affects operand evaluation but not register selection.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= Attempted repetition with the rpt, rpd, or rpl instructions causes an
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= illegal procedure fault.
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= a6bd
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Add 6-bit Displacement to Address Register
%= \end{flushleft}
%= 
%= 
%= 

\infmt {EIS address register special arithmetic instruction format (see Figure \ref{f4.12}).}

%= 
%= 
%= \begin{flushleft}
%= ALM Coding Format:
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= For A = 0,
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= a6bdx
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= PRn$|$offset,modifier
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= For A = 1,
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= a6bd
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= PRn$|$offset,modifier
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
\insum {If A = 0, then}
\inull {\hspace{1em}ADDRESS + C(REG) / 6 $\rightarrow$ C(ARn.WORDNO)}
\inull {\hspace{1em}((6 * C(REG))mod36) / 9 $\rightarrow$ C(ARn.CHAR)}
\inull {\hspace{1em}(6 * C(REG))mod9 $\rightarrow$ C(ARn.BITNO)}
\inull {f A = 1, then}
\inull {\hspace{1em}C(ARn.WORDNO) + ADDRESS + (9 * C(ARn.CHAR) +}
\inull {\hspace{2em}6 * C(REG) + C(ARn.BITNO)) / 36 $\rightarrow$ C(ARn.WORDNO)}
\inull {\hspace{1em}((9 * C(ARn.CHAR) + 6 * C(REG) +}
\inull {\hspace{2em}C(ARn.BITNO))mod36) / 9 $\rightarrow$ C(ARn.CHAR)}
\inull {\hspace{1em}(9 * C(ARn.CHAR) + 6 * C(REG) +}
\inull {\hspace{2em}C(ARn.BITNO))mod9 $\rightarrow$ C(ARn.BITNO)}

%= 
%= \begin{flushleft}
%= MODIFICATIONS:
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= None except au, qu, al, ql, xn
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
\innaf
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= NOTES:
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= The steps described in SUMMARY define special 6-bit addition arithmetic
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= for
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= ADDRESS,
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= C(REG),
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= C(ARn.WORDNO),
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= C(ARn.CHAR),
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= and
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= C(ARn.BITNO).
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= C(REG) is always treated as a count of 6-bit characters.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= The use of an address register is inherent; the value of bit 29 in the
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= instruction word affects address preparation but not register selection.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= Attempted repetition with the rpt, rpd, or rpl instructions causes an
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= illegal procedure fault.
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= a9bd
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= Add 9-bit Displacement to Address Register
%= \end{flushleft}
%= 
%= 
%= 
%= 500 (1)
%= 
%= 
%= 
%= \begin{flushleft}

\infmt {EIS address register special arithmetic instruction format (see Figure \ref{f4.12}).}

%= ALM Coding Format:
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= For A = 0,
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= a9bdx
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= PRn$|$offset,modifier
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= For A = 1,
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= a9bd
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= PRn$|$offset,modifier
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
\insum {If A = 0, then}
\inull {\hspace{1em}ADDRESS + C(REG) / 4 $\rightarrow$ C(ARn.WORDNO)}
\inull {\hspace{1em}C(REG)mod4 $\rightarrow$ C(ARn.CHAR)}
\inull {If A = 1, then}
\inull {\hspace{1em}C(ARn.WORDNO) + ADDRESS +}
\inull {\hspace{2em}(C(REG) + C(ARn.CHAR)) / 4 $\rightarrow$ C(ARn.WORDNO)}
\inull {\hspace{1em}(C(ARn.CHAR) + C(REG))mod4 $\rightarrow$ C(ARn.CHAR)}
\inull {0000 $\rightarrow$ C(ARn.BITNO)}

%= \begin{flushleft}
%= MODIFICATIONS:
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= None except au, qu, al, ql, xn
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
\innaf
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= NOTES:
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= The steps described in SUMMARY define special 9-bit addition arithmetic
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= for ADDRESS, C(REG), C(ARn.WORDNO), and C(ARn.CHAR).
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= C(REG) is always treated as a count of 9-bit bytes.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= The use of an address register is inherent; the value of bit 29 in the
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= instruction word affects operand evaluation but not register selection.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= Attempted repetition with the rpt, rpd, or rpl instructions causes an
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= illegal procedure fault.
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= abd
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Add Bit Displacement to Address Register
%= \end{flushleft}
%= 
%= 
%= 

\infmt {EIS address register special arithmetic instruction format (see Figure \ref{f4.12}).}

%= ALM Coding Format:
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= For A = 0,
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= abdx
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= PRn$|$offset,modifier
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= For A = 1,
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= abd
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= PRn$|$offset,modifier
%= \end{flushleft}
%= 
%= 
%= 503 (1)
 
\insum {If A = 0, then}
\inull {\hspace{1em}ADDRESS + C(REG) / 36 $\rightarrow$ C(ARn.WORDNO)}
\inull {\hspace{1em}(C(REG)mod36) / 9 $\rightarrow$ C(ARn.CHAR)}
\inull {\hspace{1em}C(REG)mod9 $\rightarrow$ C(ARn.BITNO)}
\inull {If A = 1, then}
\inull {\hspace{1em}C(ARn.WORDNO) + ADDRESS + (9 * C(ARn.CHAR)}
\inull {\hspace{2em}+ 36 * C(REG) + C(ARn.BITNO)) / 36 $\rightarrow$ C(ARn.WORDNO)}
\inull {\hspace{1em}((9 * C(ARn.CHAR) + 36 * C(REG) +}
\inull {\hspace{2em}C(ARn.BITNO))mod36) / 9 $\rightarrow$ C(ARn.CHAR)}
\inull {\hspace{1em}(9 * C(ARn.CHAR) + 36 * C(REG) +}
\inull {\hspace{2em}C(ARn.BITNO))mod9 $\rightarrow$ C(ARn.BITNO)}
%= MODIFICATIONS:
%= 
%= \begin{flushleft}
%= None except au, qu, al, ql, xn
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
\innaf
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= NOTES:
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= The steps described in SUMMARY define special bit addition arithmetic for
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= ADDRESS, C(REG), C(ARn.WORDNO), C(ARn.CHAR), and C(ARn.BITNO).
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= C(REG) is always treated as a bit count.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= The use of an address register is inherent; the value of bit 29 in the
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= instruction word affects operand evaluation but not register selection.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= Attempted repetition with the rpt, rpd, or rpl instructions causes an
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= illegal procedure fault.
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= awd
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Add Word Displacement to Address Register
%= \end{flushleft}
%= 
%= 
%= 

\infmt {EIS address register special arithmetic instruction format (see Figure \ref{f4.12}).}

%= ALM Coding Format:
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= For A = 0,
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= awdx
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= PRn$|$offset,modifier
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= For A = 1,
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= awd
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= PRn$|$offset,modifier
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
\insum {If A = 0, then}
\inull {\hspace{1em}ADDRESS + C(REG) $\rightarrow$ C(ARn.WORDNO)}
\inull {If A = 1, then}
\inull {\hspace{1em}C(ARn.WORDNO) + ADDRESS + C(REG) $\rightarrow$ C(ARn.WORDNO)}
\inull {00 $\rightarrow$ C(ARn.CHAR)}
\inull {0000 $\rightarrow$ C(ARn.BITNO)}

%= 
%= \begin{flushleft}
%= MODIFICATIONS:
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= None except au, qu, al, ql, xn
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
\innaf
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= NOTES:
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= The use of an address register is inherent; the value of bit 29 in the
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= instruction word affects operand evaluation but not register selection.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= C(REG) is always treated as a word count.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= Attempted repetition with the rpt, rpd, or rpl instructions causes an
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= illegal procedure fault.
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= \newpage
%= s4bd
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Subtract 4-bit Displacement from Address
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= Register
%= \end{flushleft}
%= 
%= 
%= 

\infmt {EIS address register special arithmetic instruction format (see Figure \ref{f4.12}).}

%= ALM Coding Format:
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= For A = 0,
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= s4bdx
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= PRn$|$offset,modifier
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= For A = 1,
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= s4bd
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= PRn$|$offset,modifier
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
\insum {If A = 0, then}
\inull {\hspace{1em}- (ADDRESS + C(REG) / Ah) $\rightarrow$ C(ARn.WORDNO)}
\inull {\hspace{1em}- C(REG)mod4 $\rightarrow$ C(ARn.CHAR)}
\inull {\hspace{1em}- 4 * C(REG)mod2 + 1 $\rightarrow$ C(ARn.BITNO)}
\inull {If A = 1, then}
\inull {\hspace{1em}C(ARn.WORDNO) - ADDRESS + (9 * C(ARn.CHAR)}
\inull {\hspace{2em}- 4 * C(REG) + C(ARn.BITNO)) / 36 $\rightarrow$ C(ARn.WORDNO)}
\inull {\hspace{1em}((9 * C(ARn.CHAR) - 4 * C(REG) +}
\inull {\hspace{2em}C(ARn.BITNO))mod36) / 9 $\rightarrow$ C(ARn.CHAR)}
\inull {\hspace{1em}4 * (C(ARn.CHAR) - 2 * C(REG) +}
\inull {\hspace{2em}C(ARn.BITNO) / 4)mod2 + 1 $\rightarrow$ C(ARn.BITNO)}
 
%= \begin{flushleft}
%= MODIFICATIONS:
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= None except au, qu, al, ql, xn
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
\innaf
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= NOTES:
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= The steps described in SUMMARY define special 4-bit subtraction
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= arithmetic for ADDRESS, C(REG), C(ARn.WORDNO), C(ARn.CHAR), and
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= C(ARn.BITNO).
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= C(REG) is always treated as a count of 4-bit characters.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= The use of an address register is inherent; the value of bit 29 in the
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= instruction word affects operand evaluation but not register selection.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= Attempted repetition with the rpt, rpd, or rpl instructions causes an
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= illegal procedure fault.
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= s6bd
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Subtract 6-bit Displacement from Address
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= Register
%= \end{flushleft}
%= 
%= 
%= 

\infmt {EIS address register special arithmetic instruction format (see Figure \ref{f4.12}).}

%= ALM Coding Format:
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= For A = 0,
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= s6bdx
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= PRn$|$offset,modifier
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= For A = 1,
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= s6bd
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= PRn$|$offset,modifier
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= \newpage
\insum {If A = 0, then}
\inull {\hspace{1em}- (ADDRESS + C(REG) / 6) $\rightarrow$ C(ARn.WORDNO)}
\inull {\hspace{1em}- ((6 * C(REG))mod36) / 9 $\rightarrow$ C(ARn.CHAR)}
\inull {\hspace{1em}- (6 * C(REG))mod9 $\rightarrow$ C(ARn.BITNO)}
\inull {If A = 1, then}
\inull {\hspace{1em}C(ARn.WORDNO) - ADDRESS + (9 * C(ARn.CHAR)}
\inull {\hspace{2em}- 6 * C(REG) + C(ARn.BITNO)) / 36 $\rightarrow$ C(ARn.WORDNO)}
\inull {\hspace{1em}((9 * C(ARn.CHAR) - 6 * C(REG) +}
\inull {\hspace{2em}C(ARn.BITNO))mod36) / 9 $\rightarrow$ C(ARn.CHAR)}
\inull {\hspace{1em}(9 * C(ARn.CHAR) - 6 * C(REG) +}
\inull {\hspace{2em}C(ARn.BITNO))mod9 $\rightarrow$ C(ARn.BITNO)}
 
%= \begin{flushleft}
%= MODIFICATIONS:
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= None except au, qu, al, ql, xn
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
\innaf
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= NOTES:
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= The steps described in SUMMARY define special 6-bit subtraction
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= arithmetic for ADDRESS, C(REG), C(ARn.WORDNO), C(ARn.CHAR), and
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= C(ARn.BITNO).
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= C(REG) is always treated as a count of 6-bit characters.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= The use of an address register is inherent; the value of bit 29 in the
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= instruction word affects operand evaluation but not register selection.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= Attempted repetition with the rpt, rpd, or rpl instructions causes an
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= illegal procedure fault.
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= s9bd
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Subtract 9-bit Displacement from Address
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= Register
%= \end{flushleft}
%= 
%= 
%= 

\infmt {EIS address register special arithmetic instruction format (see Figure \ref{f4.12}).}

%= ALM Coding Format:
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= For A = 0,
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= s9bdx
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= PRn$|$offset,modifier
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= For A = 1,
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= s9bd
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= PRn$|$offset,modifier
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
\insum {If A = 0, then}
\inull {\hspace{1em}- (ADDRESS + C(REG) / 4) $\rightarrow$ C(ARn.WORDNO)}
\inull {\hspace{1em}- C(REG)mod4 $\rightarrow$ C(ARn.CHAR)}
\inull {If A = 1, then}
\inull {\hspace{1em}C(ARn.WORDNO) - ADDRESS +}
\inull {\hspace{2em}(C(ARn.CHAR) - C(REG)) / 4 $\rightarrow$ C(ARn.WORDNO)}
\inull {\hspace{1em}(C(ARn.CHAR) - C(REG))mod4 $\rightarrow$ C(ARn.CHAR)}
\inull {0000 $\rightarrow$ C(ARn.BITNO)}
 
%= \begin{flushleft}
%= MODIFICATIONS:
%= \end{flushleft}
%= 
%= 
%= 
%= 520 (1)
%= 
%= 
%= 
%= \begin{flushleft}
%= None except au, qu, al, qu, xn
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= \newpage
\innaf
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= NOTES:
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= The steps described in SUMMARY define special 9-bit subtraction
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= arithmetic for ADDRESS, C(REG), C(ARn.WORDNO), and C(ARn.CHAR).
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= C(REG) is always treated as a count of 9-bit bytes.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= The use of an address register is inherent: the value of bit 29 in the
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= instruction word affects operand evaluation but not register selection.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= Attempted repetition with the rpt, rpd, or rpl instructions causes an
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= illegal procedure fault.
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= sbd
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Subtract Bit Displacement from Address
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= Register
%= \end{flushleft}
%= 
%= 
%= 

\infmt {EIS address register special arithmetic instruction format (see Figure \ref{f4.12}).}

%= ALM Coding Format:
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= For A = 0,
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= sbdx
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= PRn$|$offset,modifier
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= For A = 1,
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= sbd
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= PRn$|$offset,modifier
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
\insum {If A = 0, then}
\inull {\hspace{1em}- (ADDRESS + C(REG) / 36) $\rightarrow$ C(ARn.WORDNO)}
\inull {\hspace{1em}- (C(REG)mod36) / 9 $\rightarrow$ C(ARn.CHAR)}
\inull {\hspace{1em}- C(REG)mod9 $\rightarrow$ C(ARn.BITNO)}
\inull {If A = 1, then}
\inull {\hspace{1em}C(ARn.WORDNO) - ADDRESS + (9 * C(ARn.CHAR)}
\inull {\hspace{2em}- 36 * C(REG) + C(ARn.BITNO)) / 36 $\rightarrow$ C(ARn.WORDNO)}
\inull {\hspace{1em}((9 * C(ARn.CHAR) - 36 * C(REG) +}
\inull {\hspace{2em}C(ARn.BITNO))mod36) / 9 $\rightarrow$ C(ARn.CHAR)}
\inull {\hspace{1em}(9 * C(ARn.CHAR) - 36 * C(REG) +}
\inull {\hspace{2em}C(ARn.BITNO))mod9 $\rightarrow$ C(ARn.BITNO)}
 
%= \begin{flushleft}
%= MODIFICATIONS:
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= None except au, qu, al, ql, xn
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
\innaf
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= NOTES:
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= The steps described in SUMMARY define special bit subtraction arithmetic
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= for
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= ADDRESS,
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= C(REG),
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= C(ARn.WORDNO),
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= C(ARn.CHAR),
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= and
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= C(ARn.BITNO).
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= C(REG) is always treated as a bit count.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= The use of an address register is inherent; the value of bit 29 in the
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= instruction word affects operand evaluation but not register selection.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= Attempted repetition with the rpt, rpd, or rpl instructions causes an
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= illegal procedure fault.
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= \newpage
%= swd
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Subtract Word Displacement from Address
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= Register
%= \end{flushleft}
%= 
%= 
%= 

\infmt {EIS address register special arithmetic instruction format (see Figure \ref{f4.12}).}

%= ALM Coding Format:
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= For A = 0,
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= swdx
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= PRn$|$offset,modifier
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= For A = 1,
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= swd
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= PRn$|$offset,modifier
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
\insum {If A = 0, then}
\inull {\hspace{1em}- (ADDRESS + C(REG)) $\rightarrow$ C(ARn.WORDNO)}
\inull {If A = 1, then}
\inull {\hspace{1em}C(ARn.WORDNO) - (ADDRESS + C(REG)) $\rightarrow$ C(ARn.WORDNO)}
\inull {\hspace{1em}00 $\rightarrow$ C(ARn.CHAR)}
\inull {0000 $\rightarrow$ C(ARn.BITNO)}
 
%= \begin{flushleft}
%= MODIFICATIONS:
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= None except au, qu, al, ql, xn
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
\innaf
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= NOTES:
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= The use of an address register is inherent; the value of bit 29 in the
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= instruction word affects operand evaluation but not register selection.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= Attempted repetition with the rpt, rpd, or rpl instructions causes an
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= illegal procedure fault.
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= \newpage

\subsubsection{EIS - Alphanumeric Compare}

%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= cmpc
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Compare Alphanumeric Character Strings
%= \end{flushleft}
%= 
%= 
%= 
%= 106 (1)
%= 
%= 
%= 
%= \begin{flushleft}
%= FORMAT:
%= \end{flushleft}
%= 
%= 0
%= 
%= 0
%= 
%= 
%= 
%= 0 0 1 1
%= 
%= 8 9 0 1
%= 
%= \begin{flushleft}
%= FILL
%= \end{flushleft}
%= 
%= 
%= 
%= 0 0
%= 
%= 
%= 
%= 1 1
%= 
%= 7 8
%= 
%= 
%= 
%= 2 2 2 2 2
%= 
%= 0 1 2 3 4
%= 
%= 
%= 
%= \begin{flushleft}
%= MF2
%= \end{flushleft}
%= 
%= 
%= 
%= 9
%= 
%= 2
%= 
%= \begin{flushleft}
%= Y-charn1
%= \end{flushleft}
%= 
%= 
%= 
%= 106 (1)
%= 
%= 7
%= 
%= 
%= 
%= \begin{flushleft}
%= Y-charn2
%= \end{flushleft}
%= 
%= 
%= 
%= 2 2 2
%= 
%= 7 8 9
%= 
%= \begin{flushleft}
%= I
%= \end{flushleft}
%= 
%= 
%= 
%= 3
%= 
%= 5
%= 
%= \begin{flushleft}
%= MF1
%= \end{flushleft}
%= 
%= 
%= 
%= 10 1
%= 
%= 
%= 
%= 7
%= 
%= 
%= 
%= \begin{flushleft}
%= CN1
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= TA1 0
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= N1
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= CN2
%= \end{flushleft}
%= 
%= 
%= 
%= 2 1
%= 
%= 0 0 0
%= 
%= 
%= 
%= \begin{flushleft}
%= N2
%= \end{flushleft}
%= 
%= 
%= 
%= 18
%= 
%= 
%= 
%= 3
%= 
%= 
%= 
%= 3
%= 
%= 
%= 
%= \begin{flushleft}
%= Figure 4-13. Compare Alphanumeric Character Strings (cmpc)
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= EIS Multiword Instruction Format
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= FILL
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Fill character for string extension
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= MF1
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Modification field for operand descriptor 1
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= MF2
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Modification field for operand descriptor 2
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= I
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Interrupt inhibit bit
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Y-charn1
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Address of left-hand string
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= CN1
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= First character position of left-hand string
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= TA1
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Data type of left-hand string
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= N1
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Length of left-hand string
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Y-charn2
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Address of right-hand string
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= CN2
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= First character position of right-hand string
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= N2
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Length of right-hand string
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= ALM Coding Format:
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= cmpc
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= (MF1),(MF2)[,fill(octalexpression)]
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= descna
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Y-charn1[(CN1)],N1
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= n = 4, 6, or 9 (TA1 = 2, 1, or 0)
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= descna
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Y-charn2[(CN2)],N2
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= n = 4, 6, or 9 (TA2 is ignored)
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
\insum {For i = 1, 2, ..., minimum (N1,N2)}
\inull {\hspace{1em}C(Y-charn1)i-1 :: C(Y-charn2)i-1}
\inull {If N1 $<$ N2, then for i = N1+1, N1+2, ..., N2}
\inull {\hspace{1em}C(FILL) :: C(Y-charn2)i-1}
 
%= 
%= 
%= 
%= \begin{flushleft}
%= \newpage
%= If N1 $>$ N2, then for i = N2+1, N2+2, ..., N1
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= C(Y-charn1)i-1 :: C(FILL)
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= MODIFICATIONS:
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= None except au, qu, al, ql, xn for MF1 and MF2
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}

\inina

\ininz {If C(Y-char\textsl{n}1)\tsb{i-1} = C(Y-char\textsl{n}2)\tsb{i-1} for all i, then ON; otherwise, OFF}

%= 
%= 
%= 
%= \begin{flushleft}
%= Carry
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= If C(Y-charn1)i-1 $<$ C(Y-charn2)i-1 for any i, then OFF; otherwise ON
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= NOTES:
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Both strings are treated as the data type given for the left-hand string,
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= TA1. A data type given for the right-hand string, TA2, is ignored.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= Comparison is made on full 9-bit fields. If the given data type is not 9-bit
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= (TA1 $\neq$ 0), then characters from C(Y-charn1) and C(Y-charn2) are highorder zero filled. All 9 bits of C(FILL) are used.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= Instruction execution proceeds until an inequality is found or the larger
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= string length count is exhausted.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= If MFk.RL = 1, then Nk does not contain the operand length; instead, it
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= contains a register code for a register holding the operand length.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= If MFk.ID = 1, then the kth word following the instruction word does not
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= contain an operand descriptor; instead, it contains an indirect pointer to
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= the operand descriptor.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= Attempted execution with the xed instruction causes an illegal procedure
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= fault.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= Attempted repetition with the rpt, rpd, or rpl instructions causes an
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= illegal procedure fault.
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= scd
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Scan Characters Double
%= \end{flushleft}
%= 
%= 
%= 
%= 120 (1)
%= 
%= 
%= 
%= \begin{flushleft}
%= FORMAT:
%= \end{flushleft}
%= 
%= 0
%= 
%= 0
%= 
%= 
%= 
%= 1 1
%= 
%= 0 1
%= 
%= 
%= 
%= 0 0 0 0 0 0 0 0 0 0 0
%= 
%= 11
%= 
%= \begin{flushleft}
%= Y-charn1
%= \end{flushleft}
%= 
%= 
%= 
%= 1 1
%= 
%= 7 8
%= 
%= 
%= 
%= 2 2 2 2 2
%= 
%= 0 1 2 3 4
%= 
%= 
%= 
%= \begin{flushleft}
%= MF2
%= \end{flushleft}
%= 
%= 
%= 
%= 120 (1)
%= 
%= 7
%= 
%= 
%= 
%= \begin{flushleft}
%= Y-charn2
%= \end{flushleft}
%= 
%= 
%= 
%= 2 2 2 3 3 3
%= 
%= 7 8 9 0 1 2
%= 
%= \begin{flushleft}
%= I
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= MF1
%= \end{flushleft}
%= 
%= 
%= 
%= 10 1
%= 
%= 
%= 
%= 7
%= 
%= 
%= 
%= \begin{flushleft}
%= CN1
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= TA1 0
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= N1
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= CN2
%= \end{flushleft}
%= 
%= 
%= 
%= 2 1
%= 
%= 12
%= 
%= 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
%= 
%= 
%= 
%= 3
%= 
%= \begin{flushleft}
%= 0 0 0 0 0 0 0 0 0 0 0 A 0 0
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Y3
%= \end{flushleft}
%= 
%= 
%= 
%= 3
%= 
%= 5
%= 
%= 
%= 
%= 18
%= 
%= 
%= 
%= 11 1
%= 
%= 
%= 
%= 2
%= 
%= 
%= 
%= 15
%= 
%= \begin{flushleft}
%= REG
%= \end{flushleft}
%= 
%= 4
%= 
%= 
%= 
%= \begin{flushleft}
%= Figure 4-14. Scan Characters Double (scd) EIS Multiword Instruction Format
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= MF1
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Modification field for operand descriptor 1
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= MF2
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Modification field for operand descriptor 2
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= I
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Interrupt inhibit bit
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Y-charn1
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Address of string
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= \newpage
%= CN1
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= First character position of string
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= TA1
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Data type of string
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= N1
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Length of string
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Y-charn2
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Address of test character pair
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= CN2
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= First character position of test character pair
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Y3
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Address of compare count word
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= A
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Indirect via pointer register flag for Y3
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= REG
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Register modifier for Y3
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= ALM Coding Format:
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= scd
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= (MF1),(MF2)
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= descna
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Y-charn1[(CN1)],N1
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= n = 4, 6, or 9 (TA1 = 2, 1, or 0)
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= descna
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Y-charn2[(CN2)]
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= n = 4, 6, or 9 (TA2 is ignored)
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= arg
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Y3[,tag]
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
\insum {For i = 1, 2, ..., N1-1}
\inull {\hspace{1em}C(Y-charn1)i-1,i :: C(Y-charn2)0,1}
\inull {On instruction completion, if a match was found:}
\inull {\hspace{1em}00...0 $\rightarrow$ C(Y3)0,11}
\inull {\hspace{1em}i-1 $\rightarrow$ C(Y3)12,35}
\inull {If no match was found:}
\inull {\hspace{1em}00...0 $\rightarrow$ C(Y3)0,11}
\inull {\hspace{1em}N1-1$\rightarrow$ C(Y3)12,35}
 
%= MODIFICATIONS:
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= None except au, qu, al, ql, xn for MF1 and REG
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= None except du, au, qu, al, ql, xn for MF2
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= INDICATORS:
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= Tally runout
%= \end{flushleft}
%= 
%= \begin{flushleft}

\inina

%= 
%= \begin{flushleft}
%= ON; otherwise OFF
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= Both the string and the test character pair are treated as the data type
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= given for the string, TA1. A data type given for the test character pair,
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= TA2, is ignored.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= Instruction execution proceeds until a character pair match is found or the
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= string length count is exhausted.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= If MFk.RL = 1, then Nk does not contain the operand length; instead, it
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= contains a register code for a register holding the operand length.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= If MFk.ID = 1, then the kth word following the instruction word does not
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= contain an operand descriptor; instead, it contains an indirect pointer to
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= the operand descriptor.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= If MF2.ID = 0 and MF2.REG = du, then the second word following the
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= instruction word does not contain an operand descriptor for the test
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= character pair; instead, it contains the test character pair as a direct upper
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= operand in bits 0,17.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= Attempted execution with the xed instruction causes an illegal procedure
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= fault.
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= \newpage
%= Attempted repetition with the rpt, rpd, or rpl instructions causes an
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= illegal procedure fault.
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= scdr
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Scan Characters Double in Reverse
%= \end{flushleft}
%= 
%= 
%= 
%= 121 (1)
%= 
%= 
%= 
%= \begin{flushleft}
%= FORMAT:
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Same as Scan Characters Double (scd) format (see Figure 4-14).
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
\insum {For i = 1, 2, ..., N1-1}
\inull {\hspace{2em}C(Y-charn1)N1-i-1,N1-i :: C(Y-charn2)0,1}
\inull {On instruction completion, if a match was found:}
\inull {\hspace{1em}00...0 $\rightarrow$ C(Y3)0,11}
\inull {\hspace{1em}i-1 $\rightarrow$ C(Y3)12,35}
\inull {If no match was found:}
\inull {\hspace{1em}00...0 $\rightarrow$ C(Y3)0,11}
\inull {\hspace{1em}N1-1 $\rightarrow$ C(Y3)12,35}
 
%= MODIFICATIONS:
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= None except au, qu, al, ql, xn for MF1 and REG
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= None except du, au, qu, al, ql, xn for MF2
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= INDICATORS:
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= Tally runout
%= \end{flushleft}
%= 
%= \begin{flushleft}

\inina

%= 
%= \begin{flushleft}
%= ON; otherwise OFF
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= Both the string and the test character pair are treated as the data type
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= given for the string, TA1. A data type given for the test character pair,
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= TA2, is ignored.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= Instruction execution proceeds until a character pair match is found or the
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= string length count is exhausted.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= If MFk.RL = 1, then Nk does not contain the operand length; instead, it
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= contains a register code for a register holding the operand length.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= If MFk.ID = 1, then the kth word following the instruction word does not
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= contain an operand descriptor; instead, it contains an indirect pointer to
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= the operand descriptor .
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= If MF2.ID = 0 and MF2.REG = du, then the second word following the
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= instruction word does not contain an operand descriptor for the test
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= character pair; instead, it contains the test character pair as a direct upper
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= operand in bits 0, 17.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= Attempted execution with the xed instruction causes an illegal procedure
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= fault.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= Attempted repetition with the rpt, rpd, or rpl instructions causes an
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= illegal procedure fault.
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= \newpage
%= scm
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Scan with Mask
%= \end{flushleft}
%= 
%= 
%= 
%= 124 (1)
%= 
%= 
%= 
%= \begin{flushleft}
%= FORMAT:
%= \end{flushleft}
%= 
%= 0
%= 
%= 0
%= 
%= 
%= 
%= 0 0 1 1
%= 
%= 8 9 0 1
%= 
%= \begin{flushleft}
%= MASK
%= \end{flushleft}
%= 
%= 
%= 
%= 0 0
%= 
%= 
%= 
%= 1 1
%= 
%= 7 8
%= 
%= 
%= 
%= 2 2 2 2 2
%= 
%= 0 1 2 3 4
%= 
%= 
%= 
%= \begin{flushleft}
%= MF2
%= \end{flushleft}
%= 
%= 
%= 
%= 2 2 2 3 3 3
%= 
%= 7 8 9 0 1 2
%= 
%= 
%= 
%= 124 (1)
%= 
%= 
%= 
%= 9
%= 
%= 2
%= 
%= \begin{flushleft}
%= Y-charn1
%= \end{flushleft}
%= 
%= 
%= 
%= 7
%= 
%= 
%= 
%= \begin{flushleft}
%= Y-charn2
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= I
%= \end{flushleft}
%= 
%= 10
%= 
%= 
%= 
%= \begin{flushleft}
%= MF1
%= \end{flushleft}
%= 
%= 
%= 
%= 1
%= 
%= 
%= 
%= 7
%= 
%= 
%= 
%= \begin{flushleft}
%= CN1
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= TA1 0
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= N1
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= CN2
%= \end{flushleft}
%= 
%= 
%= 
%= 2 1
%= 
%= 12
%= 
%= 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
%= 
%= 
%= 
%= 3
%= 
%= \begin{flushleft}
%= 0 0 0 0 0 0 0 0 0 0 0 A 0 0
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Y3
%= \end{flushleft}
%= 
%= 
%= 
%= 3
%= 
%= 5
%= 
%= 
%= 
%= 18
%= 
%= 
%= 
%= 11 1
%= 
%= 
%= 
%= 15
%= 
%= \begin{flushleft}
%= REG
%= \end{flushleft}
%= 
%= 
%= 
%= 2
%= 
%= 
%= 
%= \begin{flushleft}
%= Figure 4-15. Scan with Mask (scm) EIS Multiword Instruction Format
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= MASK
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Comparison bit mask
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= MF1
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Modification field for operand descriptor 1
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= MF2
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Modification field for operand descriptor 2
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= I
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Interrupt inhibit bit
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Y-charn1
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Address of string
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= CN1
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= First character position of string
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= TA1
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Data type of string
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= N1
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Length of string
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Y- charn2
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Address of test character
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= CN2
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= First character position of test character
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Y3
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Address of compare count word
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= A
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Indirect via pointer register flag for Y3
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= REG
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Register modifier for Y3
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= ALM Coding Format:
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= scm
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= (MF1),(MF2)[,mask(octalexpression)]
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= descna
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Y-charn1[(CN1)],N1
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= n = 4, 6, or 9 (TA1 = 2, 1, or 0)
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= descna
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Y-charn2[(CN2)]
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= n = 4, 6, or 9 (TA2 is ignored)
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= arg
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Y3[,tag]
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
\insum {For characters i = 1, 2, ..., N1}
\inull {\hspace{1em}For bits j = 0, 1, ..., 8}
\inull {\hspace{2em}C(Z)j = \~{}C(MASK)j \& ((C(Y-charn1)i-1 )j $\oplus$ (C(Y-charn2)0)j)}
\inull {\hspace{1em}If C(Z)0,8 = 00...0, then}
\inull {\hspace{2em}00...0 $\rightarrow$ C(Y3)0,11}
\inull {\hspace{2em}i-1 $\rightarrow$ C(Y3)12,35}
\inull {\hspace{1em}otherwise, continue scan of C(Y-charn1)}
\inull {\hspace{1em}If a masked character match was not found, then}
\inull {\hspace{2em}00...0 $\rightarrow$ C(Y3)0,11}
\inull {\hspace{2em}N1 $\rightarrow$ C(Y3)12,35}

%= MODIFICATIONS:
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= None except au, qu, al, ql, xn for MF1 and REG
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= None except du, au, qu, al, ql, xn for MF2
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}

\inina

%= Tally runout
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= NOTES:
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= If the string length count exhausts, then ON; otherwise, OFF
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= Both the string and the test character pair are treated as the data type
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= given for the string, TA1. A data type given for the test character pair,
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= TA2, is ignored.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= 1 bits in C(MASK) specify those bits of each character that will not take
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= part in the masked comparison.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= Instruction execution proceeds until a masked character match is found or
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= the string length count is exhausted.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= Masking and comparison is done on full 9-bit fields. If the given data type
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= is not 9-bit (TA1 $\neq$ 0), then characters from C(Y-charn1) and C(Y-charn2)
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= are high-order zero filled. All 9 bits of C(MASK) are used.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= If MF1.RL = 1, then N1 does not contain the operand length; instead, it
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= contains a register code for a register holding the operand length.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= If MFk.ID = 1, then the kth word following the instruction word does not
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= contain an operand descriptor; instead, it contains an indirect pointer to
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= the operand descriptor.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= If MF2.ID = 0 and MF2.REG = du, then the second word following the
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= instruction word does not contain an operand descriptor for the test
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= character; instead, it contains the test character as a direct upper operand
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= in bits 0,8.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= Attempted execution with the xed instruction causes an illegal procedure
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= fault.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= Attempted repetition with the rpt, rpd, or rpl instructions causes an
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= illegal procedure fault.
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= scmr
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Scan with Mask in Reverse
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= FORMAT:
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Same as Scan with Mask (scm) format (see Figure 4-15).
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
\insum {For characters i = 1, 2, ..., N1}
\inull {\hspace{1em}For bits j = 0, 1, ..., 8}
\inull {\hspace{2em}C(Z)j = \~{}C(MASK)j \& ((C(Y-charn1)N1-i)j $\oplus$ (C(Y-charn2)0)j)}
\inull {\hspace{1em}If C(Z)0,8 = 00...0, then}
\inull {\hspace{2em}00...0 $\rightarrow$ C(Y3)0,11}
\inull {\hspace{2em}i-1 $\rightarrow$ C(Y3)12,35}
\inull {\hspace{1em}otherwise, continue scan of C(Y-charn1)}
\inull {If a masked character match was not found, then}
\inull {\hspace{1em}00...0 $\rightarrow$ C(Y3)0,11}
\inull {\hspace{1em}N1 $\rightarrow$ C(Y3)12,35}

%= MODIFICATIONS:
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= None except au, qu, al, ql, xn for MF1 and REG
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= None except du, au, qu, al, ql, xn for MF2
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= INDICATORS:
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= Tally runout
%= \end{flushleft}
%= 
%= \begin{flushleft}

\inina

%= 
%= \begin{flushleft}
%= Both the string and the test character are treated as the data type given
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= for the string, TA1. A data type given for the test character, TA2, is
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= ignored.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= 1 bits in C(MASK) specify those bits of each character that will not take
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= part in the masked comparison.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= Instruction execution proceeds until a masked character match is found or
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= the string length count is exhausted.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= Masking and comparison is done on full 9-bit fields. If the given data type
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= is not 9-bit (TA1 $\neq$ 0), then characters from C(Y-charn1) and C(Y-charn2)
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= are high-order zero filled. All 9 bits of C(MASK) are used.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= If MF1.RL = 1, then N1 does not contain the operand length; instead, it
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= contains a register code for a register holding the operand length.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= If MFk.ID = 1, then the kth word following the instruction word does not
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= contain an operand descriptor; instead, it contains an indirect pointer to
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= the operand descriptor.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= If MF2.ID = 0 and MF2.REG = du, then the second word following the
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= instruction word does not contain an operand descriptor for the test
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= character; instead, it contains the test character as a direct upper operand
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= in bits 0,8.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= Attempted execution with the xed instruction causes an illegal procedure
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= fault.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= Attempted repetition with the rpt, rpd, or rpl instructions causes an
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= illegal procedure fault.
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= \newpage
%= tct
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Test Character and Translate
%= \end{flushleft}
%= 
%= 
%= 
%= 164 (1)
%= 
%= 
%= 
%= \begin{flushleft}
%= FORMAT:
%= \end{flushleft}
%= 
%= 0
%= 
%= 0
%= 
%= 
%= 
%= 1 1
%= 
%= 7 8
%= 
%= 
%= 
%= 2 2 2 2 2
%= 
%= 0 1 2 3 4
%= 
%= 
%= 
%= 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
%= 
%= 
%= 
%= 164 (1)
%= 
%= 
%= 
%= 2 2 2 3 3 3
%= 
%= 7 8 9 0 1 2
%= 
%= \begin{flushleft}
%= I
%= \end{flushleft}
%= 
%= 
%= 
%= 3
%= 
%= 5
%= 
%= 
%= 
%= \begin{flushleft}
%= MF1
%= \end{flushleft}
%= 
%= 
%= 
%= 10 1
%= 
%= \begin{flushleft}
%= Y-charn1
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= CN1
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= TA1 0
%= \end{flushleft}
%= 
%= 
%= 
%= 7
%= 
%= \begin{flushleft}
%= N1
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Y-char92
%= \end{flushleft}
%= 
%= 
%= 
%= 3
%= 
%= 2 1
%= 
%= \begin{flushleft}
%= 0 0 0 0 0 0 0 0 0 0 0 A 0 0
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= REG
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Y3
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= 0 0 0 0 0 0 0 0 0 0 0 A 0 0
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= REG
%= \end{flushleft}
%= 
%= 
%= 
%= 18
%= 
%= 
%= 
%= 11 1
%= 
%= 
%= 
%= 12
%= 
%= 
%= 
%= 2
%= 
%= 
%= 
%= \begin{flushleft}
%= Figure 4-16. Test Character and Translate (tct)
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= EIS Multiword Instruction Format
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= MF1
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Modification field for operand descriptor 1
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= I
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Interrupt inhibit bit
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Y-charn1
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Address of string
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= CN1
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= First character position of string
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= TA1
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Data type of string
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= N1
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Length of string
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Y-char92
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Address of character translation table
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Y3
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Address of result word
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= A
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Indirect via pointer register flag for Y2 and Y3
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= REG
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Register modifier for Y2 and Y3
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= ALM Coding Format:
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= tct
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= (MF1)
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= descna
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Y-charn1[(CN1)],N1
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= arg
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Y-char92[,tag]
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= arg
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Y3[,tag]
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
\insum {n = 4, 6, or 9 (TA1 = 2, 1, or 0)}
\inull {\hspace{1em}For i = 1, 2, ..., N1}
\inull {\hspace{1em}m = C(Y-charn1)i-1}
\inull {\hspace{1em}If C(Y-char92)m $\neq$ 00...0, then}
\inull {\hspace{2em}C(Y-char92)m $\rightarrow$ C(Y3)0,8}
\inull {\hspace{2em}000 $\rightarrow$ C(Y3)9,11}
\inull {\hspace{2em}i-1 $\rightarrow$ C(Y3)12,35}
\inull {\hspace{1em}otherwise, continue scan of C(Y-charn1)}
\inull {\hspace{1em}If a non-zero table entry was not found, then}
\inull {\hspace{2em}00...0 $\rightarrow$ C(Y3)0,11}
\inull {\hspace{2em}N1 $\rightarrow$ C(Y3)12,3}


%= MODIFICATIONS:
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= None except au, qu, al, ql, xn for MF1 and MF2
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}

\inina

%= Tally runout
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= NOTES:
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= If the string length count exhausts, then ON; otherwise, OFF
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= If the data type of the string to be scanned is not 9-bit (TA1 $\neq$ 0), then
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= characters from C(Y-charn1) are high-order zero filled in forming the table
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= index, m.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= Instruction execution proceeds until a non-zero table entry is found or the
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= string length count is exhausted.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= If MF1.RL = 1, then N1 does not contain the operand length; instead, it
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= contains a register code for a register holding the operand length.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= If MF1.ID = 1, then the first word following the instruction word does not
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= contain an operand descriptor; instead, it contains an indirect pointer to
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= the operand descriptor.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= Attempted execution with the xed instruction causes an illegal procedure
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= fault.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= Attempted repetition with the rpt, rpd, or rpl instructions causes an
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= illegal procedure fault.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= The character number of Y-char92 must be zero, i.e., Y-char92 must start
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= on a word boundary.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= If a non-zero table entry was not found, then
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= 00...0 $\rightarrow$ C(Y3)0,11
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= N1 $\rightarrow$ C(Y3)12,35
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= tctr
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Test Character and Translate in Reverse
%= \end{flushleft}
%= 
%= 
%= 
%= 165 (1)
%= 
%= 
%= 
%= \begin{flushleft}
%= FORMAT:
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Same as Test Character and Translate (tct) format (see Figure 4-16).
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
\insum {For i = 1, 2, ..., N1}
\inull {\hspace{1em}m = C(Y-charn1)N1-i}
\inull {\hspace{1em}If C(Y-char92)m $\neq$ 00...0, then}
\inull {\hspace{2em}C(Y-char92)m $\rightarrow$ C(Y3)0,8}
\inull {\hspace{2em}000 $\rightarrow$ C(Y3)9,11}
\inull {\hspace{2em}i-1 $\rightarrow$ C(Y3)12,35}
\inull {\hspace{1em}otherwise, continue scan of C(Y-charn1)}
\inull {If a non-zero table entry was not found, then}
\inull {\hspace{1em}00...0 $\rightarrow$ C(Y3)0,11}
\inull {\hspace{1em}N1 $\rightarrow$ C(Y3)12,35}


%= MODIFICATIONS:
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= None except au, qu, al, ql, xn for MF1 and REG
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}

\inina

%= Tally runout
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= If the string length count exhausts, then ON; otherwise, OFF
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= \newpage
%= NOTES:
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= If the data type of the string to be scanned is not 9-bit (TA1 $\neq$ 0), then
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= characters from C(Y-charn1) are high-order zero filled in forming the table
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= index, m.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= Instruction execution proceeds until a non-zero table entry is found or the
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= string length count is exhausted.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= If MF1.RL = 1, then N1 does not contain the operand length; instead, it
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= contains a register code for a register holding the operand length.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= If MF1.ID = 1, then the first word following the instruction word does not
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= contain an operand descriptor; instead, it contains an indirect pointer to
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= the operand descriptor.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= Attempted execution with the xed instruction causes an illegal procedure
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= fault.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= Attempted repetition with the rpt, rpd, or rpl instructions causes an
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= illegal procedure fault.
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= \newpage

\subsubsection{EIS - Alphanumeric Move}

%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= mlr
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Move Alphanumeric Left to Right
%= \end{flushleft}
%= 
%= 
%= 
%= 100 (1)
%= 
%= 
%= 
%= \begin{flushleft}
%= FORMAT:
%= \end{flushleft}
%= 
%= 0
%= 
%= 0
%= 
%= 
%= 
%= 0 0 1 1
%= 
%= 8 9 0 1
%= 
%= \begin{flushleft}
%= FILL
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= T 0
%= \end{flushleft}
%= 
%= 
%= 
%= 1 1
%= 
%= 7 8
%= 
%= 
%= 
%= 2 2 2 2 2
%= 
%= 0 1 2 3 4
%= 
%= 
%= 
%= \begin{flushleft}
%= MF2
%= \end{flushleft}
%= 
%= 
%= 
%= 9 1 1
%= 
%= \begin{flushleft}
%= Y-charn1
%= \end{flushleft}
%= 
%= 
%= 
%= 100 (1)
%= 
%= 7
%= 
%= 
%= 
%= \begin{flushleft}
%= Y-charn2
%= \end{flushleft}
%= 
%= 
%= 
%= 2 2 2
%= 
%= 7 8 9
%= 
%= \begin{flushleft}
%= I
%= \end{flushleft}
%= 
%= 
%= 
%= 3
%= 
%= 5
%= 
%= \begin{flushleft}
%= MF1
%= \end{flushleft}
%= 
%= 
%= 
%= 10 1
%= 
%= 
%= 
%= 7
%= 
%= 
%= 
%= \begin{flushleft}
%= CN1
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= TA1 0
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= N1
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= CN2
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= TA2 0
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= N2
%= \end{flushleft}
%= 
%= 
%= 
%= 18
%= 
%= 
%= 
%= 3
%= 
%= 
%= 
%= 2 1
%= 
%= 
%= 
%= \begin{flushleft}
%= Figure 4-17. Move Alphanumeric Left to Right (mlr)
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= EIS Multiword Instruction Format
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= FILL
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Fill character for string extension
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= T
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Truncation fault enable bit
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= MF1
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Modification field for operand descriptor 1
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= MF2
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Modification field for operand descriptor 2
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Y-charn1
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Address of sending string
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= CN1
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= First character position of sending string
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= TA1
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Data type of sending string
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= N1
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Length of sending string
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Y- charn2
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Address of receiving string
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= CN2
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= First character position of receiving string
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= TA2
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Data type of receiving string
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= N2
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Length of receiving string
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= ALM Coding Format:
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= mlr
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= (MF1),(MF2)[,fill(octalexpression)][,enablefault]
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= descna
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Y-charn1[(CN1)],N1
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= n = 4, 6, or 9 (TA1 = 2, 1, or 0)
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= descna
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Y-charn2[(CN2)],N2
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= n = 4, 6, or 9 (TA2 = 2, 1, or 0)
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
\insum {For i = 1, 2, ..., minimum (N1,N2)}
\inull {\hspace{1em}C(Y-charn1)i-1 $\rightarrow$ C(Y-charn2)i-1}
\inull {If N1 $<$ N2, then for i = N1+1, N1+2, ..., N2}
\inull {\hspace{1em}C(FILL) $\rightarrow$ C(Y-charn2)i-1}

%= MODIFICATIONS:
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= None except au, qu, al, ql, xn for MF1 and MF2
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}

\inina

%= Truncation
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= If N1 $>$ N2 then ON; otherwise OFF
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= NOTES:
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= If data types are dissimilar (TA1 $\neq$ TA2), each character is high-order
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= truncated or zero filled, as appropriate, as it is moved. No character
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= conversion takes place.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= If N1 $>$ N2, then (N1-N2) trailing characters of C(Y-charn1) are not moved
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= and the truncation indicator is set ON.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= If N1 $<$ N2 and TA2, = 2 (4-bit data) or 1 (6-bit data), then FILL characters
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= are high-order truncated as they are moved to C(Y-charn2). No character
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= conversion takes place.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= If N1 $<$ N2, C(FILL)0 = 1, TA1 = 1, and TA2 = 2, then C(Y-charn1)N1-1 is
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= examined for a GBCD overpunch sign. If a negative overpunch sign is
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= found, then the minus sign character is placed in C(Y-charn2)N2-1;
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= otherwise, a plus sign character is placed in C(Y-charn2)N2-1.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= If MFk.RL = 1,, then Nk does not contain the operand length; instead, it
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= contains a register code for a register holding the operand length.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= If MFk.ID = 1, then the kth word following the instruction word does not
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= contain an operand descriptor; instead, it contains an indirect pointer to
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= the operand descriptor.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= C(Y-charn1) and C(Y-charn2) may be overlapping strings; no check is
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= made. This feature is useful for replication of substrings within a larger
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= string, but care must be exercised in the construction of the operand
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= descriptors so that sending string, C(Y-charn1), data is not inadvertently
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= destroyed.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= The user of string replication or overlaying is warned that the decimal unit
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= addresses the main memory in unaligned (not on modulo 8 boundary) units
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= of Y-block8 words and that the overlayed string, C(Y-charn2), is not
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= returned to main memory until the unit of Y-block8 words is filled or the
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= instruction completes.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= If T = 1 and the truncation indicator is set ON by execution of the
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= instruction, then a truncation (overflow) fault occurs.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= Attempted execution with the xed instruction causes an illegal procedure
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= fault.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= Attempted repetition with the rpt, rpd, or rpl instructions causes an
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= illegal procedure fault.
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= mrl
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Move Alphanumeric Right to Left
%= \end{flushleft}
%= 
%= 
%= 
%= 101 (1)
%= 
%= 
%= 
%= \begin{flushleft}
%= FORMAT:
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Same as Move Alphanumeric Left to Right (mlr) format (see Figure 4-17).
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
\insum {For i = 1, 2, ..., minimum (N1,N2)}
\inull {\hspace{1em}C(Y-charn1)N1-i $\rightarrow$ C(Y-charn2)N2-i}
\inull {If N1 $<$ N2, then for i = N1+1, N1+2, ..., N2}
\inull {\hspace{1em}C(FILL) $\rightarrow$ C(Y-charn2)N2-i}
 
%= MODIFICATIONS:
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= None except au, qu, al, ql, xn for MF1 and MF2
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= INDICATORS:
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= (Indicators not list,ed are not affected)
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Truncation
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= If N1 $>$ N2 then ON; otherwise OFF
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= \newpage
%= NOTES:
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= If data types are dissimilar (TA1 $\neq$ TA2), each character is high-order
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= truncated or zero filled, as appropriate, as it is moved. No character
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= conversion takes place.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= If N1 $>$ N2, then (N1-N2) leading characters of C(Y-charn1) are not moved
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= and the truncation indicator is set ON.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= If N1 $<$ N2 and TA2 = 2 (4-bit data) or 1 (6-bit data), then FILL characters
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= are high-order truncated as they are moved to C(Y-charn2). No character
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= conversion takes place.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= If MFk.RL = 1, then Nk does not contain the operand length; instead, it
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= contains a register code for a register holding the operand length.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= If MFk.ID = 1, then the kth word following the instruction word does not
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= contain an operand descriptor; instead, it contains an indirect pointer to
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= the operand descriptor.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= C(Y-charn1) and C(Y-charn2) may be overlapping strings; no check is
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= made. This feature is useful for replication of substrings within a larger
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= string, but care must be exercised in the construction of the operand
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= descriptors so that sending string, C(Y-charn1), data is not inadvertently
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= destroyed.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= The user of string replication or overlaying is warned that the decimal unit
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= addresses the main memory in unaligned (not on modulo 8 boundary) units
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= of Y-block8 words and that the overlayed string, C(Y-charn2), is not
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= returned to main memory until the unit of Y-block8 words is filled or the
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= instruction completes.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= If T = 1 and the truncation indicator is set ON by execution of the
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= instruction, then a truncation (overflow) fault occurs.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= Attempted execution with the xed instruction causes an illegal procedure
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= fault.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= Attempted repetition with the rpt, rpd, or rpl instructions causes an
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= illegal procedure fault.
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= mve
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Move Alphanumeric Edited
%= \end{flushleft}
%= 
%= 
%= 
%= 020 (1)
%= 
%= 
%= 
%= \begin{flushleft}
%= FORMAT:
%= \end{flushleft}
%= 
%= 0 0 0
%= 
%= 0 1 2
%= 
%= 0 0
%= 
%= 2
%= 
%= 
%= 
%= 0 0 1 1
%= 
%= 8 9 0 1
%= 
%= \begin{flushleft}
%= MF3
%= \end{flushleft}
%= 
%= 
%= 
%= 0 0
%= 
%= 7
%= 
%= 2
%= 
%= \begin{flushleft}
%= Y-charn1
%= \end{flushleft}
%= 
%= 
%= 
%= 1 1
%= 
%= 7 8
%= 
%= 
%= 
%= 2 2 2 2 2
%= 
%= 0 1 2 3 4
%= 
%= 
%= 
%= \begin{flushleft}
%= MF2
%= \end{flushleft}
%= 
%= 
%= 
%= 020 (1)
%= 
%= 7
%= 
%= 
%= 
%= 2 2 2
%= 
%= 7 8 9
%= 
%= \begin{flushleft}
%= I
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= MF1
%= \end{flushleft}
%= 
%= 
%= 
%= 10 1
%= 
%= 
%= 
%= 7
%= 
%= 
%= 
%= \begin{flushleft}
%= CN1
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= TA1 0
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= N1
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Y-char92
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= CN2
%= \end{flushleft}
%= 
%= 
%= 
%= 0 0 0
%= 
%= 
%= 
%= \begin{flushleft}
%= N2
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Y-charn3
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= CN3
%= \end{flushleft}
%= 
%= 
%= 
%= 3
%= 
%= \begin{flushleft}
%= TA3 0
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= N3
%= \end{flushleft}
%= 
%= 
%= 
%= 18
%= 
%= 
%= 
%= 3
%= 
%= 
%= 
%= 2 1
%= 
%= 
%= 
%= \begin{flushleft}
%= Figure 4-18. Move Alphanumeric Edited (mve)
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= EIS Multiword Instruction Format
%= \end{flushleft}
%= 
%= 
%= 
%= 3
%= 
%= 5
%= 
%= 
%= 
%= 12
%= 
%= 
%= 
%= \begin{flushleft}
%= \newpage
%= MF1
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Modification field for operand descriptor 1
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= MF2
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Modification field for operand descriptor 2
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= MF3
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Modification field for operand descriptor 3
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= I
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Interrupt inhibit bit
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Y-charn1
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Address of sending string
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= CN1
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= First character position of sending string
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= TA1
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Data type of sending string
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= N1
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Length of sending string
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Y-char92
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Address of MOP control string
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= CN2
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= First character position of MOP control string
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= N2
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Length of MOP control string
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Y-charn3
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Address of receiving string
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= CN3
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= First character position of receiving string
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= TA3
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Data type of receiving string
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= N3
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Length of receiving string
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= ALM Coding Format:
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= mve
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= (MF1),(MF2),(MF3)
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= descna
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Y-charn1[(CN1)],N1
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= desc9a
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Y-char92[(CN2)],N2
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= descna
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Y-charn3[(CN3)],N3
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= \begin{flushleft}
%= n = 4, 6, or 9 (TA1 = 2, 1, or 0)
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= n = 4, 6, or 9 (TA3 = 2, 1, or 0)
%= \end{flushleft}
%= 
%= 
%= 
\insum {C(Y-charn1) $\rightarrow$ C(Y-charn3) under C(Y-char92) MOP control}
\inull {See {``}Micro Operations for Edit Instructions'' later in this section for details
of editing under MOP control.}
 
%= MODIFICATIONS:
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= None except au, qu, al, ql, xn for MF1, MF2, and MF3
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
\innaf
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= NOTES:
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= If data types are dissimilar (TA1 $\neq$ TA3), each character of C(Y-charn1) is
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= high-order truncated or zero filled, as appropriate, as it is moved. No
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= character conversion takes place.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= If the data type of the receiving string is not 9-bit (TA3 = 0), then insertion
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= characters are high-order truncated as they are inserted.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= The maximum string length is 63. The count fields N1, N2, and N3 are
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= treated as modulo 64 numbers.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= The instruction completes normally only if N3 is the first tally to exhaust:
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= otherwise, an illegal procedure fault occurs.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= If MFk.RL = 1, then Nk does not contain the operand length; instead, it
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= contains a register code for a register holding the operand length.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= If MFk.ID = 1, then the kth word following the instruction word does not
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= contain an operand descriptor; instead, it contains an indirect pointer to
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= the operand descriptor.
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= \newpage
%= C(Y-charn1) and C(Y-charn3) may be overlapping strings; no check is
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= made. This feature is useful for replication of substrings within a larger
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= string, but care must be exercised in the construction of the operand
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= descriptors so that sending string, C(Y-charn1), data is not inadvertently
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= destroyed.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= The user of string replication or overlaying is warned that the decimal unit
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= addresses the main memory in unaligned (not on modulo 8 boundary) units
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= of Y-block8 words and that the overlayed string, C(Y-charn3), is not
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= returned to main memory until the unit of Y-block8 words is filled or the
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= instruction completes.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= Attempted execution with the xed instruction causes an illegal procedure
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= fault.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= Attempted repetition with the rpt, rpd, or rpl instructions causes an
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= illegal procedure fault.
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= mvt
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Move Alphanumeric with Translation
%= \end{flushleft}
%= 
%= 
%= 
%= 160 (1)
%= 
%= 
%= 
%= \begin{flushleft}
%= FORMAT:
%= \end{flushleft}
%= 
%= 0 0 0
%= 
%= 0 1 2
%= 
%= 0 0
%= 
%= 2
%= 
%= 
%= 
%= 0 0 1 1
%= 
%= 8 9 0 1
%= 
%= \begin{flushleft}
%= MF3
%= \end{flushleft}
%= 
%= 
%= 
%= 0 0
%= 
%= 
%= 
%= 1 1
%= 
%= 7 8
%= 
%= 
%= 
%= 2 2 2 2 2
%= 
%= 0 1 2 3 4
%= 
%= 
%= 
%= \begin{flushleft}
%= MF2
%= \end{flushleft}
%= 
%= 
%= 
%= 7
%= 
%= 2
%= 
%= \begin{flushleft}
%= Y-charn1
%= \end{flushleft}
%= 
%= 
%= 
%= 020 (1)
%= 
%= 7
%= 
%= 
%= 
%= 2 2 2
%= 
%= 7 8 9
%= 
%= \begin{flushleft}
%= I
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= MF1
%= \end{flushleft}
%= 
%= 
%= 
%= 10 1
%= 
%= 
%= 
%= 7
%= 
%= 
%= 
%= \begin{flushleft}
%= CN1
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= TA1 0
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= N1
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Y-char92
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= CN2
%= \end{flushleft}
%= 
%= 
%= 
%= 0 0 0
%= 
%= 
%= 
%= \begin{flushleft}
%= N2
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Y-charn3
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= CN3
%= \end{flushleft}
%= 
%= 
%= 
%= 3
%= 
%= \begin{flushleft}
%= TA3 0
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= N3
%= \end{flushleft}
%= 
%= 
%= 
%= 18
%= 
%= 
%= 
%= 3
%= 
%= 5
%= 
%= 
%= 
%= 3
%= 
%= 
%= 
%= 2 1
%= 
%= 
%= 
%= \begin{flushleft}
%= Figure 4-19. Move Alphanumeric with Translation (mvt)
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= EIS Multiword Instruction Format
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= FILL
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Fill character for string extension
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= T
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Truncation fault enable bit
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= MF1
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Modification field for operand descriptor 1
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= MF2
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Modification field for operand descriptor 2
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Y-charn1
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Address of sending string
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= CN1
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= First character position of sending string
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= TA1
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Data type of sending string
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= N1
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Length of sending string
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Y- charn2
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Address of receiving string
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= CN2
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= First character position of receiving string
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= TA2
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Data type of receiving string
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= N2
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Length of receiving string
%= \end{flushleft}
%= 
%= 
%= 
%= 12
%= 
%= 
%= 
%= \begin{flushleft}
%= \newpage
%= Y-char93
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Address of character translation table
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= A
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Indirect via pointer register flag for Y-char93
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= REG
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Register modifier for Y-char93
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= ALM Coding Format:
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= mvt
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= (MF1),(MF2)[,fill(octalexpression)][,enablefault]
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= descna
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Y-charn1[(CN1)],N1
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= n = 4, 6, or 9 (TA1 = 2, 1, or 0)
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= descna
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Y-charn2[(CN2)],N2
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= n = 4, 6, or 9 (TA1 = 2, 1, or 0)
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= arg
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Y-char93[,tag]
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
\insum {For i = 1, 2, ..., minimum (N1,N2)}
\inull {\hspace{1em}m = C(Y-charn1)i-1}
\inull {\hspace{1em}C(Y-char93)m $\rightarrow$ C(Y-charn2)i-1}
\inull {If N1 $<$ N2, then for i = N1+1, N1+2, ..., N2}
\inull {\hspace{1em}m = C(FILL)}
\inull {\hspace{1em}C(Y-char93)m $\rightarrow$ C(Y-charn2)i-1}
 
%= MODIFICATIONS:
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= None except au, qu, al, ql, xn for MF1, MF2, and REG
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}

\inina

%= Truncation
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= NOTES:
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= If N1 $>$ N2 then ON; otherwise OFF
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= If the data type of the receiving field is not 9-bit (TA2 $\neq$ 0), then characters
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= from C(Y-char93) are high-order truncated, as appropriate, as they are
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= moved.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= If the data type of the sending field is not 9-bit (TA1 $\neq$ 0), then characters
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= from C(Y-charn1) are high-order zero filled when forming the table index.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= If N1 $>$ N2, then (N1-N2) trailing characters of C(Y-charn1) are not moved
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= and the truncation indicator is set ON.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= If MFk.RL = 1, then Nk does not contain the operand length; instead, it
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= contains a register code for a register holding the operand length.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= If MFk.ID = 1, then the kth word following the instruction word does not
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= contain an operand descriptor; instead, it contains an indirect pointer to
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= the operand descriptor.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= C(Y-charn1) and C(Y-charn2) may be overlapping strings; no check is
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= made. This feature is useful for replication of substrings within a larger
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= string, but care must be exercised in the construction of the operand
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= descriptors so that sending string, C(Y-charn1), data is not inadvertently
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= destroyed.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= The user of string replication or overlaying is warned that the decimal unit
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= addresses the main memory in unaligned (not on modulo 8 boundary) units
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= of Y-block8 words and that the overlayed string, C(Y-charn2), is not
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= returned to main memory until the unit of Y-block8 words is filled or the
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= instruction completes.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= If T = 1 and the truncation indicator is set ON by execution of the
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= instruction, then a truncation (overflow) fault occurs.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= Attempted execution with the xed instruction causes an illegal procedure
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= fault.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= Attempted repetition with the rpt, rpd, or rpl instructions causes an
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= illegal procedure fault.
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= \newpage

\subsubsection{EIS - Numeric Compare}

%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= cmpn
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Compare Numeric
%= \end{flushleft}
%= 
%= 
%= 
%= 303 (1)
%= 
%= 
%= 
%= \begin{flushleft}
%= FORMAT:
%= \end{flushleft}
%= 
%= 0
%= 
%= 0
%= 
%= 
%= 
%= 1 1
%= 
%= 0 1
%= 
%= 
%= 
%= 0 0 0 0 0 0 0 0 0 0 0
%= 
%= 
%= 
%= 1 1
%= 
%= 7 8
%= 
%= 
%= 
%= 2 2 2 2 2
%= 
%= 0 1 2 3 4
%= 
%= 
%= 
%= \begin{flushleft}
%= MF2
%= \end{flushleft}
%= 
%= 
%= 
%= 2 2 2 3
%= 
%= 7 8 9 0
%= 
%= 
%= 
%= 303 (1)
%= 
%= 
%= 
%= 11
%= 
%= \begin{flushleft}
%= Y-charn1
%= \end{flushleft}
%= 
%= 
%= 
%= 7
%= 
%= 
%= 
%= 3
%= 
%= 5
%= 
%= 
%= 
%= \begin{flushleft}
%= I
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= MF1
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= N1
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= CN1
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= a
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= S1
%= \end{flushleft}
%= 
%= 
%= 
%= 10 1
%= 
%= \begin{flushleft}
%= SF1
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= CN2
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= b
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= S2
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= SF2
%= \end{flushleft}
%= 
%= 
%= 
%= 7
%= 
%= 1
%= 
%= 
%= 
%= \begin{flushleft}
%= Y-charn2
%= \end{flushleft}
%= 
%= 18
%= 
%= 
%= 
%= 3 1
%= 
%= 
%= 
%= 2
%= 
%= 
%= 
%= 1
%= 
%= \begin{flushleft}
%= N2
%= \end{flushleft}
%= 
%= 
%= 
%= 6
%= 
%= 
%= 
%= 6
%= 
%= 
%= 
%= \begin{flushleft}
%= Figure 4-20. Compare Numeric (cmpn) EIS Multiword Instruction Format
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= key
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= a
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= MF1
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Modification field for operand descriptor 1
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= MF2
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Modification field for operand descriptor 2
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= I
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Interrupt inhibit bit
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Y-charn1
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Address of left-hand number
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= CN1
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= First character position of left-hand number
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= TN1
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Data type of left-hand number
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= S1
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Sign and decimal type of left-hand number
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= SF1
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Scaling factor of left-hand number
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= N1
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Length of left-hand number
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Y- charn2 Address of right-hand number
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= b
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= CN2
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= First character position of right-hand number
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= TN2
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Data type of right-hand number
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= S2
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Sign and decimal type of right-hand number
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= SF2
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Scaling factor of right-hand number
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= N2
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Length of right-hand string
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= ALM Coding Format:
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= cmpn
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= (MF1),(MF2)
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= descn[fl,ls,ns,ts]
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Y-charn1[(CN1)],N1,SF1
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= n = 4 or 9
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= descn[fl,ls,ns,ts]
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Y-charn2[(CN2)],N2,SF2
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= n = 4 or 9
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
\insum {C(Y-charn1) :: C(Y-charn2) as numeric values}
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= \newpage
%= MODIFICATIONS:
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= None except au, qu, al, ql, xn for MF1 and MF2
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}

\inina

\ininz {If C(Y-char\textsl{n}1) = C(Y-char\textsl{n}2), then ON; otherwise OFF}
\ininn {If C(Y-char\textsl{n}1) $>$ C(Y-chartextsl{n}2), then ON; otherwise OFF}

%= Carry
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= If $|$ C(Y-charn1) $|$ $>$ $|$ C(Y-charn2) $|$ , then OFF, otherwise ON
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= NOTES:
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Comparison is made on 4-bit numeric values contained in each character of
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= C(Y-charnk). If either given data type is 9-bit (TNk = 0), characters from
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= C(Y-char9k) are high-order truncated to 4 bits before comparison.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= Sign characters are located according to information in CN k, Sk, and Nk
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= and interpreted as 4-bit fields; 9-bit sign characters are high-order
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= truncated before interpretation. The sign character 158 is interpreted as a
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= minus sign; all other legal sign characters are interpreted as plus signs.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= The position of the decimal point in C(Y-charnk) is determined from
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= information in CNk, Sk, SFk, and Nk.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= Comparison begins at the decimal position corresponding to the first digit
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= of the operand with the larger number of integer digits and ends with the
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= last digit of the operand with the larger number of fraction digits.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= Four-bit numeric zeros are used to represent digits to the left of the first
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= given digit of the operand with the smaller number of integer digits.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= Four-bit numeric zeros are used to represent digits to the right of the last
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= given digit of the operand with the smaller number of fraction digits.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= Instruction execution proceeds until an inequality is found or the larger
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= string length count is exhausted.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= If MFk.RL = 1, then Nk does not contain the operand length; instead, it
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= contains a register code for a register holding the operand length.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= If MFk.ID = 1, then the kth word following the instruction word does not
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= contain an operand descriptor; instead, it contains an indirect pointer to
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= the operand descriptor.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= Detection of a character outside the range [0,11]8 in a digit position or a
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= character outside the range [12,l7]8 in a sign position causes an illegal
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= procedure fault.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= Attempted execution with the xed instruction causes an illegal procedure
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= fault.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= Attempted repetition with the rpt, rpd, or rpl instructions causes an
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= illegal procedure fault.
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= \newpage

\subsubsection{EIS - Numeric Move}

%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= mvn
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Move Numeric
%= \end{flushleft}
%= 
%= 
%= 
%= 300 (1)
%= 
%= 
%= 
%= \begin{flushleft}
%= FORMAT:
%= \end{flushleft}
%= 
%= 0 0
%= 
%= 0 1
%= 
%= 
%= 
%= 0 0 1 1
%= 
%= 8 9 0 1
%= 
%= 
%= 
%= \begin{flushleft}
%= P 0 0 0 0 0 0 0 0 T R
%= \end{flushleft}
%= 
%= 1
%= 
%= 
%= 
%= 1 1
%= 
%= 7 8
%= 
%= 
%= 
%= 2 2 2 2 2
%= 
%= 0 1 2 3 4
%= 
%= 
%= 
%= \begin{flushleft}
%= MF2
%= \end{flushleft}
%= 
%= 
%= 
%= 2 2 2 3
%= 
%= 7 8 9 0
%= 
%= 
%= 
%= 300 (1)
%= 
%= 
%= 
%= 8 1 1
%= 
%= \begin{flushleft}
%= Y-charn1
%= \end{flushleft}
%= 
%= 
%= 
%= 7
%= 
%= 
%= 
%= 3
%= 
%= 5
%= 
%= 
%= 
%= \begin{flushleft}
%= I
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= MF1
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= N1
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= CN1
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= a
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= S1
%= \end{flushleft}
%= 
%= 
%= 
%= 10 1
%= 
%= \begin{flushleft}
%= SF1
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= CN2
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= b
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= S2
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= SF2
%= \end{flushleft}
%= 
%= 
%= 
%= 7
%= 
%= 1
%= 
%= 
%= 
%= \begin{flushleft}
%= Y-charn2
%= \end{flushleft}
%= 
%= 18
%= 
%= 
%= 
%= 3 1
%= 
%= 
%= 
%= 2
%= 
%= 
%= 
%= 1
%= 
%= \begin{flushleft}
%= N2
%= \end{flushleft}
%= 
%= 
%= 
%= 6
%= 
%= 
%= 
%= \begin{flushleft}
%= Figure 4-21. Move Numeric (mvn) EIS Multiword Instruction Format
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= key
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= a
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= P
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= 4-bit data sign character control
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= T
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Truncation fault enable bit
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= R
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Rounding flag
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= MF1
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Modification field for operand descriptor 1
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= MF2
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Modification field for operand descriptor 2
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= I
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Interrupt inhibit bit
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Y-charn1
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Address of sending number
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= CN1
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= First character position of sending number
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= TN1
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Data type of sending number
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= S1
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Sign and decimal type of sending number
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= SF1
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Scaling factor of sending number
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= N1
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Length of sending number
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Y- charn2 Address of receiving number
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= b
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= CN2
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= First character position of receiving number
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= TN2
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Data type of receiving number
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= S2
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Sign and decimal type of receiving number
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= SF2
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Scaling factor of receiving number
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= N2
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Length of receiving string
%= \end{flushleft}
%= 
%= 
%= 
%= 6
%= 
%= 
%= 
%= \begin{flushleft}
%= \newpage
%= ALM Coding Format:
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= mvn
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= (MF1),(MF2)[,enablefault][,round]
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= descn[fl,ls,ns,ts]
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Y-charn1[(CN1)],N1,SF1
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= n = 4 or 9
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= descn[fl,ls,ns,ts]
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Y-charn2[(CN2)],N2,SF2
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= n = 4 or 9
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
\insum {C(Y-charn1) converted and/or rescaled $\rightarrow$ C(Y-charn2)}
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= MODIFICATIONS:
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= None except au, qu, al, ql, xn for MF1 and MF2
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}

\inina
\ininz {If C(Y-char\textsl{n}2) = decimal 0, then ON; otherwise OFF}
\ininn {If a minus sign character is moved to C(Y-char\textsl{n}2), then ON; otherwise OFF}

%= Truncation
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= If low-order digit truncation occurs without rounding, then ON; otherwise
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= OFF
%= \end{flushleft}

\inino {If fixed-point integer overflow occurs, then ON; otherwise unchanged. (see NOTES)}

%= Exponent
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= overflow
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= If exponent of floating-point result exceeds +127, then ON; otherwise
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= unchanged.
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Exponent
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= underflow
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= If exponent of floating-point result is less than -128 then ON; otherwise
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= unchanged.
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= NOTES:
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= If data types are dissimilar (TN1 $\neq$ TN2), each character is high-order
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= truncated or filled, as appropriate, as it is moved. The fill data used is
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= {``}00011''b for digit characters and {``}00010''b for sign characters.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= If TN2 and S2 specify a 4-bit signed number and P = 1, then a legal plus
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= sign character in C(Y-charn1) is converted to 138 as it is moved.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= If N2 is not large enough to hold the integer part of C(Y-char n1) as
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= rescaled by SF2, an overflow condition exists; the overflow indicator is set
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= ON and an overflow fault occurs. This implies that an unsigned fixed-point
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= receiving field has a minimum length of 1 character; a signed fixed-point
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= field, 2 characters; and a floating-point field, 3 characters.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= If N2 is not large enough to hold all the given digits of C(Y-charn1) as
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= rescaled by SF2 and R = 0, then a truncation condition exists; data
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= movement stops when C(Y-charn2) is filled and the truncation indicator is
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= set ON. If R = 1, then the last digit moved is rounded according to the
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= absolute value of the remaining digits of C(Y-charn1) and the instruction
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= completes normally.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= If MFk.RL = 1, then Nk does not contain the operand length; instead, it
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= contains a register code for a register holding the operand length.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= If MFk.ID = 1, then the kth word following the instruction word does not
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= contain an operand descriptor; instead, it contains an indirect pointer to
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= the operand descriptor.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= C(Y-charn1) and C(Y-charn2) may be overlapping strings; no check is
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= made. This feature is useful for replication of substrings within a larger
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= string, but care must be exercised in the construction of the operand
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= descriptors so that sending string, C(Y-charn1), data is not inadvertently
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= destroyed. Difficulties may be encountered because of scaling factors and
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= the special treatment of sign characters and floating-point exponents.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= The user of string replication or overlaying is warned that the decimal unit
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= addresses the main memory in unaligned (not on modulo 8 boundary) units
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= of Y-block8 words and that the overlayed string, C(Y-charn2), is not
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= returned to main memory until the unit of Y-block8 words is filled or the
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= instruction completes.
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= \newpage
%= If T = 1 and the truncation indicator is set ON by execution of the
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= instruction, then a truncation (overflow) fault occurs.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= Detection of a character outside the range [0,11]8 in a digit position or a
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= character outside the range [12,l7]8 in a sign position causes an illegal
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= procedure fault.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= Attempted execution with the xed instruction causes an illegal procedure
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= fault.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= Attempted repetition with the rpt, rpd, or rpl instructions causes an
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= illegal procedure fault.
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= mvne
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Move Numeric Edited
%= \end{flushleft}
%= 
%= 
%= 
%= 024 (1)
%= 
%= 
%= 
%= \begin{flushleft}
%= FORMAT:
%= \end{flushleft}
%= 
%= 0 0 0
%= 
%= 0 1 2
%= 
%= 0 0
%= 
%= 2
%= 
%= 
%= 
%= 0 0 1 1
%= 
%= 8 9 0 1
%= 
%= \begin{flushleft}
%= MF3
%= \end{flushleft}
%= 
%= 
%= 
%= 0 0
%= 
%= 
%= 
%= 1 1
%= 
%= 7 8
%= 
%= 
%= 
%= 2 2 2 2 2
%= 
%= 0 1 2 3 4
%= 
%= 
%= 
%= \begin{flushleft}
%= MF2
%= \end{flushleft}
%= 
%= 
%= 
%= 024 (1)
%= 
%= 
%= 
%= 7
%= 
%= 2
%= 
%= \begin{flushleft}
%= Y-charn1
%= \end{flushleft}
%= 
%= 
%= 
%= 7
%= 
%= 
%= 
%= 2 2 2 3
%= 
%= 7 8 9 0
%= 
%= \begin{flushleft}
%= I
%= \end{flushleft}
%= 
%= 
%= 
%= 3
%= 
%= 5
%= 
%= \begin{flushleft}
%= MF1
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= CN1
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= a
%= \end{flushleft}
%= 
%= 
%= 
%= 10 1
%= 
%= 0 0 0 0 0 0
%= 
%= 
%= 
%= \begin{flushleft}
%= N1
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Y-char92
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= CN2
%= \end{flushleft}
%= 
%= 
%= 
%= 1
%= 
%= 2
%= 
%= 6
%= 
%= 0 0 0 0 0 0 0 0 0
%= 
%= 
%= 
%= \begin{flushleft}
%= N2
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Y-charn3
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= CN3
%= \end{flushleft}
%= 
%= 
%= 
%= 9
%= 
%= \begin{flushleft}
%= TA3 0 0 0 0 0 0 0
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= N3
%= \end{flushleft}
%= 
%= 
%= 
%= 18
%= 
%= 
%= 
%= 3
%= 
%= 
%= 
%= \begin{flushleft}
%= S1
%= \end{flushleft}
%= 
%= 
%= 
%= 2
%= 
%= 
%= 
%= 7
%= 
%= 
%= 
%= 7
%= 
%= 
%= 
%= 6
%= 
%= 
%= 
%= \begin{flushleft}
%= Figure 4-22. Move Numeric Edited (mvne) EIS Multiword Instruction Format
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= key
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= a
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= MF1
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Modification field for operand descriptor 1
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= MF2
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Modification field for operand descriptor 2
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= MF3
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Modification field for operand descriptor 3
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= I
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Interrupt inhibit bit
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Y-charn1
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Address of sending string
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= CN1
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= First character position of sending string
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= TN1
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Data type of sending string
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= S1
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Sign and decimal type of sending string
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= N1
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Length of sending string
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Y-char92
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Address of MOP control string
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= CN2
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= First character position of MOP control string
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= N2
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Length of MOP control string
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Y-charn3
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Address of receiving string
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= CN3
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= First character position of receiving string
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= TA3
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Data type of receiving string
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= \newpage
%= N3
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Length of receiving string
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= ALM Coding Format:
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= mvne
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= (MF1),(MF2),(MF3)
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= descn[fl,ls,ns,ts]
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Y-charn1[(CN1)],N1
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= desc9a
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Y-char92[(CN2)],N2
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= descna
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Y-charn3[(CN3)],N3
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= n = 4 or 9
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= n = 4, 6, or 9
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
\insum {C(Y-charn1) $\rightarrow$ C(Y-charn3) under C(Y-char92) MOP control}
\inull {See {``}Micro Operations for Edit Instructions'' later in this section for details
of editing under MOP control.}

%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= MODIFICATIONS:
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= None except au, qu, al, ql, xn for MF1, MF2, and MF3
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
\innaf
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= NOTES:
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= If data types are dissimilar (TA1 $\neq$ TA3), each character of C(Y-charn1) is
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= high-order truncated or zero filled, as appropriate, as it is moved. No
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= character conversion takes place.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= If the data type of the receiving string is not 9-bit (TA3 $\neq$ $\neq$ 0), then
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= insertion characters are high-order truncated as they are inserted.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= The maximum string length is 63. The count fields N1, N2, and N3 are
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= treated as modulo 64 numbers.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= The instruction completes normally only if N3 is the first tally to exhaust:
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= otherwise, an illegal procedure fault occurs.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= If MFk.RL = 1, then Nk does not contain the operand length; instead, it
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= contains a register code for a register holding the operand length.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= If MFk.ID = 1, then the kth word following the instruction word does not
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= contain an operand descriptor; instead, it contains an indirect pointer to
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= the operand descriptor.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= C(Y-charn1) and C(Y-charn3) may be overlapping strings; no check is
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= made. This feature is useful for replication of substrings within a larger
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= string, but care must be exercised in the construction of the operand
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= descriptors so that sending string, C(Y-charn1), data is not inadvertently
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= destroyed.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= The user of string replication or overlaying is warned that the decimal unit
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= addresses the main memory in unaligned (not on modulo 8 boundary) units
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= of Y-block8 words and that the overlayed string, C(Y-charn3), is not
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= returned to main memory until the unit of Y-block8 words is filled or the
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= instruction completes.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= Attempted execution with the xed instruction causes an illegal procedure
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= fault.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= Attempted repetition with the rpt, rpd, or rpl instructions causes an
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= illegal procedure fault.
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= \newpage

\subsubsection{EIS - Bit String Combine}

%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= csl
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Combine Bit Strings Left
%= \end{flushleft}
%= 
%= 
%= 
%= 060 (1)
%= 
%= 
%= 
%= \begin{flushleft}
%= FORMAT:
%= \end{flushleft}
%= 
%= 0 0
%= 
%= 0 1
%= 
%= 
%= 
%= 0 0
%= 
%= 4 5
%= 
%= 
%= 
%= \begin{flushleft}
%= F 0 0 0 0
%= \end{flushleft}
%= 
%= 1
%= 
%= 
%= 
%= 0 0 1 1
%= 
%= 8 9 0 1
%= 
%= \begin{flushleft}
%= BOLR
%= \end{flushleft}
%= 
%= 
%= 
%= 4
%= 
%= 
%= 
%= \begin{flushleft}
%= T 0
%= \end{flushleft}
%= 
%= 
%= 
%= 1 1 1 2
%= 
%= 7 8 9 0
%= 
%= \begin{flushleft}
%= MF2
%= \end{flushleft}
%= 
%= 
%= 
%= 4 1 1
%= 
%= \begin{flushleft}
%= Y-bit1
%= \end{flushleft}
%= 
%= 
%= 
%= 2 2
%= 
%= 3 4
%= 
%= 
%= 
%= 2 2 2
%= 
%= 7 8 9
%= 
%= 
%= 
%= 060 (1)
%= 
%= 7
%= 
%= 
%= 
%= \begin{flushleft}
%= Y-bit2
%= \end{flushleft}
%= 
%= 18
%= 
%= 
%= 
%= \begin{flushleft}
%= I
%= \end{flushleft}
%= 
%= 
%= 
%= 3
%= 
%= 5
%= 
%= \begin{flushleft}
%= MF1
%= \end{flushleft}
%= 
%= 
%= 
%= 10 1
%= 
%= 
%= 
%= 7
%= 
%= 
%= 
%= \begin{flushleft}
%= C1
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= B1
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= N1
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= C2
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= B2
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= N2
%= \end{flushleft}
%= 
%= 
%= 
%= 2
%= 
%= 
%= 
%= 4
%= 
%= 
%= 
%= 12
%= 
%= 
%= 
%= \begin{flushleft}
%= Figure 4-23. Combine Bit Strings Left (csl) EIS Multiword Instruction Format
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= F
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Fill bit for string extension
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= BOLR
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Boolean result control field
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= T
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Truncation fault enable bit
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= MF1
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Modification field for operand descriptor 1
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= MF2
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Modification field for operand descriptor 2
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= I
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Interrupt inhibit bit
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Y-bit1
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Address of sending string
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= C1
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= First character position of sending string
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= B1
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= First bit position of sending string
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= N1
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Length of sending string
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Y-bit2
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Address of receiving string
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= C2
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= First character position of receiving string
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= B2
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= First bit position of receiving string
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= N2
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Length of receiving string
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= ALM Coding Format:
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= csl
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= (MF1),(MF2)[,enablefault][,bool(octalexpression)][,fill(0$|$1)]
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= descb
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Y-bit1[(BITNO1)],N1
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= descb
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Y-bit2[(BITNO2)],N2
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
\insum {For i = bits 1, 2, ..., minimum (N1,N2)}
\inull {\hspace{1em}m = C(Y-bit1)i-1 $||$ C(Y-bit2)i-1 (a 2-bit number)}
\inull {\hspace{1em}C(BOLR)m $\rightarrow$ C(Y-bit2)i-1}
\inull {If N1 $<$ N2, then for i = N1+l, N1+2, ..., N2}
\inull {\hspace{1em}m = C(F) $||$ C(Y-bit2)i-1 (a 2-bit number)}
\inull {\hspace{1em}C(BOLR)m $\rightarrow$ C(Y-bit2)i-1}


%= MODIFICATIONS:
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= None except au, qu, al, ql, xn for MF1 and MF2
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}

\inina
\ininz {If C(Y-bit2) = 00...0, then ON; otherwise OFF}

%= 
%= 
%= 
%= \begin{flushleft}
%= Truncation
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= If N1 $>$ N2, then ON; otherwise OFF
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= NOTES:
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= If N1 $>$ N2, the low order (N1-N2) bits of C(Y-bit1) are not processed and
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= the truncation indicator is set ON.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= The bit pattern in C(BOLR) defines the Boolean operation to be performed.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= Any of the sixteen possible Boolean operations may be used. Some
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= common Boolean operations and their BOLR fields are shown below.
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Operation
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= C(BOLR)
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= MOVE
%= \end{flushleft}
%= 
%= 
%= 
%= 0011
%= 
%= 
%= 
%= \begin{flushleft}
%= AND
%= \end{flushleft}
%= 
%= 
%= 
%= 0001
%= 
%= 
%= 
%= \begin{flushleft}
%= OR
%= \end{flushleft}
%= 
%= 
%= 
%= 0111
%= 
%= 
%= 
%= \begin{flushleft}
%= NAND
%= \end{flushleft}
%= 
%= 
%= 
%= 1110
%= 
%= 
%= 
%= \begin{flushleft}
%= EXCLUSIVE OR
%= \end{flushleft}
%= 
%= 
%= 
%= 0110
%= 
%= 
%= 
%= \begin{flushleft}
%= Clear
%= \end{flushleft}
%= 
%= 
%= 
%= 0000
%= 
%= 
%= 
%= \begin{flushleft}
%= Invert
%= \end{flushleft}
%= 
%= 
%= 
%= 1100
%= 
%= 
%= 
%= \begin{flushleft}
%= If MFk.RL = 1, then Nk does not contain the operand length; instead, it
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= contains a register code for a register holding the operand length.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= If MFk.ID = 1, then the kth word following the instruction word does not
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= contain an operand descriptor; instead, it contains an indirect pointer to
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= the operand descriptor.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= C(Y-bit1) and C(Y-bit2) may be overlapping strings; no check is made. This
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= feature is useful for replication of substrings within a larger string, but
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= care must be exercised in the construction of the operand descriptors so
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= that sending string, C(Y-bit1), data is not inadvertently destroyed.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= The user of string replication or overlaying is warned that the decimal unit
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= addresses the main memory in unaligned (not on modulo 8 boundary) units
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= of Y-block8 words and that the overlayed string, C(Y-bit2), is not returned
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= to main memory until the unit of Y-block8 words is filled or the instruction
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= completes.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= If T = 1 and the truncation indicator is set ON by execution of the
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= instruction, then a truncation (overflow) fault occurs.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= Attempted execution with the xed instruction causes an illegal procedure
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= fault.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= Attempted repetition with the rpt, rpd, or rpl instructions causes an
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= illegal procedure fault.
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= csr
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= FORMAT:
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Combine Bit Strings Right
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= Same as Combine Bit Strings Left (csl) (see Figure 4-23).
%= \end{flushleft}
%= 
%= 
%= 
%= 061 (1)
%= 
%= 
%= 
%= \begin{flushleft}
%= \newpage
\insum {For i = bits 1, 2, ..., minimum (N1,N2)}
\inull {\hspace{1em}m = C(Y-bit1)N1-i $||$ C(Y-bit2)N2-i (a 2-bit number)}
\inull {\hspace{1em}C(BOLR)m $\rightarrow$ C( Y-bit2)N2-i}
\inull {If N1 $<$ N2, then for i = N1+i, N1+2, ..., N2}
\inull {\hspace{1em}m = C(F) $||$ C(Y-bit2)N2-i (a 2-bit number)}
\inull {\hspace{1em}C(BOLR)m $\rightarrow$ C( Y-bit2)N2-i}
 
%= MODIFICATIONS:
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= None except au, qu, al, ql, xn for MF1 and MF2
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}

\inina
\ininz {If C(Y-bit2) = 00\ldots0, then ON; otherwise OFF}

%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Truncation
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= If N1 $>$ N2, then ON; otherwise OFF
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= NOTES:
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= If N1 $>$ N2, the high order (N1-N2) bits of C(Y-bit1) are not processed and
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= the truncation indicator is set ON.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= The bit pattern in C(BOLR) defines the Boolean operation to be performed.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= Any of the sixteen possible Boolean operations may be used. See NOTES
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= under the Combine Bit Strings Left (csl) instruction for examples of BOLR
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= If MFk.RL = 1, then Nk does not contain the operand length; instead, it
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= contains a register code for a register holding the operand length.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= If MFk.ID = 1, then the kth word following the instruction word does not
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= contain an operand descriptor; instead, it contains an indirect pointer to
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= the operand descriptor.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= C(Y-bit1) and C(Y-bit2) may be overlapping strings; no check is made. This
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= feature is useful for replication of substrings within a larger string, but
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= care must be exercised in the construction of the operand descriptors so
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= that sending string, C(Y-bit1), data is not inadvertently destroyed.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= The user of string replication or overlaying is warned that the decimal unit
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= addresses the main memory in unaligned (not on modulo 8 boundary) units
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= of Y-block8 words and that the overlayed string, C(Y-bit2), is not returned
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= to main memory until the unit of Y-block8 words is filled or the instruction
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= completes.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= If T = 1 and the truncation indicator is set ON by execution of the
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= instruction, then a truncation (overflow) fault occurs.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= Attempted execution with the xed instruction causes an illegal procedure
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= fault.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= Attempted repetition with the rpt, rpd, or rpl instructions causes an
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= illegal procedure fault.
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= \newpage

\subsubsection{EIS - Bit String Compare}

%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= cmpb
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Compare Bit Strings
%= \end{flushleft}
%= 
%= 
%= 
%= 066 (1)
%= 
%= 
%= 
%= \begin{flushleft}
%= FORMAT:
%= \end{flushleft}
%= 
%= 0 0
%= 
%= 0 1
%= 
%= 
%= 
%= 0 0 1 1
%= 
%= 8 9 0 1
%= 
%= 
%= 
%= \begin{flushleft}
%= F 0 0 0 0 0 0 0 0 T 0
%= \end{flushleft}
%= 
%= 1
%= 
%= 
%= 
%= 1 1 1 2
%= 
%= 7 8 9 0
%= 
%= \begin{flushleft}
%= MF2
%= \end{flushleft}
%= 
%= 
%= 
%= 2 2
%= 
%= 3 4
%= 
%= 066 (1)
%= 
%= 
%= 
%= 8 1 1
%= 
%= \begin{flushleft}
%= Y-bit1
%= \end{flushleft}
%= 
%= 
%= 
%= 7
%= 
%= 
%= 
%= \begin{flushleft}
%= Y-bit2
%= \end{flushleft}
%= 
%= 
%= 
%= 2 2 2
%= 
%= 7 8 9
%= 
%= \begin{flushleft}
%= I
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= MF1
%= \end{flushleft}
%= 
%= 
%= 
%= 10 1
%= 
%= 
%= 
%= 7
%= 
%= 
%= 
%= \begin{flushleft}
%= C1
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= B1
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= N1
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= C2
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= B2
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= N2
%= \end{flushleft}
%= 
%= 
%= 
%= 18
%= 
%= 
%= 
%= 2
%= 
%= 
%= 
%= 4
%= 
%= 
%= 
%= 3
%= 
%= 5
%= 
%= 
%= 
%= 12
%= 
%= 
%= 
%= \begin{flushleft}
%= Figure 4-24. Compare Bit Strings (cmpb) EIS Multiword Instruction Format
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= F
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Fill bit for string extension
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= T
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Truncation fault enable bit
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= MF1
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Modification field for operand descriptor 1
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= MF2
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Modification field for operand descriptor 2
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= I
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Interrupt inhibit bit
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Y-bit1
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Address of left-hand string
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= C1
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= First character position of left-hand string
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= B1
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= First bit position of left-hand string
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= N1
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Length of left-hand string
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Y-bit2
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Address of right-hand string
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= C2
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= First character position of right-hand string
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= B2
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= First bit position of right-hand string
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= N2
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Length of right-hand string
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= ALM Coding Format:
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= cmpb
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= (MF1),(MF2)[,enablefault][,fill(0$|$1)]
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= descb
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Y-bit1[(BITNO1)],N1
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= descb
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Y-bit2[(BITNO2)],N2
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
\insum {For i = 1, 2, ..., minimum (N1,N2)}
\inull {\hspace{1em}C(Y-bit1)i-1 :: C(Y-bit2)i-1}
\inull {If N1 $<$ N2, then for i = N1+1, N1+2, ..., N2}
\inull {\hspace{1em}C(FILL) :: C(Y-bit2)i-1}
\inull {If N1 $>$ N2, then for i = N2+l, N2+2, ..., N1}
\inull {\hspace{1em}C(Y-bit1)i-1 :: C(FILL)}

%= MODIFICATIONS:
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= None except au, qu, al, ql, xn for MF1 and MF2
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}

\inina

\ininz {If C(Y-bit1)\tsb{i} = C(Y-bit2)\tsb{i} for all i, then ON; otherwise, OFF}

%= 
%= 
%= 
%= \begin{flushleft}
%= Carry
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= If C(Y-bit1)i $<$ C(Y-bit2)i for any i, then OFF; otherwise ON
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= NOTES:
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Instruction execution proceeds until an inequality is found or the larger
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= string length count is exhausted.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= If MFk.RL = 1, then Nk does not contain the operand length; instead, it
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= contains a register code for a register holding the operand length.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= If MFk.ID = 1, then the kth word following the instruction word does not
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= contain an operand descriptor; instead, it contains an indirect pointer to
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= the operand descriptor.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= Attempted execution with the xed instruction causes an illegal procedure
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= fault.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= Attempted repetition with the rpt, rpd, or rpl instructions causes an
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= illegal procedure fault.
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= \newpage

\subsubsection{EIS - Bit String Set Indicators}

%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= sztl
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Set Zero and Truncation Indicators with Bit
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= Strings Left
%= \end{flushleft}
%= 
%= 
%= 
%= 064 (1)

\infmt {Same as Combine Bit Strings Left (csl) (see Figure \ref{f4.23}).}

\insum {For i = bits 1, 2, ..., minimum (N1,N2)}
\inull {\hspace{1em}m = C(Y-bit1)i-1 $||$ C(Y-bit2)i-1 (a 2-bit number)}
\inull {\hspace{1em}If C(BOLR)m $\neq$ 0, then terminate}
\inull {If N1 $<$ N2, then for i = N1+i, N1+2, ..., N2}
\inull {\hspace{1em}m = C(F) $||$ C(Y-bit2)i-1 (a 2-bit number)}
\inull {\hspace{1em}If C(BOLR)m $\neq$ 0, then terminate}


%= MODIFICATIONS:
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= None except au, qu, al, ql, xn for MF1 and MF2
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}

\inina
\ininz {If C(BOLR)\tsb{m} = 0 for all i, then ON; otherwise OFF}

%= 
%= 
%= 
%= \begin{flushleft}
%= Truncation
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= If N1 $>$ N2, then ON; otherwise OFF
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= NOTES:
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= If N1 $>$ N2, the low order (N1-N2) bits of C(Y-biti) are not processed and
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= the truncation indicator is set ON.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= The execution of this instruction is identical to the Combine Bit Strings
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= Left (csl) instruction except that C(BOLR)m is not placed into C(Y-bit2)i-1.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= The bit pattern in C(BOLR) defines the Boolean operation to be performed.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= Any of the sixteen possible Boolean operations may be used. See NOTES
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= under the Combine Bit Strings Left (csl) instruction for examples of BOLR.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= If MFk.RL = 1, then Nk does not contain the operand length; instead, it
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= contains a register code for a register holding the operand length.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= If MFk.ID = 1, then the kth word following the instruction word does not
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= contain an operand descriptor; instead, it contains an indirect pointer to
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= the operand descriptor.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= If T = 1 and the truncation indicator is set ON by execution of the
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= instruction, then a truncation (overflow) fault occurs.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= Attempted execution with the xed instruction causes an illegal procedure
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= fault.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= Attempted repetition with the rpt, rpd, or rpl instructions causes an
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= illegal procedure fault.
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= sztr
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= FORMAT:
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Set Zero and Truncation Indicators with Bit
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= Strings Right
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= Same as Combine Bit Strings Left (csl) (see Figure 4-23).
%= \end{flushleft}
%= 
%= 
%= 
%= 065 (1)
%= 
%= 
%= 
%= \begin{flushleft}
%= \newpage
\insum {For i = bits 1, 2, ..., minimum (N1,N2)}
\inull {\hspace{1em}m = C(Y-bit1)N1-i $||$ C(Y-bit2)N2-i (a 2-bit number)}
\inull {\hspace{1em}If C(BOLR)m $\neq$ 0, then terminate}
\inull {If N1 $<$ N2, then for i = N1+1, N1+2, ..., N2}
\inull {\hspace{1em}m = C(F) $||$ C(Y-bit2)N2-i (a 2-bit number)}
\inull {\hspace{1em}If C(BOLR)m $\neq$ 0, then terminate}

%= MODIFICATIONS:
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= None except au, qu, al, ql, xn for MF1 and MF2
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}

\inina
\ininz {If C(BOLR)\tsb{m} = 0 for all i, then ON; otherwise OFF}

%= 
%= 
%= 
%= \begin{flushleft}
%= Truncation
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= If N1 $>$ N2, then ON; otherwise OFF
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= NOTES:
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= If N1 $>$ N2, the low order (N1-N2) bits of C(Y-bit1) are not processed and
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= the truncation indicator is set ON.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= The execution of this instruction is identical to the Combine Bit Strings
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= Right (csr) instruction except that C(BOLR)m is not placed into C(Ybit2)N2-i.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= The bit pattern in C(BOLR) defines the Boolean operation to be performed.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= Any of the sixteen possible Boolean operations may be used. See NOTES
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= under the Combine Bit Strings Left (csl) instruction for examples of BOLR.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= If MFk.RL = 1, then Nk does not contain the operand length; instead, it
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= contains a register code for a register holding the operand length.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= If MFk.ID = 1, then the kth word following the instruction word does not
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= contain an operand descriptor; instead, it contains an indirect pointer to
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= the operand descriptor.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= If T = 1 and the truncation indicator is set ON by execution of the
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= instruction, then a truncation (overflow) fault occurs.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= Attempted execution with the xed instruction causes an illegal procedure
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= fault.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= Attempted repetition with the rpt, rpd, or rpl instructions causes an
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= illegal procedure fault.
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= \newpage

\subsubsection{EIS - Data Conversion}

%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= btd
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Binary to Decimal Convert
%= \end{flushleft}
%= 
%= 
%= 
%= 301 (1)
%= 
%= 
%= 
%= \begin{flushleft}
%= FORMAT:
%= \end{flushleft}
%= 
%= 0 0
%= 
%= 0 1
%= 
%= 
%= 
%= 1 1
%= 
%= 0 1
%= 
%= 
%= 
%= \begin{flushleft}
%= P 0 0 0 0 0 0 0 0 0 0
%= \end{flushleft}
%= 
%= 1
%= 
%= 
%= 
%= 1 1
%= 
%= 7 8
%= 
%= 
%= 
%= 2 2 2 2 2
%= 
%= 0 1 2 3 4
%= 
%= 
%= 
%= \begin{flushleft}
%= MF2
%= \end{flushleft}
%= 
%= 
%= 
%= 10
%= 
%= \begin{flushleft}
%= Y-char91
%= \end{flushleft}
%= 
%= 
%= 
%= 301 (1)
%= 
%= 7
%= 
%= 
%= 
%= \begin{flushleft}
%= Y-charn2
%= \end{flushleft}
%= 
%= 
%= 
%= 2 2 2 3
%= 
%= 7 8 9 0
%= 
%= \begin{flushleft}
%= I
%= \end{flushleft}
%= 
%= 
%= 
%= 3
%= 
%= 5
%= 
%= \begin{flushleft}
%= MF1
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= CN1
%= \end{flushleft}
%= 
%= 
%= 
%= 10 1
%= 
%= 0 0 0 0 0 0 0 0 0
%= 
%= 
%= 
%= \begin{flushleft}
%= N1
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= CN2
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= a
%= \end{flushleft}
%= 
%= 
%= 
%= 9
%= 
%= 0 0 0 0 0 0
%= 
%= 
%= 
%= \begin{flushleft}
%= N2
%= \end{flushleft}
%= 
%= 
%= 
%= 18
%= 
%= 
%= 
%= \begin{flushleft}
%= S2
%= \end{flushleft}
%= 
%= 
%= 
%= 3 1
%= 
%= 
%= 
%= 2
%= 
%= 
%= 
%= 7
%= 
%= 
%= 
%= 6
%= 
%= 
%= 
%= \begin{flushleft}
%= Figure 4-25. Binary to Decimal Convert (btd)
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= EIS Multiword Instruction Format
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= key
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= P
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= 4-bit data sign character control
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= MF1
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Modification field for operand descriptor 1
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= MF2
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Modification field for operand descriptor 2
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= I
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Interrupt inhibit bit
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Y-char91
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Address of binary number
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= CN1
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= First byte position of binary number
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= N1
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Length of binary number in 9-bit bytes
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Y- charn2 Address of decimal number
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= a
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= CN2
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= First character position of decimal number
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= TN2
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Data type of decimal number
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= S2
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Sign and decimal type of decimal number
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= N2
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Length of decimal number
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= ALM Coding Format:
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= btd
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= (MF1),(MF2)
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= desc9a
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Y-char91[(CN1)],N1
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= descn[ls,ns,ts]
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Y-charn2[(CN2)],N2
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= n = 4 or 9
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
\insum {C(Y-char91) converted to decimal $\rightarrow$ C(Y-charn2)}
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= MODIFICATIONS:
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= None except au, qu, al, ql, xn for MF1 and MF2
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}

\inina
\ininz {If C(Y-char\textsl{n}2) = decimal 0, then ON: otherwise OFF}
\ininn {If a minus sign character is moved to C(Y-char\textsl{n}2), then ON; otherwise OFF}
\inino {If fixed-point integer overflow occurs, then ON; otherwise unchanged (see NOTES)}

%= NOTES:
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= C(Y-char91) contains a twos complement binary integer aligned on 9-bit
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= character boundaries with length 0 $<$ N1 $<$= 8.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= If TN2 and S2 specify a 4-bit signed number and P = 1, then if C(Y-char91)
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= is positive (bit 0 of C(Y-char91)0 = 0), then the 138 plus sign character is
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= moved to C(Y-charn2) as appropriate.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= The scaling factor of C(Y-charn2), SF2, must be 0.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= If N2 is not large enough to hold the digits generated by conversion of C(Ychar91) an overflow condition exists; the overflow indicator is set ON and
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= an overflow fault occurs.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= This implies that an unsigned fixed-point
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= receiving field has a minimum length of 1 character and a signed fixedpoint field, 2 characters.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= If MFk.RL = 1, then Nk does not contain the operand length; instead; it
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= contains a register code for a register holding the operand length.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= If MFk.ID = 1, then the kth word following the instruction word does not
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= contain an operand descriptor; instead, it contains an indirect pointer to
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= the operand descriptor.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= C(Y-char91) and C(Y-charn2) may be overlapping strings; no check is
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= made.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= Attempted conversion to a floating-point number (S2 = 0) or attempted use
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= of a scaling factor (SF2 $\neq$ 0) causes an illegal procedure fault.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= If N1 = 0 or N1 $>$ 8 an illegal procedure fault occurs.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= Attempted execution with the xed instruction causes an illegal procedure
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= fault.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= Attempted repetition with the rpt, rpd, or rpl instructions causes an
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= illegal procedure fault.
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= dtb
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Decimal to Binary Convert
%= \end{flushleft}
%= 
%= 
%= 
%= 305 (1)
%= 
%= 
%= 
%= \begin{flushleft}
%= FORMAT:
%= \end{flushleft}
%= 
%= 0
%= 
%= 0
%= 
%= 
%= 
%= 1 1
%= 
%= 0 1
%= 
%= 
%= 
%= 0 0 0 0 0 0 0 0 0 0 0
%= 
%= 11
%= 
%= \begin{flushleft}
%= Y-charn1
%= \end{flushleft}
%= 
%= 
%= 
%= 1 1
%= 
%= 7 8
%= 
%= 
%= 
%= 2 2 2 2 2
%= 
%= 0 1 2 3 4
%= 
%= 
%= 
%= \begin{flushleft}
%= MF2
%= \end{flushleft}
%= 
%= 
%= 
%= 305 (1)
%= 
%= 7
%= 
%= 
%= 
%= \begin{flushleft}
%= Y-char92
%= \end{flushleft}
%= 
%= 18
%= 
%= 
%= 
%= 2 2 2 3
%= 
%= 7 8 9 0
%= 
%= \begin{flushleft}
%= I
%= \end{flushleft}
%= 
%= 
%= 
%= 3
%= 
%= 5
%= 
%= \begin{flushleft}
%= MF1
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= CN1
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= a
%= \end{flushleft}
%= 
%= 
%= 
%= 10 1
%= 
%= 0 0 0 0 0 0
%= 
%= 
%= 
%= \begin{flushleft}
%= N1
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= CN2
%= \end{flushleft}
%= 
%= 
%= 
%= 1
%= 
%= 2
%= 
%= 6
%= 
%= 0 0 0 0 0 0 0 0 0
%= 
%= 
%= 
%= \begin{flushleft}
%= N2
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= S1
%= \end{flushleft}
%= 
%= 
%= 
%= 3
%= 
%= 
%= 
%= \begin{flushleft}
%= Figure 4-26. Decimal to Binary Convert (dtb)
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= EIS Multiword Instruction Format
%= \end{flushleft}
%= 
%= 
%= 
%= 9
%= 
%= 
%= 
%= 7
%= 
%= 
%= 
%= 6
%= 
%= 
%= 
%= \begin{flushleft}
%= \newpage
%= key
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= a
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= MF1
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Modification field for operand descriptor 1
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= MF2
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Modification field for operand descriptor 2
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= I
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Interrupt inhibit bit
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Y-charn1
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Address of decimal number
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= CN1
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= First character position of decimal number
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= TN1
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Data type of decimal number
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= S1
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Sign and decimal type of decimal number
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= N1
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Length of decimal number
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Y-char92
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Address of binary number
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= CN2
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= First byte position of binary number
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= N2
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Length of binary number in 9-bit bytes
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= ALM Coding Format:
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= dtb
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= (MF1),(MF2)
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= descn[ls,ns,ts]
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Y-charn1[(CN1)],N1
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= desc9a
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Y-char92[(CN2)],N2
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
\insum {C(Y-charn1) converted to binary $\rightarrow$ C(Y-char92)}
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= MODIFICATIONS:
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= None except au, qu, al, ql, xn for MF1 ad MF2
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}

\inina
\ininz {If C(Y-char92) = 0, then ON: otherwise OFF}
\ininn {If a minus sign character is found in C(Y-char\textsl{n}1), then ON; otherwise OFF}
\inino {If fixed-point integer overflow occurs, then ON; otherwise unchanged (see NOTES)}

%= NOTES:
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= C(Y-char92) will contain a twos complement binary integer aligned on 9-bit
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= byte boundaries with length 0 $<$ N2 $<$= 8.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= The scaling factor of C(Y-charn1), SF1, must be 0.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= If N2 is not large enough to hold the converted value of C(Y-charn1) an
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= overflow condition exists; the overflow indicator is set ON and an overflow
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= fault occurs.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= If MFk.RL = 1, then Nk does not contain the operand length; instead, it
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= contains a register code for a register holding the operand length.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= If MFk.ID = 1, then the kth word following the instruction word does not
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= contain an operand descriptor; instead, it contains an indirect pointer to
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= the operand descriptor.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= C(Y-charn1) and C(Y-char92) may be overlapping strings; no check is
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= made.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= Attempted conversion of a floating-point number (S1 = 0) or attempted use
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= of a scaling factor (SF1 $\neq$ 0) causes an illegal procedure fault.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= If N2 = 0 or N2 $>$ 8 an illegal procedure fault occurs.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= Attempted execution with the xed instruction causes an illegal procedure
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= fault.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= Attempted repetition with the rpt, rpd, or rpl instructions causes an
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= illegal procedure fault.
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= \newpage

\subsubsection{EIS - Decimal Addition}

%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= ad2d
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Add Using Two Decimal Operands
%= \end{flushleft}
%= 
%= 
%= 
%= 202 (1)
%= 
%= 
%= 
%= \begin{flushleft}
%= FORMAT:
%= \end{flushleft}
%= 
%= 0 0
%= 
%= 0 1
%= 
%= 
%= 
%= 0 0 1 1
%= 
%= 8 9 0 1
%= 
%= 
%= 
%= \begin{flushleft}
%= P 0 0 0 0 0 0 0 0 T R
%= \end{flushleft}
%= 
%= 1
%= 
%= 
%= 
%= 1 1
%= 
%= 7 8
%= 
%= 
%= 
%= 2 2 2 2 2
%= 
%= 0 1 2 3 4
%= 
%= 
%= 
%= \begin{flushleft}
%= MF2
%= \end{flushleft}
%= 
%= 
%= 
%= 8 1 1
%= 
%= \begin{flushleft}
%= Y-charn1
%= \end{flushleft}
%= 
%= 
%= 
%= 2 2 2 3
%= 
%= 7 8 9 0
%= 
%= 
%= 
%= 202 (1)
%= 
%= 7
%= 
%= 
%= 
%= 3
%= 
%= 5
%= 
%= 
%= 
%= \begin{flushleft}
%= I
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= MF1
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= N1
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= CN1
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= a
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= S1
%= \end{flushleft}
%= 
%= 
%= 
%= 10 1
%= 
%= \begin{flushleft}
%= SF1
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= CN2
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= b
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= S2
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= SF2
%= \end{flushleft}
%= 
%= 
%= 
%= 7
%= 
%= 1
%= 
%= 
%= 
%= \begin{flushleft}
%= Y-charn2
%= \end{flushleft}
%= 
%= 18
%= 
%= 
%= 
%= 3 1
%= 
%= 
%= 
%= 2
%= 
%= 
%= 
%= 1
%= 
%= \begin{flushleft}
%= N2
%= \end{flushleft}
%= 
%= 
%= 
%= 6
%= 
%= 
%= 
%= 6
%= 
%= 
%= 
%= \begin{flushleft}
%= Figure 4-27. Add Using Two Decimal Operands (ad2d)
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= EIS Multiword Instruction Format
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= key
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= a
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= P
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= 4-bit data sign character control
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= T
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Truncation fault enable bit
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= R
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Rounding flag
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= MF1
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Modification field for operand descriptor 1
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= MF2
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Modification field for operand descriptor 2
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= I
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Interrupt inhibit bit
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Y-charn1
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Address of augend (ad2d), minuend (sb2d), multiplicand (mp2d), or divisor (dv2d)
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= CN1
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= First character position of augend (ad2d), minuend (sb2d), multiplicand (mp2d),
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= or divisor (dv2d)
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= TN1
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Data type of augend (ad2d), minuend (sb2d), multiplicand (mp2d), or divisor
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= (dv2d)
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= S1
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Sign and decimal type of augend (ad2d), minuend (sb2d), multiplicand (mp2d), or
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= divisor (dv2d)
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= SF1
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Scaling factor of augend (ad2d), minuend (sb2d), multiplicand (mp2d), or divisor
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= (dv2d)
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= N1
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Length of augend (ad2d), minuend (sb2d), multiplicand (mp2d), or divisor (dv2d)
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Y- charn2 Address of addend and sum (ad2d), subtrahend and difference (sb2d), multiplier
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= and product (mp2d), or dividend and quotient (dv2d)
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= b
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= CN2
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= First character position of addend and sum (ad2d), subtrahend and difference
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= (sb2d), multiplier and product (mp2d), or dividend and quotient (dv2d)
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= TN2
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Data type of addend and sum (ad2d), subtrahend and difference (sb2d),
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= multiplier and product (mp2d), or dividend and quotient (dv2d)
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= S2
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Sign and decimal type of addend and sum (ad2d), subtrahend and difference
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= (sb2d), multiplier and product (mp2d), or dividend and quotient (dv2d)
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= \newpage
%= SF2
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Scaling factor of addend and sum (ad2d), subtrahend and difference (sb2d),
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= multiplier and product (mp2d), or dividend and quotient (dv2d)
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= N2
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Length of addend and sum (ad2d), subtrahend and difference (sb2d), multiplier
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= and product (mp2d), or dividend and quotient (dv2d)
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= ALM Coding Format:
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= ad2d
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= (MF1),(MF2)[,enablefault][,round]
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= descn[fl,ls,ns,ts]
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Y-charn1[(CN1)],N1,SF1
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= n = 4 or 9
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= descn[fl,ls,ns,ts]
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Y-charn2[(CN2)],N2,SF2
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= n = 4 or 9
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
\insum {C(Y-charn1) + C(Y-charn2) $\rightarrow$ C(Y-charn2)}
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= MODIFICATIONS:
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= None except au, qu, al, ql, xn for MF1 and MF2
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}

\inina
\ininz {If C(Y-char\textsl{n}2) = decimal 0, then ON; otherwise OFF}
\ininn {If C(Y-charn2) is negative, then ON; otherwise OFF}

%= Truncation
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= If the truncation condition exists without rounding, then ON; otherwise
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= OFF see NOTES)

\inino {If the overflow condition exists, then ON; otherwise unchanged (see NOTES)}

%= Exponent
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= overflow
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= If exponent of floating-point result exceeds 127 then ON; otherwise
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= unchanged.
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Exponent
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= underflow
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= If exponent of floating-point result is less than -128 then ON; otherwise
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= unchanged
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= NOTES:
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= If TN2 and S2 specify a 4-bit signed number and P = 1, then the 13 8 plus
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= sign character is placed appropriately if the result of the operation is
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= positive.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= If N2 is not large enough to hold the integer part of the result as scaled by
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= SF2, an overflow condition exists; the overflow indicator is set ON and an
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= overflow fault occurs. This implies that an unsigned fixed-point receiving
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= field has a minimum length of l character; a signed fixed-point field, 2
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= characters; and a floating-point field, 3 characters.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= If N2 is not large enough to hold all the digits of the result as scaled by
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= SF2 and R = 0, then a truncation condition exists; data movement stops
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= when. C(Y-charn2) is filled and the truncation indicator is set ON. If R =
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= 1, then the last digit moved is rounded according to the absolute value of
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= the remaining digits of the result and the instruction completes normally.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= If MFk.RL = 1, then Nk does not contain the operand length; instead, it
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= contains a register code for a register holding the operand length.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= If MFk.ID = 1, then the kth word following the instruction word does not
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= contain an operand descriptor; instead, it contains an indirect pointer to
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= the operand descriptor.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= C(Y-charn1) and C(Y-charn2) may be overlapping strings; no check is
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= made.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= If T = l and the truncation indicator is set ON by execution of the
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= instruction, then a truncation (overflow) fault occurs.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= Detection of a character outside the range [0,11]8 in a digit position or a
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= character outside the range [12,17]8 in a sign position causes an illegal
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= procedure fault.
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= \newpage
%= Attempted execution with the xed instruction causes an illegal procedure
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= fault.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= Attempted repetition with the rpt, rpd, or rpl instructions causes an
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= illegal procedure fault.
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= ad3d
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Add Using Three Decimal Operands
%= \end{flushleft}
%= 
%= 
%= 
%= 222 (1)
%= 
%= 
%= 
%= \begin{flushleft}
%= FORMAT:
%= \end{flushleft}
%= 
%= 0 0 0
%= 
%= 0 1 2
%= 
%= 
%= 
%= 0 0 1 1
%= 
%= 8 9 0 1
%= 
%= 
%= 
%= \begin{flushleft}
%= P 0
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= MF3
%= \end{flushleft}
%= 
%= 
%= 
%= 1 1
%= 
%= 
%= 
%= \begin{flushleft}
%= T R
%= \end{flushleft}
%= 
%= 
%= 
%= 1 1
%= 
%= 7 8
%= 
%= 
%= 
%= 2 2 2 2 2
%= 
%= 0 1 2 3 4
%= 
%= 
%= 
%= \begin{flushleft}
%= MF2
%= \end{flushleft}
%= 
%= 
%= 
%= 7 1 1
%= 
%= \begin{flushleft}
%= Y-charn1
%= \end{flushleft}
%= 
%= 
%= 
%= 2 2 2 3
%= 
%= 7 8 9 0
%= 
%= 
%= 
%= 222 (1)
%= 
%= 7
%= 
%= 
%= 
%= 3
%= 
%= 5
%= 
%= 
%= 
%= \begin{flushleft}
%= I
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= MF1
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= CN1
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= a
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= S1
%= \end{flushleft}
%= 
%= 
%= 
%= 10 1
%= 
%= \begin{flushleft}
%= SF1
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= N1
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Y-charn2
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= CN2
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= b
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= S2
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= SF2
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= N2
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Y-charn3
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= CN3
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= c
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= S3
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= SF3
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= N3
%= \end{flushleft}
%= 
%= 
%= 
%= 18
%= 
%= 
%= 
%= 3 1
%= 
%= 
%= 
%= 2
%= 
%= 
%= 
%= 7
%= 
%= 
%= 
%= 6
%= 
%= 
%= 
%= 6
%= 
%= 
%= 
%= \begin{flushleft}
%= Figure 4-28. Add Using Three Decimal Operands (ad3d)
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= EIS Multiword Instruction Format
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= key
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= a
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= P
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= 4-bit data sign character control
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= T
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Truncation fault enable bit
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= R
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Rounding flag
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= MF1
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Modification field for operand descriptor 1
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= MF2
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Modification field for operand descriptor 2
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= MF3
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Modification field for operand descriptor 3
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= I
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Interrupt inhibit bit
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Y-charn1
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Address of augend (ad3d), minuend (sb3d), multiplicand (mp3d), or divisor (dv3d)
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= CN1
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= First character position of augend (ad3d), minuend (sb3d), multiplicand (mp3d),
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= or divisor (dv3d)
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= TN1
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Data type of augend (ad3d), minuend (sb3d), multiplicand (mp3d), or divisor
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= (dv3d)
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= S1
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Sign and decimal type of augend (ad3d), minuend (sb3d), multiplicand (mp3d), or
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= divisor (dv3d)
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= SF1
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Scaling factor of augend (ad3d), minuend (sb3d), multiplicand (mp3d), or divisor
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= (dv3d)
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= N1
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Length of augend (ad3d), minuend (sb3d), multiplicand (mp3d), or divisor (dv3d)
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Y- charn2
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Address of addend (ad3d), subtrahend (sb3d), multiplier (mp3d), or dividend
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= (dv3d)
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= \newpage
%= key
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= b
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= c
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= CN2
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= First character position of addend (ad3d), subtrahend (sb3d), multiplier (mp3d),
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= or dividend (dv3d)
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= TN2
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Data type of addend (ad3d), subtrahend (sb3d), multiplier (mp3d), or dividend
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= (dv3d)
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= S2
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Sign and decimal type of addend (ad3d), subtrahend (sb3d), multiplier (mp3d), or
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= dividend (dv3d)
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= SF2
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Scaling factor of addend (ad3d), subtrahend (sb3d), multiplier (mp3d), or
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= dividend (dv3d)
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= N2
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Length of addend (ad3d), subtrahend (sb3d), multiplier (mp3d), or dividend
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= (dv3d)
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Y-charn3
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Address of sum (ad3d), difference (sb3d), product (mp3d), or quotient (dv3d)
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= CN3
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= First character position of sum (ad3d), difference (sb3d), product (mp3d), or
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= quotient (dv3d)
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= TN3
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Data type of sum (ad3d), difference (sb3d), product (mp3d), or quotient (dv3d)
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= S3
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Sign and decimal type of sum (ad3d), difference (sb3d), product (mp3d), or
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= quotient (dv3d)
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= SF3
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Scaling factor of sum (ad3d), difference (sb3d), product (mp3d), or quotient (dv3d)
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= N3
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Length of sum (ad3d), difference (sb3d), product (mp3d), or quotient (dv3d)
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= ALM Coding Format:
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= ad3d
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= (MF1),(MF2),(MF3)[,enablefault][,round]
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= descn[fl,ls,ns,ts]
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Y-charn1[(CN1)],N1,SF1
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= n = 4 or 9
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= descn[fl,ls,ns,ts]
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Y-charn2[(CN2)],N2,SF2
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= n = 4 or 9
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= descn[fl,ls,ns,ts]
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Y-charn3[(CN3)],N3,SF3
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= n = 4 or 9
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
\insum {C(Y-charn1) + C(Y-charn2) $\rightarrow$ C(Y-charn3)}
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= MODIFICATIONS:
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= None except au, qu, al, ql, xn for MF1 and MF2
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}

\inina
\ininz {If C(Y-char\textsl{n}3) = decimal 0, then ON; otherwise OFF}
\ininn {If C(Y-charn3) is negative, then ON; otherwise OFF}

%= Truncation
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= If the truncation condition exists without rounding, then ON; otherwise
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= OFF (see NOTES)

\inino {If the overflow condition exists, then ON; otherwise unchanged (see NOTES)}
 
%= Exponent
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= overflow
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= If exponent of floating-point result exceeds 127 then ON; otherwise
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= unchanged.
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Exponent
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= underflow
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= If exponent of floating-point result is less than -128 then ON; otherwise
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= unchanged
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= NOTES:
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= If TN3 and S3 specify a 4-bit signed number and P = 1, then the 13 8 plus
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= sign character is placed appropriately if the result of the operation is
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= positive.
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= \newpage
%= If N3 is not large enough to hold the integer part of the result as scaled by
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= SF3, an overflow condition exists; the overflow indicator is set ON and an
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= overflow fault occurs. This implies that an unsigned fixed-point receiving
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= field has a minimum length of 1 character; a signed fixed-point field, 2
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= characters; and a floating-point field, 3 characters.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= If N3 is not large enough to hold all the digits of the result as scaled by
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= SF3 and R = 0, then a truncation condition exists; data movement stops
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= when C(Y-charn3) is filled and the truncation indicator is set ON. If R = 1,
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= then the last digit moved is rounded according to the absolute value of the
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= remaining digits of the result and the instruction completes normally.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= If MFk.RL = 1, then Nk does not contain the operand length; instead, it
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= contains a register code for a register holding the operand length.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= If MFk.ID = 1, then the kth word following the instruction word does not
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= contain an operand descriptor; instead, it contains an indirect pointer to
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= the operand descriptor.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= C(Y-charn1), C(Y-charn2), and G(Y-charn3) may be overlapping strings; no
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= check is made.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= If T = 1 and the truncation indicator is set ON by execution of the
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= instruction, then a truncation (overflow) fault occurs.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= Detection of a character outside the range [0,11]8 in a digit position or a
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= character outside the range [12,17]8 in a sign position causes an illegal
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= procedure fault.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= Attempted execution with the xed instruction causes an illegal procedure
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= fault.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= Attempted repetition with the rpt, rpd, or rpl instructions causes an
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= illegal procedure fault.
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= \newpage

\subsubsection{EIS - Decimal Subtraction}

%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= sb2d
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Subtract Using Two Decimal Operands
%= \end{flushleft}
%= 
%= 
%= 
%= 203 (1)
%= 
%= 
%= 
%= \begin{flushleft}
%= FORMAT:
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Same as Add Using Two Decimal Operands (ad2d) (see Figure 4-27).
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
\insum {C(Y-charn1) - C(Y-charn2) $\rightarrow$ C(Y-charn2)}
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= MODIFICATIONS:
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= None except au, qu, al, ql, xn for MF1 and MF2
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}

\inina
\ininz {If C(Y-char\textsl{n}2) = decimal 0, then ON; otherwise OFF}
\ininn {If C(Y-charn2) is negative, then ON; otherwise OFF}

%= Truncation
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= If the truncation condition exists without rounding, then ON; otherwise
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= OFF (see NOTES)
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}

\inino {If the overflow condition exists, then ON; otherwise unchanged (see NOTES)}
 
%= Exponent
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= overflow
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= If exponent of floating-point result exceeds 127 then ON; otherwise
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= unchanged.
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Exponent
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= underflow
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= If exponent of floating-point result is less than -128 then ON; otherwise
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= unchanged
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= NOTES:
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= If TN2 and S2 specify a 4-bit signed number and P = 1, then the 13 8 plus
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= sign character is placed appropriately if the result of the operation is
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= positive.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= If N2 is not large enough to hold the integer part of the result as scaled by
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= SF2, an overflow condition exists; the overflow indicator is set ON and an
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= overflow fault occurs. This implies that an unsigned fixed-point receiving
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= field has a minimum length of 1 character; a signed fixed-point field, 2
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= characters; and a floating-point field, 3 characters.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= If N2 is not large enough to hold all the digits of the result as scaled by
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= SF2 and R = 0, then a truncation condition exists; data movement stops
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= when C(Y-charn2) is filled and the truncation indicator is set ON. If R = 1,
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= then the last digit moved is rounded according to the absolute value of the
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= remaining digits of the result and the instruction completes normally.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= If MFk.RL = 1, then Nk does not contain the operand length; instead, it
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= contains a register code for a register holding the operand length.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= If MFk.ID = 1, then the kth word following the instruction word does not
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= contain an operand descriptor; instead, it contains an indirect pointer to
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= the operand descriptor.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= C(Y-charn1) and C(Y-charn2) may be overlapping strings; no check is
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= made.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= If T = 1 and the truncation indicator is set ON by execution of the
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= instruction, then a truncation (overflow) fault occurs.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= Detection of a character outside the range [0,11]8 in a digit position or a
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= character outside the range [12,17]8 in a sign position causes an illegal
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= procedure fault.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= Attempted execution with the xed instruction causes an illegal procedure
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= fault.
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= \newpage
%= \newpage

\subsubsection{EIS - Decimal Multiplication}

%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= mp2d
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Multiply Using Two Decimal Operands
%= \end{flushleft}
%= 
%= 
%= 
%= 206 (1)
%= 
%= 
%= 
%= \begin{flushleft}
%= FORMAT:
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Same as Add Using Two Decimal Operands (ad2d) (see Figure 4-27).
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
\insum {C(Y-charn1) $\times$ C(Y-charn2) $\rightarrow$ C(Y-charn2)}
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= MODIFICATIONS:
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= None except au, qu, al, ql, xn for MF1 and MF2
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}

\inina
\ininz {If C(Y-char\textsl{n}2) = decimal 0, then ON; otherwise OFF}
\ininn {If C(Y-charn2) is negative, then ON; otherwise OFF}

%= Truncation
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= If the truncation condition exists without rounding, then ON; otherwise
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= OFF (see NOTES)

\inino {If the overflow condition exists, then ON; otherwise unchanged (see NOTES)}

%= Exponent
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= overflow
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= If exponent of floating-point result exceeds 127 then ON; otherwise
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= unchanged.
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Exponent
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= underflow
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= If exponent of floating-point result is less than -128 then ON; otherwise
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= unchanged
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= NOTES:
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= If TN2 and S2 specify a 4-bit signed number and P = 1, then the 13 8 plus
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= sign character is placed appropriately if the result of the operation is
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= positive.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= If N2 is not large enough to hold the integer part of the result as scaled by
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= SF2, an overflow condition exists; the overflow indicator is set ON and an
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= overflow fault occurs. This implies that an unsigned fixed-point receiving
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= field has a minimum length of 1 character; a signed fixed-point field, 2
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= characters; and a floating-point field, 3 characters.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= If N2 is not large enough to hold all the digits of the result as scaled by
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= SF2 and R = 0, then a truncation condition exists; data movement stops
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= when C(Y-charn2) is filled and the truncation indicator is set ON. If R = 1,
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= then the last digit moved is rounded according to the absolute value of the
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= remaining digits of the result and the instruction completes normally.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= If MFk.RL = 1, then Nk does not contain the operand length; instead, it
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= contains a register code for a register holding the operand length.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= If MFk.ID = 1, then the kth word following the instruction word does not
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= contain an operand descriptor; instead, it contains an indirect pointer to
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= the operand descriptor.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= C(Y-charn1) and C(Y-charn2) may be overlapping strings; no check is
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= made.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= If T = 1 and the truncation indicator is set ON by execution of the
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= instruction, then a truncation (overflow) fault occurs.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= Detection of a character outside the range [0,11]8 in a digit position or a
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= character outside the range [12,17]8 in a sign position causes an illegal
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= procedure fault.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= Attempted execution with the xed instruction causes an illegal procedure
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= fault.
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= \newpage
%= Attempted repetition with the rpt, rpd, or rpl instructions causes an
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= illegal procedure fault.
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= mp3d
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Multiply Using Three Decimal Operands
%= \end{flushleft}
%= 
%= 
%= 
%= 226 (1)
%= 
%= 
%= 
%= \begin{flushleft}
%= FORMAT:
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Same as Add Using Three Decimal Operands (ad3d) (see Figure 4-28).
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
\insum {C(Y-charn1) $\times$ C(Y-charn2) $\rightarrow$ C(Y-charn3)}
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= MODIFICATIONS:
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= None except au, qu, al, ql, xn for MF1 and MF2
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}

\inina
\ininz {If C(Y-char\textsl{n}3) = decimal 0, then ON; otherwise OFF}
\ininn {If C(Y-charn3) is negative, then ON; otherwise OFF}

%= Truncation
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= If the truncation condition exists without rounding, then ON; otherwise
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= OFF (see NOTES)

\inino {If the overflow condition exists, then ON; otherwise unchanged (see NOTES)}

%= Exponent
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= overflow
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= If exponent of floating-point result exceeds 127 then ON; otherwise
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= unchanged.
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Exponent
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= underflow
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= If exponent of floating-point result is less than -128 then ON; otherwise
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= unchanged
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= NOTES:
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= If TN3 and S3 specify a 4-bit signed number and P = 1, then the 13 8 plus
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= sign character is placed appropriately if the result of the operation is
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= positive.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= If N3 is not large enough to hold the integer part of the result as scaled by
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= SF3, an overflow condition exists; the overflow indicator is set ON and an
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= overflow fault occurs. This implies that an unsigned fixed-point receiving
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= field has a minimum length of 1 character; a signed fixed-point field, 2
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= characters; and a floating-point field, 3 characters.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= If N3 is not large enough to hold all the digits of the result as scaled by
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= SF3 and R = 0, then a truncation condition exists; data movement stops
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= when C(Y-charn3) is filled and the truncation indicator is set ON. If R = 1,
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= then the last digit moved is rounded according to the absolute value of the
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= remaining digits of the result and the instruction completes normally.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= If MFk.RL = 1, then Nk does not contain the operand length; instead, it
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= contains a register code for a register holding the operand length.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= If MFk.ID = 1, then the kth word following the instruction word does not
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= contain an operand descriptor; instead, it contains an indirect pointer to
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= the operand descriptor.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= C(Y-charn1), C(Y-charn2), and C(Y-charn3) may be overlapping strings; no
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= check is made.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= If T = 1 and the truncation indicator is set ON by execution of the
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= instruction, then a truncation (overflow) fault occurs.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= Detection of a character outside the range [0,11]8 in a digit position or a
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= character outside the range [12,17]8 in a sign position causes an illegal
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= procedure fault.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= Attempted execution with the xed instruction causes an illegal procedure
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= fault.
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= \newpage
%= Attempted repetition with the rpt, rpd, or rpl instructions causes an
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= illegal procedure fault.
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= \newpage

\subsubsection{EIS - Decimal Division}

%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= dv2d
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Divide Using Two Decimal Operands
%= \end{flushleft}
%= 
%= 
%= 
%= 207 (1)
%= 
%= 
%= 
%= \begin{flushleft}
%= FORMAT:
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Same as Add Using Two Decimal Operands (ad2d) (see Figure 4-27).
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
\insum {C(Y-charn2) / C(Y-charn1) $\rightarrow$ C(Y-charn2)}
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= MODIFICATIONS:
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= None except au, qu, al, ql, xn for MF1 and MF2
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}

\inina
\ininz {If C(Y-char\textsl{n}2) = decimal 0, then ON; otherwise OFF}
\ininn {If C(Y-charn2) is negative, then ON; otherwise OFF}
\inino {If the overflow condition exists, then ON; otherwise unchanged (see
NOTES) }


%= Exponent
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= overflow
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= If exponent of floating-point result exceeds 127 then ON; otherwise
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= unchanged.
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Exponent
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= Underflow
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= If exponent of floating-point result is less than -128 then ON; otherwise
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= unchanged
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= NOTES:
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= This instruction performs continued long division on the operands until it
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= has produced enough output digits to satisfy the requirements of the
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= quotient field. The number of required quotient digits, NQ, is determined
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= before division begins as follows:
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= 1) Floating-point quotient
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= NQ = N2, but if the divisor is greater than the dividend after operand
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= alignment, the leading zero digit produced is counted and the effective
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= precision of the result is reduced by one.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= 2) Fixed-point quotient
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= NQ = (N2-LZ2+1) - (N1-LZ1) + (E2-E1-SF2)
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= where:
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Nn = given operand field length
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= LZn = leading zero count for operand n
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= En = exponent of operand n
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= SF2 = scaling factor of quotient
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= 3) Rounding
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= If rounding is specified (R = 1), then one extra quotient digit is
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= produced.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= If C(Y-charn1) = decimal 0 or NQ $>$ 63, then division does not take place,
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= C(Y-charn2) are unchanged, and a divide check fault occurs.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= If TN2 and S2 specify a 4-bit signed number and P = 1, then the 13 8 plus
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= sign character is placed appropriately if the result of the operation is
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= positive.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= If N2 is not large enough to hold the integer part of the result as scaled by
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= SF2, an overflow condition exists; the overflow indicator is set ON and an
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= overflow fault occurs. This implies that an unsigned fixed-point receiving
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= field has a minimum length of 1 character; a signed fixed-point field, 2
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= characters; and a floating-point field, 3 characters.
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= \newpage
%= If N2 is not large enough to hold all the digits of the result as scaled by
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= SF2 and R = 0, then a truncation condition exists; data movement stops
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= when C(Y-charn2) is filled and the truncation indicator is set ON. If R = 1,
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= then the last digit moved is rounded according to the absolute value of the
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= extra quotient digit and the instruction completes normally.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= If MFk.RL = 1, then Nk does not contain the operand length; instead, it
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= contains a register code for a register holding the operand length.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= If MFk.ID = 1, then the kth word following the instruction word does not
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= contain an operand descriptor; instead, it contains an indirect pointer to
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= the operand descriptor.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= C(Y-charn1) and C(Y-charn2) may be overlapping strings; no check is
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= made.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= Detection of a character outside the range [0,11]8 in a digit position or a
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= character outside the range [12,17]8 in a sign position causes an illegal
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= procedure fault.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= Attempted execution with the xed instruction causes an illegal procedure
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= fault.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= Attempted repetition with the rpt, rpd, or rpl instructions causes an
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= illegal procedure fault.
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= dv3d
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Divide Using Three Decimal Operands
%= \end{flushleft}
%= 
%= 
%= 
%= 227 (1)
%= 
%= 
%= 
%= \begin{flushleft}
%= FORMAT:
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Same as Add Using Three Decimal Operands (ad3d) (see Figure 4-28).
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
\insum {C(Y-charn2) / C(Y-charn1) $\rightarrow$ C(Y-charn3)}
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= MODIFICATIONS:
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= None except au, qu, al, ql, xn for MF1 and MF2
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}

\inina
\ininz {If C(Y-char\textsl{n}3) = decimal 0, then ON; otherwise OFF}
\ininn {If C(Y-charn3) is negative, then ON; otherwise OFF}
\inino {If the overflow condition exists, then ON; otherwise unchanged (see
NOTES)}

%= Exponent
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= overflow
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= If exponent of floating-point result exceeds 127 then ON; otherwise
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= unchanged.
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Exponent
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= underflow
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= If exponent of floating-point result is less than -128 then ON; otherwise
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= unchanged
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= NOTES:
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= This instruction performs continued long division on the operands until it
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= has produced enough output digits to satisfy the requirements of the
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= quotient field. The number of required quotient digits, NQ, is determined
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= before division begins as follows:
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= 1) Floating-point quotient
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= NQ = N3, but if the divisor is greater than the dividend after operand
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= alignment, the leading zero digit produced is counted and the effective
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= precision of the result is reduced by one.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= 2) Fixed-point quotient
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= NQ = (N2-LZ2+1) - (N1-LZ1) + (E2-E1-SF3)
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= \newpage
%= where:
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Nn = given operand field length
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= LZn = leading zero count for operand n
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= En = exponent of operand n
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= SF3 = scaling factor of quotient
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= 3) Rounding
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= If rounding is specified (R = 1), then one extra quotient digit is
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= produced.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= If C(Y-charn1) = decimal 0 or NQ $>$ 63, then division does not take place,
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= C(Y-charn3) are unchanged, and a divide check fault occurs.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= If TN3 and S3 specify a 4-bit signed number and P = 1 , then the 138 plus
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= sign character is placed appropriately if the result of the operation is
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= positive.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= If N3 is not large enough to hold the integer part of the result as scaled by
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= SF3, an overflow condition exists; the overflow indicator is set ON and an
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= overflow fault occurs. This implies that an unsigned fixed-point receiving
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= field has a minimum length of 1 character; a signed fixed-point field, 2
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= characters; and a floating-point field, 3 characters.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= If N3 is not large enough to hold all the digits of the result as scaled by
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= SF3 and R = 0, then a truncation condition exists; data movement stops
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= when C(Y-charn3) is filled and the truncation indicator is set ON. If R = 1,
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= then the last digit moved is rounded according to the absolute value of the
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= extra quotient digit and the instruction completes normally.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= If MFk.RL = 1, then Nk does not contain the operand length; instead, it
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= contains a register code for a register holding the operand length.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= If MFk.ID = 1, then the kth word following the instruction word does not
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= contain an operand descriptor; instead, it contains an indirect pointer to
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= the operand descriptor.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= C(Y-charn1), G(Y-charn2), and C(Y-charn3) may be overlapping strings; no
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= check is made.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= Detection of a character outside the range [0,11]8 in a digit position or a
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= character outside the range [12,17]8 in a sign position causes an illegal
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= procedure fault.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= Attempted execution with the xed instruction causes an illegal procedure
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= fault.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= Attempted repetition with the rpt, rpd, or rpl instructions causes an
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= illegal procedure fault.
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= \newpage

\subsubsection{MICRO OPERATIONS FOR EDIT INSTRUCTIONS}

%= \end{flushleft}
%= 
%= \begin{flushleft}
%= The Move Alphanumeric Edited (mve) and Move Numeric Edited (mvne) instructions require
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= micro operations to perform the editing functions in an efficient manner. The sequence of micro
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= operation steps to be executed is contained in main memory and is referenced by the second
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= operand descriptor of the mve or mvne instructions. Some of the micro operations require special
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= characters for insertion into the string of characters being edited. These special characters are
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= shown in the {``}Edit Insertion Table'' discussion below.
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}

\subsubsection{Micro Operation Sequence}

%= \end{flushleft}
%= 
%= \begin{flushleft}
%= The micro operation string operand descriptor points to a string of 9-bit bytes that specify
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= the micro operations to be performed during an edited move. Each of the 9-bit bytes defines a
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= micro operation and has the following format:
%= \end{flushleft}
%= 
%= 0
%= 
%= 0
%= 
%= 
%= 
%= 0 0
%= 
%= 4 5
%= 
%= \begin{flushleft}
%= MOP
%= \end{flushleft}
%= 
%= 
%= 
%= 0
%= 
%= 8
%= 
%= \begin{flushleft}
%= IF
%= \end{flushleft}
%= 
%= 
%= 
%= 5
%= 
%= 
%= 
%= 4
%= 
%= 
%= 
%= \begin{flushleft}
%= Figure 4-29. Micro Operation (MOP) Character Format
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= MOP
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= 5-bit code specifying the micro operator
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= IF
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Information field containing one of the following:
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= 1) A sending string character count. A value of 0 is interpreted as 16.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= 2) The index of an entry in the edit insertion table to be used. Permissible values
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= are 1 through 8.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= 3) An interpretation of the {``}blank-when-zero'' operation
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}

\subsubsection{Edit Insertion Table}

%= \end{flushleft}
%= 
%= \begin{flushleft}
%= While executing an edit instruction, the processor provides a register of eight 9-bit bytes to
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= hold insertion information. This register, called the edit insertion table, is not maintained after
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= execution of an edit instruction. At the start of each edit instruction, the processor initializes the
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= table to the values given in Table 4-8, where each symbol refers to the corresponding standard
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= ASCII character.
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Table 4-8. Default Edit Insertion Table Characters
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= Table Entry
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= Number
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Character
%= \end{flushleft}
%= 
%= 
%= 
%= 1
%= 
%= 
%= 
%= \begin{flushleft}
%= blank
%= \end{flushleft}
%= 
%= 
%= 
%= 2
%= 
%= 
%= 
%= *
%= 
%= 
%= 
%= 3
%= 
%= 
%= 
%= +
%= 
%= 
%= 
%= 4
%= 
%= 
%= 
%= -
%= 
%= 
%= 
%= 5
%= 
%= 
%= 
%= \$
%= 
%= 
%= 
%= 6
%= 
%= 
%= 
%= ,
%= 
%= 
%= 
%= \begin{flushleft}
%= \newpage
%= Table Entry
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= Number
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Character
%= \end{flushleft}
%= 
%= 
%= 
%= 7
%= 
%= 
%= 
%= .
%= 
%= 
%= 
%= 8
%= 
%= 
%= 
%= \begin{flushleft}
%= 0 (zero)
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= One or all of the table entries can be changed by the Load Table Entry (lte) or the Change
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= Table (cht) micro operations to provide different insertion characters.
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}

\subsubsection{Edit Flags}

%= \end{flushleft}
%= 
%= \begin{flushleft}
%= The processor provides the following four edit flags for use by the micro operations.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= ES
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= End suppression flag; initially OFF and set ON by a micro operation when zero
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= suppression ends.
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= SN
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Sign flag; initially set OFF if the sending string is alphanumeric or unsigned numeric. If
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= the sending string is signed numeric, the sending string sign character is tested and SN
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= is set OFF if positive, and ON if negative.
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Z
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Zero flag; initially set ON. It is set OFF whenever a sending string character that is not
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= decimal zero is moved into the receiving string.
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= BZ
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Blank-when-zero flag; initially set OFF and is set ON by either the enf or ses micro
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= operation. If, at the completion of a move, both the Z and BZ are ON, the receiving
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= string is filled with character 1 of the edit insertion table.
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}

\subsubsection{Terminating Micro Operations}

%= \end{flushleft}
%= 
%= \begin{flushleft}
%= The micro operation sequence is terminated normally when the receiving string length
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= becomes exhausted. The micro operation sequence is terminated abnormally (with an illegal
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= procedure fault) if a move from an exhausted sending string or the use of an exhausted MOP string
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= is attempted.
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}

\subsubsection{MVNE and MVE Differences}

%= \end{flushleft}
%= 
%= \begin{flushleft}
%= The processor executes mvne in a slightly different manner than it executes mve. This is due
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= to the inherent differences in the way numeric and alphanumeric data are handled. The following
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= are brief descriptions of the hardware operations for mvne and mve.
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}

\subsubsubsection{Numeric Edit}

%= \end{flushleft}
%= 
%= \begin{flushleft}
%= 1. Load the entire sending string number (maximum length 63 characters) into the decimal unit
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= input buffer as 4-bit digits (high-order truncating 9-bit data). Strip the sign and exponent
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= characters (if any), put them aside into special holding registers and decrease the input
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= buffer count accordingly.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= 2. Test sign and, if required, set the SN flag.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= 3. Execute micro operation string, starting with first (4-bit) digit.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= 4. If an edit insertion table entry or MOP insertion character is to be stored, ANDed, or ORed
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= into a receiving string of 4- or 6-bit characters, high-order truncate the character
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= accordingly.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= 5. If the receiving string is 9-bit characters, high-order fill the (4-bit) digits from the input
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= buffer with bits 0-4 of character 8 of the edit insertion table. If the receiving string is 6-bit
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= characters, high-order fill the digits with {``}00''b.
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= \newpage

\subsubsubsection{Alphanumeric Edit}

%= \end{flushleft}
%= 
%= \begin{flushleft}
%= 1. Load decimal unit input buffer with sending string characters. Data is read from main
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= memory in unaligned units (not modulo 8 boundary) of Y-block8 words. The number of
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= characters loaded is the minimum of the remaining sending string count, the remaining
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= receiving string count, and 64.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= 2. Execute micro operation string, starting with the first receiving string character.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= 3. If an edit insertion table entry or MOP insertion character is to be stored, ANDed, or ORed
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= into a receiving string of 4- or 6-bit characters, high-order truncate the character
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= accordingly.
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}

\subsubsection{Micro Operations}

%= \end{flushleft}
%= 
%= \begin{flushleft}
%= A description of the 17 micro operations (MOPs) follows. The mnemonic, name, octal value,
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= and the function performed is given for each MOP in a format similar to that for processor
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= instructions. These micro operations are included in the alphabetic list of instructions in Appendix
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= B, identified by the code MOP.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= Checks for termination are made during and after each micro operation. All MOPs that
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= make a zero test of a sending string character test only the four least significant bits of the
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= character.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= The following additional abbreviations and symbols are used in the description of the MOPs.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= EIT
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= edit insertion table
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= pin
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= current position in the sending string
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= pmop
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= current position in the micro operation string
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= pout
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= current position in the receiving string
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= After each MOP, add one to pmop.
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= cht
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Change Table
%= \end{flushleft}
%= 
%= 
%= 
%= 21
%= 
%= 
%= 
\insum {For i = 1, 2, ..., 8}
\inull {\hspace{1em}C(Y-char92)pmop+i $\rightarrow$ C(EIT)i}
\inull {pmop = pmop + 8}
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
\innaf
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= NOTES:
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= C(IF) is not interpreted for this operation.
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= enf
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= End Floating Suppression
%= \end{flushleft}
%= 02
%= 
%= \begin{flushleft}
\insum {If C(IF)0 = 0, then}
\inull {\hspace{1em}If ES is OFF, then}
\inull {\hspace{2em}If SN is OFF, then C(EIT)3 $\rightarrow$ C(Y-charn3)pout}
\inull {\hspace{2em}If SN is ON, then C(EIT)4 $\rightarrow$ C(Y-charn3)pout}
\inull {\hspace{2em}pout = pout + 1}
\inull {\hspace{2em}ES set ON}
\inull {\hspace{1em}If ES is ON, then no action}
\inull {If C(IF)0 = 1, then}
\inull {\hspace{1em}If ES is OFF, then}
\inull {\hspace{2em}C(EIT)5 $\rightarrow$ C(Y-charn3)pout}
\inull {\hspace{2em}pout = pout + 1}
\inull {\hspace{2em}ES set ON}
\inull {\hspace{1em}If ES is ON, then no action}
\inull {If C(IF)1 = 1, then BZ set ON; otherwise no action}

%= FLAGS:
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= (Flags not listed are not affected)
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= ES
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= If OFF, then set ON
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= BZ
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= If C(IF) = 1, then set ON; otherwise no change
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= ign
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Ignore Source Character
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
\insum {pin = pin + C(IF)}
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
\innaf
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= insa
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Insert Asterisk on Suppression
%= \end{flushleft}
%= 
%= \begin{flushleft}
\insum {If ES is OFF, then}
\inull {\hspace{1em}C(EIT)2 $\rightarrow$ C(Y-charn3)pout}
\inull {\hspace{1em}If C(IF) = 0, then pmop = pmop}
\inull {f ES is ON, then}
\inull {\hspace{1em}If C(IF) $\neq$ 0, then}
\inull {\hspace{2em}m = C(IF)}
\inull {\hspace{2em}C(EIT)m $\rightarrow$ C(Y-charn3)pout}
\inull {\hspace{1em}If C(IF) = 0, then}
\inull {\hspace{2em}C(Y-char92)pmop+1 $\rightarrow$ C(Y-charn3)pout}
\inull {\hspace{2em}pmop = pmop + 1}
\inull {pout = pout + 1}


%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
\innaf
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= NOTES:
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= If C(IF) $>$ 8 an illegal procedure fault occurs.
%= \end{flushleft}
%= 
%= 
%= 
%= 14
%= 
%= 
%= 
%= 11
%= 
%= 
%= 
%= \begin{flushleft}
%= \newpage
%= insb
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Insert Blank on Suppression
%= \end{flushleft}
%= 
%= 
%= 
%= 10
%= 
%= 
%= 
%= \begin{flushleft}
\insum {If ES is OFF, then}
\inull {\hspace{1em}C(EIT)1 $\rightarrow$ C(Y-charn3)pout}
\inull {\hspace{1em}If C(IF) = 0, then pmop = pmop + 1}
\inull {If ES is ON, then}
\inull {\hspace{1em}If C(IF) $\neq$ 0, then}
\inull {\hspace{2em}m = C(IF)}
\inull {\hspace{2em}C(EIT)m $\rightarrow$ C(Y-charn3)pout}
\inull {\hspace{1em}If C(IF) = 0, then}
\inull {\hspace{2em}C(Y-char92)pmop+1 $\rightarrow$ C(Y-charn3)pout}
\inull {\hspace{2em}pmop = pmop + 1}
\inull {pout = pout + 1}
\innaf

%= NOTES:
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= If C(IF) $>$ 8 an illegal procedure fault occurs.
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= insm
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Insert Table Entry One Multiple
%= \end{flushleft}
%= 
%= 
%= 
%= 01
%= 
%= 
%= 
%= \begin{flushleft}
\insum {For i = 0, 1, ..., C(IF) - 1}
\inull {\hspace{1em}C(EIT)1 $\rightarrow$ C(Y-charn3)pout+i}
\inull {pout = pout + C(IF)}

%= FLAGS:
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= insn
%= \end{flushleft}
%= 
%= \begin{flushleft}
\innaf
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Insert On Negative
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= If SN is OFF, then
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= C(EIT)1 $\rightarrow$ C(Y-charn3)pout
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= If C(IF) = 0, then pmop = pmop + 1
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= If SN is ON, then
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= If C(IF) $\neq$ 0, then
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= m = C(IF)
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= C(EIT)m $\rightarrow$ C(Y-charn3)pout
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= If C(IF) = 0, then
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= C(Y-char92)pmop+1 $\rightarrow$ C(Y-charn3)pout
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= pmop = pmop + 1
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= pout = pout + 1
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
\innaf
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= NOTES:
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= If C(IF) $>$ 8 an illegal procedure fault occurs.
%= \end{flushleft}
%= 
%= 
%= 
%= 12
%= 
%= 
%= 
%= \begin{flushleft}
%= \newpage
%= insp
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Insert On Positive
%= \end{flushleft}
%= 
%= 
%= 
%= 13
%= 
%= 
%= 
%= \begin{flushleft}
\insum {If SN is ON, then}
\inull {\hspace{1em}C(EIT)1 $\rightarrow$ C(Y-charn3)pout}
\inull {\hspace{1em}If C(IF) = 0, then pmop = pmop + 1}
\inull {If SN is OFF, then}
\inull {\hspace{1em}If C(IF) $\neq$ 0, then}
\inull {\hspace{2em}m = C(IF)}
\inull {\hspace{2em}C(EIT)m $\rightarrow$ C(Y-charn3)pout}
\inull {\hspace{1em}If C(IF) = 0, then}
\inull {\hspace{2em}C(Y-char92)pmop+1 $\rightarrow$ C(Y-charn3)pout}
\inull {\hspace{2em}pmop = pmop + 1}
\inull {pout = pout + 1}
\innaf
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= NOTES:
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= If C(IF) $>$ 8 an illegal procedure fault occurs.
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= lte
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Load Table Entry
%= \end{flushleft}
%= 
%= 
%= 
%= 20
%= 
%= 
%= 
%= \begin{flushleft}
\insum {m = C(IF)}
\inull {C(Y-char92)pmop+1 $\rightarrow$ C(EIT)m}
\inull {pmop = pmop + 1}

%= 
%= \begin{flushleft}
\innaf
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= NOTES:
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= If C(IF) = 0 or C(IF) $>$ 8 an illegal procedure fault occurs.
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= mflc
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Move with Floating Currency Symbol Insertion
%= \end{flushleft}
%= 
%= \begin{flushleft}
\insum {For i = 0, 1, ..., C(IF) - 1}
\inull {\hspace{1em}If ES is ON, then C(Y-charn1)pin+i $\rightarrow$ C(Y-charn3)pout+i}
\inull {\hspace{1em}If ES is OFF and C(Y-charn1)pin+i = decimal 0, then}
\inull {\hspace{2em}C(EIT)1 $\rightarrow$ C(Y-charn3)pout+i}
\inull {\hspace{1em}If ES is OFF and C(Y-charn1)pin+i $\neq$ decimal 0, then}
\inull {\hspace{2em}C(EIT)5 $\rightarrow$ C(Y-charn3)pout+i}
\inull {\hspace{2em}C(Y-charn1)pin+i $\rightarrow$ C(Y-charn3)pout+i+1}
\inull {\hspace{2em}pout = pout + 1}
\inull {\hspace{2em}ES set ON}
\inull {pin = pin + C(IF)}
\inull {pout = pout + C(IF)}
%= 
%= 
%= 
%= 07
%= 
%= 
%= 
%= \begin{flushleft}
%= \newpage
%= FLAGS:
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= (Flags not listed are not affected)
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= ES
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= If OFF and any of C(Y-charn1)pin+i $\neq$ decimal 0, then ON; otherwise
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= unchanged
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Z
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= See the {``}Edit Flags'' section.
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= NOTES:
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= mfls
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= The number of characters moved to the receiving string is data dependent.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= If the entire C(Y-charn1) are decimal 0s, C(IF) characters are moved to
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= C(Y-charn3). However, if the sending string contains a non-zero character,
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= then C(IF)+1 characters are moved to C(Y-charn3); the insertion character
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= plus C(Y-charn1). A possible illegal procedure fault due to this condition
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= may be avoided by assuring that the Z and BZ flags are ON.
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Move with Floating Sign Insertion
%= \end{flushleft}
%= 
%= 
%= 
%= 06
%= 
%= 
%= 
%= \begin{flushleft}
\insum {For i = 0, 1, ..., C(IF) - 1}
\inull {\hspace{1em}If ES is ON, then C(Y-charn1)pin+i $\rightarrow$ C(Y-charn3)pout+i}
\inull {\hspace{1em}If ES is OFF and C(Y-charn1)pin+i = decimal 0, then}
\inull {\hspace{2em}C(EIT)1 $\rightarrow$ C(Y-charn3)pout+i}
\inull {\hspace{1em}If ES is OFF and C(Y-charn1)pin+i $\neq$ decimal 0, then}
\inull {\hspace{2em}If SN is OFF, then C(EIT)3 $\rightarrow$ C(Y-charn3)pout+i}
\inull {\hspace{2em}If SN is ON, then C(EIT)4 $\rightarrow$ C(Y-charn3)pout+i}
\inull {\hspace{2em}C(Y-charn1)pin+i $\rightarrow$ C(Y-charn3)pout+i+1}
\inull {\hspace{2em}pout = pout + 1}
\inull {\hspace{2em}ES set On}
\inull {pin = pin + C(IF)}
\inull {pout = pout + C(IF)}
 
%= FLAGS:
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= (Flags not listed are not affected)
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= ES
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= If OFF and any of C(Y-charn1)pin+i $\neq$ decimal 0, then ON; otherwise
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= unchanged
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Z
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= See the {``}Edit Flags'' section
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= NOTES:
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= mors
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= The number of characters moved to the receiving string is data dependent.
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= If the entire C(Y-charn1) are decimal 0s, C(IF) characters are moved to
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= C(Y-charn3). However, if the sending string contains a non-zero character,
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= then C(IF)+1 characters are moved to C(Y-charn3); the insertion character
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= plus C(Y-charn1) A possible illegal procedure fault due to this condition
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= may be avoided by assuring that the Z and BZ flags are ON.
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Move and OR Sign
%= \end{flushleft}
%= 
%= \begin{flushleft}
\insum {For i = 0, 1, ..., C(IF) - 1}
\inull {\hspace{1em}If SN is OFF, then}
\inull {\hspace{2em}C(Y-charn1)pin+i $|$ C(EIT)3 $\rightarrow$ C(Y-charn3)pout+i}
\inull {\hspace{1em}If SN is ON, then}
\inull {\hspace{2em}C(Y-charn1)pin+i $|$ C(EIT)4 $\rightarrow$ C(Y-charn3)pout+i}
\inull {pin = pin + C(IF)}
\inull {pout = pout + C(IF)}



%= \end{flushleft}
%= 
%= \begin{flushleft}
%= FLAGS:
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= Z
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= mses
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= (Flags not listed are not affected)
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= See the {``}Edit Flags'' section
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Move and Set Sign
%= \end{flushleft}
%= 
%= 
%= 
%= 16
%= 
%= 
%= 
\insum {\textbf{\textsl{For mvne}}}
\inull {For i = 0, 1, ..., C(IF) - 1}
\inull {\hspace{1em}C(Y-charn1)pin+i $\rightarrow$ C(Y-charn3)pout+i}
\inull {pin = pin + C(IF)}
\inull {pout = pout + C(IF)}
\inull {\hspace{1em}\textbf{\textsl{For mve}}}
\inull {C(Z) = 0}
\inull {For i = 0, 1, ..., C(IF) - 1}
\inull {\hspace{1em}C(Y-charn1)pin+i $\rightarrow$ C(Y-charn3)pout+i}
\inull {\hspace{1em}If C(Z) = 0, then}
\inull {\hspace{2em}(Z) = C(Y-charn1)pin+i \& C(EIT)3}
\inull {\hspace{1em}If C(Z) = 0, then}
\inull {\hspace{2em}C(Z) = C(Y-charn1)pin+i \& C(EIT)4}
\inull {\hspace{1em}If C(Z) $\neq$ 0, then SN set ON}
\inull {pin = pin + C(IF)}
\inull {pout = pout + C(IF)}



%= FLAGS:
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= (Flags not listed are not affected)
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= SN
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= If C(EIT)4 found in C(Y-charn1), then ON; otherwise no change
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Z
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= See the {``}Edit Flags'' section
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= mvc
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Move Source Characters
%= \end{flushleft}
%= 
%= \begin{flushleft}
\insum {For i = 0, 1, ..., C(IF) - 1}
\inull {\hspace{1em}C(Y-charn1)pin+i $\rightarrow$ C(Y-charn3)pout+i}
\inull {pin = pin + C(IF)}
\inull {pout = pout + C(IF)}
 
%= FLAGS:
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= Z
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= (Flags not listed are not affected)
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= See the {``}Edit Flags'' section
%= \end{flushleft}
%= 
%= 
%= 
%= 15
%= 
%= 
%= 
%= \begin{flushleft}
%= \newpage
%= mvza
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Move with Zero Suppression and Asterisk
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= Replacement
%= \end{flushleft}
%= 
%= 
%= 
%= 05
%= 
%= 
%= 
%= \begin{flushleft}
\insum {For i = 0, 1, ..., C(IF) - 1}
\inull {\hspace{1em}If ES is ON, then C(Y-charn1)pin+i $\rightarrow$ C(Y-charn3)pout+i}
\inull {\hspace{1em}If ES is OFF and C(Y-charn1)pin+i = decimal 0, then}
\inull {\hspace{2em}C(EIT)2 $\rightarrow$ C(Y-charn3)pout+i}
\inull {\hspace{1em}If ES is OFF and C(Y-charn1)pin+i $\neq$ decimal 0, then}
\inull {\hspace{2em}C(Y-charn1)pin+i $\rightarrow$ C(Y-charn3)pout+i}
\inull {\hspace{2em}ES set On}
\inull {pin = pin + C(IF)}
\inull {pout = pout + C(IF)}
 
%= FLAGS:
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= (Flags not listed are not affected)
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= ES
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= If OFF and any of C(Y-charn1)pin+i $\neq$ decimal 0, then ON; otherwise
%= \end{flushleft}
%= 
%= \begin{flushleft}
%= unchanged
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= Z
%= \end{flushleft}
%= 
%= 
%= 
%= \begin{flushleft}
%= See the {``}Edit Flags'' section
%= \end{flushleft}
%= 
%= 
%= 




\ins {mvzb} {Move with Zero Suppression and Blank Replacement} {04}
\insum {For i = 0, 1, ..., C(IF) - 1}
\inull {\hspace{1em}If ES is ON, then C(Y-charn1)pin+i $\rightarrow$ C(Y-charn3)pout+i}
\inull {\hspace{1em}If ES is OFF and C(Y-charn1)pin+i = decimal 0, then}
\inull {\hspace{2em}C(EIT)1 $\rightarrow$ C(Y-charn3)pout+i}
\inull {\hspace{1em}If ES is OFF and C(Y-charn1)pin+i $\neq$ decimal 0, then}
\inull {\hspace{2em}C(Y-charn1)pin+i $\rightarrow$ C(Y-charn3)pout+i}
\inull {\hspace{2em}ES set ON}
\inull {\hspace{1em}pin = pin + C(IF)}
\inull {\hspace{1em}pout = pout + C(IF)}
\inlbl {FLAGS:} {(Flags not listed are not affected)}
\inlbl {\hspace{1em}ES} { If OFF and any of C(Y-charn1)pin+i $\neq$ decimal 0, then ON; otherwise}
\inlbl {\hspace{1em}Z} {See the {``}Edit Flags'' section}


\ins {ses} {Set End Suppression} {03}
\insum {If C(IF)0 = 0, then ES set OFF}
\inull {If C(IF)0 = 1, then ES set ON}
\inull {If C(IF)1 = 1, then BZ set ON; otherwise no action}
\inlbl {FLAGS:} {(Flags not listed are not affected)}
\inlbl {\hspace{1em}ES} {Set by this micro operation}
\inlbl {\hspace{1em}BZ} {If C(IF)1 = 1, then ON; otherwise no change}

\subsubsection{Micro Operation Code Assignment Map}

Operation code assignments for the micro operations are shown in Table 4-9. A dash (----)
indicates an unassigned code. All unassigned codes cause an illegal procedure fault.

\begin{table}[H]
\begin{center}
\caption {Micro Operation Code Assignment Map}
\label{t4.9}
\begin{tabular}{|c|c|c|c|c|c|c|c|c|}
\hline
 & \textit{\textbf{0}} & \textit{\textbf{1}} & \textit{\textbf{2}} & \textit{\textbf{3}} & \textit{\textbf{4}} & \textit{\textbf{5}} & \textit{\textbf{6}} & \textit{\textbf{7}}\\
\hline
\textit{\textbf{00)}} &
\texttt{----} &
\texttt{insm} &
\texttt{enf} &
\texttt{ses} &
\texttt{mvzb} &
\texttt{mvza} &
\texttt{mfls} &
\texttt{mflc} \\

\textit{\textbf{10)}} &
\texttt{insb} &
\texttt{insa} &
\texttt{insn} &
\texttt{insp} &
\texttt{ign} &
\texttt{mcv} &
\texttt{mses} &
\texttt{mors} \\

\textit{\textbf{20)}} &
\texttt{lte} &
\texttt{cht} &
\texttt{----} &
\texttt{----} &
\texttt{----} &
\texttt{----} &
\texttt{----} &
\texttt{----} \\

\textit{\textbf{30)}} &
\texttt{----} &
\texttt{----} &
\texttt{----} &
\texttt{----} &
\texttt{----} &
\texttt{----} &
\texttt{----} &
\texttt{----} \\

\hline
\end{tabular}
\end{center}
\end{table}

