\section{PROGRAM ACCESSIBLE REGISTERS}

A processor register is a hardware assembly that holds information for use in
some specified way. An accessible register is a register whose contents are
available to the user for his purposes. Some accessible registers are
explicitly addressed by particular instructions, some are implicitly referenced
during the course of execution of instructions, and some are used in both ways.
The accessible registers are listed in Table 3-1. See Section 4 for a
discussion of each instruction to determine the way in which the registers are
used.

Table 3-1. Processor Registers

Register name Mnemonic Length (bits) Quantity

Accumulator Register A 36 1

Quotient Register Q 36 1

Accumulator-Quotient Register (a) AQ 72 1

Exponent Register E 8 1

Exponent-Accumulator-Quotient Register (a) EAQ 80 1

Index Registers Xn 18 8

Indicator Register IR 14 1

Base Address Register BAR 18 1

Timer Register TR 27 1

Ring Alarm Register RALR 3 1

Pointer Registers PRn 42 8

Address Registers ARn 24 8

Procedure Pointer Register (b) PPR 37 1

Temporary Pointer Register (b) TPR 42 1

Descriptor Segment Base Register DSBR 51 1

Segment Descriptor Word Associative Memory SDWAM 88 16

Page Table Word Associative Memory PTWAM 51 16

Fault Register FR 35 1

Mode Register MR 33 1

Cache Mode Register CMR 28 1

Control Unit (CU) History Register 72 16

Operations Unit (OU) History Register 72 16

Decimal Unit (DU) History Register 72 16

Appending Unit (APU) History Register 72 16

Configuration Switch Data 36 5

Control Unit Data 288 1

Decimal Unit Data 288 1


(a)This register is not a separate physical assembly but is a combination of
its constituent registers.

(b)This register is not explicitly addressable, but is included because of its
vital role in instruction and operand address preparation.

In the descriptions that follow, the diagrams given for register formats do not
imply that a physical assembly possessing the pictured bit pattern exists.  The
diagram is a graphic representation of the form of the register data as it
appears in main memory when the register contents are stored or how data bits
must be assembled for loading into the register.

If the diagrams contain the characters {``}x'' or {``}0'', the values of the
bits in the positions shown are irrelevant to the register. Bits pictured as
{``}x'' are not changed when the register is stored. Bits pictured as {``}0''
are set to 0 when the register is stored. Neither {``}x'' bits or {``}0'' bits
are loaded into the register.


\subsection{ACCUMULATOR REGISTER (A)}

Format: - 36 bits

Figure 3-1. Accumulator Register (A) Format

Description:

A 36-bit physical register located in the operations unit.

Function:

In fixed-point binary instructions, holds operands and results.

In floating-point binary instructions, holds the most significant part of the
mantissa.

In shifting instructions, holds original data and shifted results.

In address preparation, may hold two logically independent word offsets,
A-upper and Alower, or an extended range bit- or character-string length.

\subsection{QUOTIENT REGISTER (Q)}

Format: - 36 bits

Figure 3-2. Quotient Register (Q) Format

Description:

A 36-bit physical register located in the operations unit.

Function:

In fixed-point binary instructions, holds operands and results.

In floating-point binary instructions, holds the least significant part of the
mantissa.

In shifting instructions, holds original data and shifted results.

In address preparation, may hold two logically independent word offsets, Q-upper and Qlower, or an extended range bit- or character-string length.

\subsection{ACCUMULATOR-QUOTIENT REGISTER (AQ)}

Format: - 72 bits

Figure 3-3. Accumulator-Quotient Register (AQ) Format

Description:

A combination of the accumulator (A) and quotient (Q) registers.

Function:

In fixed-point binary instructions, holds double-precision operands and results.

In floating-point binary instructions, holds the mantissa.

In shifting instructions, holds original data and shifted results.

\subsection{EXPONENT REGISTER (E)}

Format: - 8 bits

Figure 3-4. Exponent Register (E) Format

Description:

An 8-bit physical register located in the operations unit.

Function:

In floating-point binary instructions, holds the exponent.

\subsection{EXPONENT-ACCUMULATOR-QUOTIENT REGISTER (EAQ)}

Format: - 80 bits

Figure 3-5. Exponent-Accumulator-Quotient Register (EAQ) Format

Description:

A combination of the exponent (E), accumulator (A), and quotient (Q) registers.
Although the combined register has a total of 80 bits, only 72 are involved in
transfers to and from main memory. The 8 low-order bits are discarded on store
and zero-filled on load.  

Function:

In floating-point binary instructions, holds operands and results.

\subsection{INDEX REGISTERS (Xn)}

Format: - 18 bits each

Figure 3-6. Index Register (Xn) Format

Description:

Eight 18-bit physical registers in the operations unit numbered 0 through 7.
Index register data may occupy the position of either an upper or lower 18-bit
half-word operand (see Section 2).

Function:

In fixed-point binary instructions, hold half-word operands and results.

In address preparation, hold word offsets or extended range bit- or
character-string lengths.

\subsection{INDICATOR REGISTER (IR)}

Format: - 14 bits

Figure 3-7. Indicator Register (IR) Format

Description:

An assemblage of 15 indicator flags from various units of the processor. The
data occupies the position of a lower 18-bit half word operand (see Section 2).
When interpreted as data, a bit value of 1 corresponds to the ON state of the
indicator, a bit value of 0 corresponds to the OFF state.

Function:

The functions of the individual indicator bits are given below. An {``}x'' in
the column headed {``}L'' indicates that the state of the indicator is not
affected by instructions that load the IR.

key L Indicator name Action

a Zero This indicator is set ON whenever the output of the main binary adder
consists entirely of zero bits for binary or shifting instructions or the
output of the decimal adder consists entirely of zero digits for decimal
instructions; otherwise, it is set OFF.

b Negative This indicator is set ON whenever the output of bit 0 of the main
binary adder has value 1 for binary or shifting instructions or the sign
character of the result of a decimal instruction is the negative sign
character; otherwise, it is set OFF.

c Carry This indicator is set ON for any of the following conditions;
otherwise, it is set OFF.


(1) If a bit propagates leftward out of bit 0 of the main binary adder for any
binary or shifting instruction.

(2) If | value1 | $<$= | value2 | for a decimal numeric comparison instruction.

(3) If char1 $<$= char2 for a decimal alphanumeric compare instruction.

d Overflow This indicator is set ON if the arithmetic range of a register is
exceeded in a fixed-point binary instruction or if the target string of a
decimal numeric instruction is too small to hold the integer part of the
result. It remains ON until reset by the Transfer On Overflow (tov) instruction
or is reset by some other instruction that loads the IR. The event that sets
this indicator ON may also cause an overflow fault. (See overflow mask
indicator below.)

e Exponent overflow This indicator is set ON if the exponent of the result of a
floating-point binary or decimal numeric instruction is greater than +127. It
remains ON until reset by the Transfer On Exponent Overflow (teo) instruction
or is reset by some other instruction that loads the IR. The event that sets
this indicator ON may also cause an overflow fault. (See overflow mask
indicator below.)

f Exponent underflow This indicator is set ON if the exponent of the result of
a floating-point binary or decimal numeric instruction is less than -128. It
remains ON until reset by the Transfer On Exponent Underflow (teu) instruction
or is reset by some other instruction that loads the IR. The event that sets
this indicator ON may also cause an overflow fault. (See overflow mask
indicator below.)

g Overflow mask This indicator is set ON or OFF only by the instructions that
load the IR. When set ON, the IR inhibits the generation of the fault for those
events that normally cause an overflow fault. If the overflow mask indicator is
set OFF after occurrence of an overflow event, an overflow fault does not occur
even though the indicator for that event is still set ON. The state of the
overflow mask indicator does not affect the setting, testing, or storing of any
other indicator.

h Tally runout This indicator is set OFF at initialization of any tallying
operation, that is, any repeat instruction or any indirect then tally address
modification. It is then set ON for any of the following conditions:

(1) If any repeat instruction terminates because of tally exhaust.

(2) If a Repeat Link (rpl) instruction terminates because of a zero link
address.

(3) If a tally exhaust is detected for an indirect then tally modifier. The
instruction is executed whether or not tally exhaust occurs.

(4) If an EIS string scanning instruction reaches the end of the string without finding a match condition.

i Parity error This indicator is set ON whenever a system controller signals
illegal action with a parity error code or the processor detects an internal
parity error condition. The indicator is set OFF only by instructions that load
the IR.

j Parity mask This indicator is set ON or OFF only by the instructions that
load the IR and is changed only when the processor is in privileged or absolute
mode. When it is set ON, the IR inhibits the generation of the parity fault for
all events that set the parity error indicator. If the parity mask indicator is
set OFF after the occurrence of a parity error event, a parity fault does not
occur even though the parity error indicator may still be set ON. The state of
the parity mask indicator does not affect the loading, testing, or storing of
any other indicator.

k x Not BAR mode This indicator is set OFF (placing the processor in BAR mode)
only by execution of the Transfer and Set Slave (tss) instruction or by the
operand data of the Restore Control Unit (rcu) instruction and is changed only
when the processor is in privileged or absolute mode. It is set ON (taking the
processor out of BAR node) by the execution of any transfer instruction other
than tss during a fault or interrupt trap. (See Section 7.) If a fault or
interrupt trap occurs while in BAR node and the IR is stored before any
transfer occurs, then a Return (ret) or Restore Control Unit (rcu) instruction
that reloads the stored data will return the processor to BAR mode.

l Truncation This indicator is set ON whenever the target string of a decimal
numeric instruction is too small to hold all the digits of the result or the
target string of an alphanumeric instruction is too small to hold all the bits
or characters to be stored. (Also see the overflow indicator for decimal
numeric instructions.) The event that sets this indicator ON may also cause an
overflow fault.  (See overflow mask indicator above.)

m Mid instruction interrupt fault This indicator is set OFF at the start of execution of each instruction and is set ON by the events described below. The indicator has meaning only when determining the proper restart sequence for the interrupted instruction. This indicator can be set on:

(1) By any fault during execution of an EIS instruction; however, the state is
safe-stored in the Control Unit Data only for access violation and directed
faults.

(2) By an interrupt signal during execution of those EIS instructions that
allow very long operand strings.

(3) If the processor is in absolute or privileged mode, by the execution of a Load Indicator Register (ldi), Return (ret), or Restore Control Unit (rcu) instruction with bit 30 set to 1 in the IR data.

n x Absolute mode This indicator is set ON (placing the processor in absolute
mode) when the processor is initialized and by execution of an nonappended
transfer instruction during a fault or interrupt trap and is set OFF (placing
the processor in append mode) by any execution of an appended transfer
instruction. If the processor is not in absolute mode when the fault or
interrupt occurs and the transfer instruction is Return (ret) or Restore
Control Unit (rcu) and the appropriate mode bit is properly set in the IR data,
the processor remains in its current mode.

o Hex Mode When the hexadecimal permission indicator (bit 33 of the Mode Register) is set on and this indicator is also on, then the exponent of a floating point number has a power of 16 rather than a power of two (binary floating point). The state of the hex mode indicator can be changed by executing a Load Indicator Register (ldi), Return (ret), or Restore Control Unit (rcu), instruction with the desired state (1 or 0) set in bit 32 of the IR data.  Hexadecimal mode is only available on DPS 8M processors. Indicator Register bit 32 is set to a zero value on DPS/L68 processors.

\subsection{BASE ADDRESS REGISTER (BAR)}

Format: - 18 bits

Figure 3-8. Base Address Register (BAR) Format

Description:

An 18-bit physical register in the control unit.

Function:

The Base Address Register provides automatic hardware Address relocation and
Address range limitation when the processor is in BAR mode.

BAR.BASE Contains the 9 high-order bits of an 18-bit address relocation
constant.  The low-order bits are generated as zeros.

BAR.BOUND Contains the 9 high-order bits of the unrelocated address limit. The
loworder bits are generated as zeros. An attempt to access main memory beyond
this limit causes a store fault, out of bounds. A value of 0 is truly 0,
indicating a null memory range.

\subsection{TIMER REGISTER (TR)}

Format: - 27 bits

Figure 3-9. Timer Register (TR) Format

Description:

A 27-bit settable, free-running clock in the control unit. The value decrements
at a rate of 512 kHz. Its range is 1.953125 microseconds to approximately 4.37
minutes.

Function:

The TR may be loaded with any convenient value with the privileged Load Timer
(ldt) instruction. When the value next passes through zero, a timer runout
fault is signalled. If the processor is in normal or BAR mode with interrupts
not inhibited or is stopped at an uninhibited Delay Until Interrupt Signal
(dis) instruction, the fault occurs immediately. If the processor is in
absolute or privileged mode or has interrupts inhibited, the fault is delayed
until the processor returns to uninhibited normal or BAR mode or stops at an
uninhibited Delay Until Interrupt Signal (dis) instruction.

\subsection{RING ALARM REGISTER (RALR)}

Format: - 3 bits

Figure 3-10. Ring Alarm Register (RALR) Format

Description:

A 3-bit physical register in the appending unit.

Function:

If the RALR contains a value other than zero and the effective ring number (see
TPR.TRR below) is greater than or equal to the contents of the RALR and the
instruction for which an absolute main memory address is being prepared is a
transfer instruction, an access violation, ring alarm, fault occurs. Operating
system software may use this register to detect crossings from inner rings to
outer rings.

\subsection{POINTER REGISTERS (PRn)}

Format: - 42 bits each

Even word of ITS pointer pair

Odd word of ITS pointer pair

Data as stored by Store Pointer Register n Packed (sprpn)

Figure 3-11. Pointer Register (PRn) Format

Description:

Eight combinations of physical registers from the appending unit and decimal
unit numbered 0 through 7. PRn.RNR, PRn.SNR, and PRn.BITNO are located in the
appending unit and PRn.WORDNO is located in the decimal unit. The WORDNO
registers also form part of the address registers discussed later in this
section.

Function:

The pointer registers hold information relative to the location in main memory
of data items that may be external to the segment containing the procedure
being executed. The functions of the individual constituent registers are:

Register Function

PRn.SNR The segment number of the segment containing the data item described by
the pointer register.

PRn.RNR The final effective ring number value calculated during execution of
the instruction that last loaded the PR.

(43)8 This field is not part of the PR but is generated each time the PR is
stored as an ITS pair.

PRn.WORDNO The offset in words from the base or origin of the segment to the
data item.

PRn.BITNO The number of the bit within PRn.WORDNO that is the first bit of the
data item. Data items aligned on word boundaries always have the value 0.
Unaligned data items may have any value in the range [1,35].

(TAG) This field is not part of the PR but, in an ITS pointer pair, holds an
address modifier for use in address preparation.

\subsection{ADDRESS REGISTERS (ARn)}

Format: - 24 bits each

Data as stored by Store Address Register n (sarn)

Figure 3-12. Address Register (ARn) Format

Description:

Eight combinations of physical registers from the decimal unit numbered 0
through 7. The WORDNO registers also form part of the pointer registers
discussed earlier in this section.

Function:

The address registers hold information relative to the location in main memory
of the next bit, character, or byte of an EIS operand to be processed by an EIS
instruction. The functions of the individual constituent registers are:

key Register Function

ARn.WORDNO The offset in words relative to the current addressing base referent
(segment origin, BAR.BASE, or absolute 0 depending on addressing mode) to the
word containing the next data item element.

a ARn.CHAR The number of the 9-bit byte within ARn.WORDNO containing the first
bit of the next data item element.

ARn.BITNO The number of the bit within ARn.CHAR that is the first bit of the
next data item element.

NOTE: The reader's attention is directed to the presence of two bit number
registers, PRn.BITNO and ARn.BITNO. Because the Multics processor was
implemented as an enhancement to an existing design, certain apparent anomalies
appear. One of these is the difference in the handling of unaligned data items
by the appending unit and decimal unit. The decimal unit handles all unaligned
data items with a 9-bit byte number and bit offset within the byte. Conversion
from the description given in the EIS operand descriptor is done automatically
by the hardware. The appending unit maintains compatibility with the earlier
generation Multics processor by handling all unaligned data items with a bit
offset from the prior word boundary; again with any necessary conversion done
automatically by the hardware. Thus, a pointer register, PRn, may be loaded
from an ITS pointer pair having a pure bit offset and modified by one of the
EIS address register instructions (a4bd, s9bd, etc.) using character
displacement counts.  The automatic conversion performed ensures that the
pointer register, PR i, and its matching address register, ARi, both describe
the same physical bit in main memory.

SPECIAL NOTICE: The decimal unit has built-in hardware checks for illegal bit
offset values but the appending unit does not except for a single case for
packed pointers. See NOTES for Load Packed Pointers (lprpn) in Section 4.

\subsection{PROCEDURE POINTER REGISTER (PPR)}

Format: - 37 bits

Shown as part of word 0 of control unit data

Shown as part of word 4 of control unit data

Figure 3-13. Procedure Pointer Register (PPR) Format

Description:

A combination of physical registers from the appending unit and the control
unit. PPR.PRR, PPR.PSR, and PPR.P are located in the appending unit and PPR.IC
is located in the control unit. The PPR is not explicitly addressable but its
data is extracted and stored as part of the data stored with the Store Control
Unit (scu) and Store Control Double (stcd) instructions.  It is loaded from the
control unit data with the Restore Control Unit (rcu) instruction.

Function:

The Procedure Pointer Register holds information relative to the location in
main memory of the procedure segment in execution and the location of the
current instruction within that segment. The functions of the individual
constituent registers are:

Register Function

PPR.PRR The number of the ring in which the process is executing. It is set to
the effective ring number of the procedure segment when control is transferred
to the procedure.

PPR.PSR The segment number of the procedure being executed.

PPR.P A flag controlling execution of privileged instructions.  Its value is 1
(permitting execution of privileged instructions) if PPR.PRR is 0 and the
privileged bit in the segment descriptor word (SDW.P) for the procedure is 1;
otherwise, its value is 0.

PPR.IC The word offset from the origin of the procedure segment to the current

instruction.
\subsection{TEMPORARY POINTER REGISTER (TPR)}

Format: - 42 bits

Shown as part of word 2 of control unit data

Shown as part of word 3 of control unit data

Shown as part of word 5 of control unit data

Figure 3-14. Temporary Pointer Register (TPR) Format

Description:

A combination of physical registers from the appending unit and the control
unit. TPR.TRR, TPR.TSR, and TPR.TBR are located in the appending unit and
TPR.CA is located in the control unit. The TPR is not explicitly addressable
but its data is extracted and stored as part of the data stored with the Store
Control Unit (scu) instruction. It is loaded from the control unit data with
the Restore Control Unit (rcu) instruction.

Function:

The temporary pointer register holds the current virtual address used by the
processor in performing address preparation for operands, indirect words, and
instructions. At the completion of address preparation, the contents of the TPR
is presented to the appending unit associative memories for translation into
the 24-bit absolute main memory address.  The functions of the individual
constituent registers are:

Register Function

TPR.TRR The current effective ring number (see Section 8).

TPR.TSR The current effective segment number (see Section 8).

TPR.TBR The current bit offset as calculated from ITS and ITP pointer pairs.
(See Section 8.)

TPR.CA The current computed address relative to the origin of the segment whose
segment number is in TPR.TSR. (See Section 8.)

\subsection{DESCRIPTOR SEGMENT BASE REGISTER (DSBR)}

Format: - 51 bits

Even word of Y-pair as stored by Store Descriptor Base Register (sdbr)

Odd word of Y-pair as stored by Store Descriptor Base Register (sdbr)

Figure 3-15. Descriptor Segment Base Register (DSBR) Format

Description:

A physical register in the appending unit.

Function:

The Descriptor Segment Base Register contains information concerning the
descriptor segment being used by the processor.  The descriptor segment holds
the segment descriptor words (SDWs) for all segments accessible by the
processor, that is, the currently defined virtual address space. The functions
of its individual constituent registers are:

Register Function

DSBR.ADDR If DSBR.U = 1, the 24-bit absolute main memory address of the origin
of the current descriptor segment; otherwise, the 24-bit absolute main memory
address of the page table for the current descriptor segment.

DSBR.BND The 14 most significant bits of the highest Y-block16 address of the
descriptor segment that can be addressed without causing an access violation,
out of segment bounds, fault.

DSBR.U A flag specifying whether the descriptor segment is unpaged (U = 1) or
paged (U = 0).

DSBR.STACK The upper 12 bits of the 15-bit stack base segment number. It is
used only during the execution of the call6 instruction. (See Section 8 for a
discussion of generation of the stack segment number.)

\subsection{SEGMENT DESCRIPTOR WORD ASSOCIATIVE MEMORY (SDWAM)}

Format: - 88 bits each

Even word of Y-pairs as stored by Store Segment Descriptor Registers (ssdr)

Odd word of Y-pairs as stored by Store Segment Descriptor Registers (ssdr)

Data as stored by Store Segment Descriptor Pointers (ssdp)

Figure 3-16. Segment Descriptor Word Associative Memory (SDWAM) Format

Description:

A combination of 16 registers and flags from the appending unit constitute the
Segment Descriptor Word Associative Memory (SDWAM). The registers are numbered
consecutively from 0 through 15 but are not explicitly addressable by number.

For the DPS/L68 processors, the SDW associative memory will hold the 16 most
recently used (MRU) SDWs and have a full associative organization with least
recently used (LRU) replacement.

For the DPS 8M processor, the SDW associative memory will hold the 64 MRU SDWs
and have a 4-way set associative organization with LRU replacement.

Function:

Hardware segmentation in the processor is implemented by the appending unit
(see Section 5). In order to permit addressing by segment number and offset as
prepared in the temporary pointer register (described earlier), a table
containing the location and status of each accessible segment must be kept.
This table is the descriptor segment. The descriptor segment is located by
information held in the descriptor segment base register (DSBR) described
earlier.

Every time an effective segment number (TPR.TSR) is prepared, it is used as an
index into the descriptor segment to retrieve the segment descriptor word (SDW)
for the target segment. To reduce the number of main memory references required
for segment addressing, the SDWAM provides a content addressable memory to hold
the sixteen most recently referenced SDWs.

Whenever a reference to the SDW for a segment is required, the effective
segment number (TPR.TSR) is matched associatively against all 16 SDWAM.POINTER
registers (described below). If the SDWAM match logic circuitry indicates a
hit, all usage counts (SDWAM.USE) greater than the usage count of the register
hit are decremented by one, the usage count of the register hit is set to 15,
and the contents of the register hit are read out into the address preparation
circuitry. If the SDWAM match logic does not indicate a hit, the SDW is fetched
from the descriptor segment in main memory and loaded into the SDWAM register
with usage count 0 (the oldest), all usage counts are decremented by one with
the newly loaded register rolling over from 0 to 15, and the newly loaded
register is read out into the address preparation circuitry. Faulted SDWs are
not loaded into the SDWAM.

The functions of the constituent registers and flags of each SDWAM register are
as follows:

Register Function

SDWAM.ADDR The 24-bit absolute main memory address of the page table for the
target segment if SDWAM.U = 0; otherwise, the 24-bit absolute main memory
address of the origin of the target segment.

SDWAM.R1 Upper limit of read/write ring bracket (see Section 8).

SDWAM.R2 Upper limit of read/execute ring bracket (see Section 8).

SDWAM.R3 Upper limit of call ring bracket (see Section 8).

SDWAM.BOUND The 14 high-order bits of the last Y-block16 address within the
segment that can be referenced without an access violation, out of segment
bound, fault.

SDWAM.R Read permission bit. If this bit is set ON, read access requests are
allowed.

SDWAM.E Execute permission bit. If this bit is set ON, the SDW may be loaded
into the procedure pointer register (PPR) and instructions fetched from the
segment for execution.

SDWAM.W Write permission bit. If this bit is set ON, write access requests are
allowed.

SDWAM.P Privileged flag bit. If this bit is set ON, privileged instructions
from the segment may be executed if PPR.PRR is 0.

SDWAM.U Unpaged flag bit. If this bit is set ON, the segment is unpaged and
SDWAM.ADDR is the 24-bit absolute main memory address of the origin of the
segment. If this bit is set OFF, the segment is paged and SDWAM.ADDR is the
24-bit absolute main memory address of the page table for the segment.

SDWAM.G Gate control bit. If this bit is set OFF, calls and transfers into the
segment must be to an offset no greater than the value of SDWAM.CL as described
below.

SDWAM.C Cache control bit. If this bit is set ON, data and/or instructions from
the segment may be placed in the cache memory.

SDWAM.CL Call limiter (entry bound) value. If SDWAM.G is set OFF, transfers of
control into the segment must be to segment addresses no greater than this
value.

SDWAM.POINTER The effective segment number used to fetch this SDW from main
memory.

SDWAM.F Full/empty bit. If this bit is set ON, the SDW in the register is
valid.  If this bit is set OFF, a hit is not possible. All SDWAM.F bits are set
OFF by the instructions that clear the SDWAM.

SDWAM.USE Usage count for the register. The SDWAM.USE field is used to maintain
a strict FIFO queue order among the SDWs. When an SDW is matched, its USE value
is set to 15 (newest) on the DPS/L68 and to 63 on the DPS 8M, and the queue is
reordered. SDWs newly fetched from main memory replace the SDW with USE value 0
(oldest) and the queue is reordered.

\subsection{PAGE TABLE WORD ASSOCIATIVE MEMORY (PTWAM)}

Format: - 51 bits each

Data as stored by Store Page Table Registers (sptr)

Data as stored by Store Page Table Pointers (sptp)

Figure 3-17. Page Table Word Associative Memory (PTWAM) Format

Description:

A combination of 16 registers and flags from the appending unit constitute the
Page Table Word Associative Memory (PTWAM). The registers are numbered
consecutively from 0 through 15 but are not explicitly addressable by number.

For the DPS/L68 processors, the PTW associative memory will hold the 16 most
recently used (MRU) PTWs and have a full associative organization with least
recently used (LRU) replacement.

For the DPS 8M processors, the PTW associative memory will hold the 64 MRU PTWs
and have a 4-way set associative organization with LRU replacement.

Function:

Hardware paging in the Multics processor is implemented by the appending unit
(see Section 5 for details). In order to permit segment addressing by page
number and page offset as derived from the computed address prepared in the
temporary pointer register (TPR.CA described above), a table containing the
location and status of each page of an accessible segment must be kept. This
table is the page table for the segment. The page table for an accessible paged
segment is located by information held in the segment descriptor word (SDW) for
the segment.

Every time a computed address (TPR.CA) for a paged segment is prepared, it is
separated into a page number and a page offset. The page number is used as an
index into the page table to retrieve the page table word (PTW) for the target
page. To reduce the number of main memory references required for paging, the
PTWAM provides a content addressable memory to hold the 16 most recently
referenced PTWs.


Whenever a reference to the PTW for a page of a paged segment is required, the
page number (as derived from TPR.CA) is matched associatively against all 16
PTWAM.PAGENO registers (described below) and, simultaneously, TPR.TSR is
matched against PTWAM.POINTER (described below). If the PTWAM match logic
circuitry indicates a hit, all usage counts (PTWAM.USE) greater than the usage
count of the register hit are decremented by one, the usage count of the
register hit is set to 15, and the contents of the register hit are read out
into the address preparation circuitry. If the PTWAM match logic does not
indicate a hit, the PTW is fetched from main memory and loaded into the PTWAM
register with usage count 0 (the oldest), all usage counts are decremented by
one with the newly loaded register rolling over from 0 to 15, and the newly
loaded register is read out into the address preparation circuitry. Faulted
PTWs are not loaded into the PTWAM.  

The functions of the constituent registers and flags of each PTWAM register
are: (See Section 8 for additional details.)

Register Function

PTWAM.ADDR The 18 high-order bits of the 24-bit absolute main memory address of
the page. The hardware ignores low-order bits of this page address according to
page size based on the following:

Page size in words ADDR bits ignored

64 none

128 17

256 16-17

512 15-17

1024 14-17

2048 13-17

4096 12-17

PTWAM.M Page modified flag bit. This bit is set ON whenever the PTW is used for
a store type instruction. When the bit changes value from 0 to 1, a special
extra cycle is generated to write it back into the PTW in the page table in
main memory.

PTWAM.POINTER The effective segment number used to fetch this PTW from main
memory.

PTWAM.PAGENO The 12 high-order bits of the 18-bit computed address (TPR.CA)
used to fetch this PTW from main memory. Low-order bits are forced to zero by
the hardware and not used as part of the page table index according to page
size based on the following:

Page size in words PAGENO bits forced

64 none

128 11

256 10-11

512 09-11

1024 08-11

2048 07-11

4096 06-11

PTWAM.F Full/empty bit. If this bit is set ON, the PTW in the register is
valid. If this bit is set OFF, a hit is not possible. All PTWAM.F bits are set
OFF by the instructions that clear the PTWAM.

PTWAM.USE Usage count for the register. The PTWAM.USE field is used to maintain
a strict FIFO queue order among the PTWs. When an PTW is matched its USE value
is set to 15 (newest) on the DPS/L68 and to 63 on the DPS 8M, and the queue is
reordered. PTWs newly fetched from main memory replace the PTW with USE value 0
(oldest) and the queue is reordered.

\subsection{FAULT REGISTER (FR) -- DPS AND L68}

Format: - 72 bits

Even word of Y-pair as stored by Store Central Processor Register (scpr), TAG = 01

Odd word of Y-pair as stored by Store Central Processor Register (scpr), TAG = 01

Figure 3-18. Fault Register (FR) Format - DPS and L68

Description:

A combination of flags and registers all located in the control unit. The
register is stored and cleared by the Store Central Processor Register (scpr),
TAG = 01, instruction. Note that the data is stored into the word pair at
location Y. The Fault Register cannot be loaded.

Function:

The Fault Register contains the conditions in the processor for several of the
hardware faults. Data is strobed into the Fault Register during a fault
sequence. Once a bit or field in the Fault register is set, it remains set
until the register is stored and cleared. The data is not overwritten during
subsequent fault events.

The functions of the constituent flags and registers are:

Flag or key register Function

a ILL OP An illegal operation code has been detected.

b ILL MOD An illegal address modifier has been detected.

c ILL SLV An illegal BAR mode procedure has been encountered.

d ILL PROC An illegal procedure other than the three above has been encountered.

e NEM A nonexistent main memory address has been requested.

f OOB A BAR mode boundary violation has occurred.

g ILL DIG An illegal decimal digit or sign has been detected by the decimal unit.

h PROC PARU A parity error has been detected in the upper 36 bits of data.

i PROC PARL A parity error has been detected in the lower 36 bits of data.

j \$CON A A \$CONNECT signal has been received through port A.

k \$CON B A \$CONNECT signal has been received through port B.

1 \$CON C A \$CONNECT signal has been received through port C.

m \$CON D A \$CONNECT signal has been received through port D.

n DA ERR1 Operation not complete. Processor/system controller interface sequence error 1 has been detected. (\$DATA-AVAIL received with no prior \$INTERRUPT sent.)

o DA ERR2 Operation not complete. Processor/system controller interface sequence error 2 has been detected. (Multiple \$DATA-AVAIL received or \$DATA-AVAIL received out of order.)

IAA Coded illegal action, port A. (see Table 3-2)

IAB Coded illegal action, port B. (See Table 3-2)

IAC Coded illegal action, port C. (See Table 3-2)

IAD Coded illegal action, port D. (See Table 3-2)

p CPAR DIR A parity error has been detected in the cache memory directory.

q CPAR STR A data parity error has been detected in the cache memory.

r CPAR IA An illegal action has been received from a system controller during a store operation with cache memory enabled. This implies that the data are correct in cache memory and incorrect in main memory.

s CPAR BLK A cache memory parity error has occurred during a cache memory data block load.

Table 3-2. System Controller Illegal Action Codes

Code Priority Fault Reason

00 -- No illegal action

01 -- Command Unassigned

02 05 Store Nonexistent address

03 01 Command Stop on condition

04 -- Command Unassigned

05 12 Parity Data parity, store unit to system controller

06 11 Parity Data parity in store unit

07 10 Parity Data parity in store unit and store unit to system controller

10 04 Command Not control (a)

11 13 Command Port not enabled

12 03 Command Illegal command

13 07 Store Store unit not ready

14 02 Parity Zone-address-command parity, processor to system controller

15 06 Parity Data parity, processor to system controller

16 08 Parity Zone-address-command parity, system controller to store unit

17 09 Parity Data parity, system controller to store unit

(a) This illegal action code not relevant to later model system controllers.

\subsection{FAULT REGISTER (FR) - DPS 8M}

Format: - 72 bits

Even word of Y-pair as stored by Store Central Processor Register (scpr), TAG = 01

Odd word of Y-pair as stored by Store Central Processor Register (scpr), TAG = 01

Figure 3-19. Fault Register (FR) Format - DPS 8M

Function:

The Fault Register contains the conditions in the processor for several of the
hardware faults on the DPS 8M CPU and cache directory buffer overflows. Data is
strobed into the Fault Register during a fault or buffer overflow fault
sequence. Once a bit or field in the Fault Register is set, it remains set
until the register is stored and cleared. The data is not overwritten during
subsequent fault events.

The functions of the constituent flags and registers are:

Flag or key register Fault Function

a ILL OP IPR An illegal operation code has been detected.

b ILL MOD IPR An illegal address modifier has been detected.

c ILL SLV IPR An illegal BAR mode procedure has been encountered.

d ILL PROC IPR An illegal procedure other than the three above has been encountered.

e NEM ONC A nonexistent main memory address has been requested.

f OOB STR A BAR mode boundary violation has occurred.

g ILL DIG IPR An illegal decimal digit or sign has been detected by the decimal unit.

h PROC PARU PAR A parity error has been detected in the upper 36 bits of data.

i PROC PARL PAR A parity error has been detected in the lower 36 bits of data.

j \$CON A CON A \$CONNECT signal has been received through port A.

k \$CON B CON A \$CONNECT signal has been received through port B.

l \$CON C CON A \$CONNECT signal has been received through port C.

m \$CON D CON A \$CONNECT signal has been received through port D.

n DA ERR ONC Operation not complete.  Processor/system controller interface sequence error 1 has been detected. (\$DATA-AVAIL received with no prior \$INTERRUPT sent.)

o DA ERR2 ONC Operation not completed.  Processor/system controller interface sequence error 2 has been detected. (Multiple \$DATA-AVAIL received or \$DATA-AVAIL received out of order.)

IAA Coded illegal action, port A. (See Table 3-2)

IAB Coded illegal action, port B. (See Table 3-2)

IAC Coded illegal action, port C. (See Table 3-2)

IAD Coded illegal action, port D. (See Table 3-2)

p CPAR DIR None A parity error has been detected in the cache memory directory.

q CPAR STR PAR A data parity error has been detected in the cache memory.

r CPAR IA PAR An illegal action has been received from a system controller during a store operation with cache memory enabled. This implies that the data are correct in cache memory and incorrect in main memory.

s CPAR BLK PAR A cache memory parity error has occurred during a cache memory data block load.

Cache Duplicate Directory WNO Buffer Overflow

t None Port A

u None Port B

v None Port C

w None Port D

x None Cache Primary Directory WNO Buffer Overflow

y None Write Notify (WNO) Parity Error on Port A, B, C, or D.

None Cache Duplicate Directory Parity Error

z None Level 0

A None Level 1

B None Level 2

C None Level 3

D Cache Duplicate Directory Multiple Match

E None A parity error has been detected in the SDWAM.

F None A parity error has been detected in the PTWAM.

\subsection{MODE REGISTER (MR) - DPS AND L68}

Format: - 33 bits

Even word of Y-pair as stored by Store Central Processor Register (scpr), TAG = 06

Figure 3-20. Mode Register (MR) Format - DPS and L68

Description:

An assemblage of flags and registers from the control unit. The Mode Register
and the Cache Mode Register are both stored into the Y-pair by the Store
Central Processor Register (scpr), TAG = 06. The Mode Register is loaded with
the Load Central Processor Register (lcpr), TAG = 04, instruction.

Function:

The Mode Register controls the operation of those features of the processor
that are capable of being enabled and disabled.

The functions of the constituent flags and registers are:

Flag or key register Function

FFV A floating-fault vector address. The 15 high-order bits of the Yblock8 address of four word pairs constituting a floating-fault vector.  Traps to these floating faults are generated by other conditions the mode register sets.

a OC TRAP Trap on OPCODE match. If this bit is set ON and OPCODE matches the operation code of the instruction for which an address is being prepared (including indirect cycles), generate the second floating fault (xed FFV+2). See NOTE below.

b ADR TRAP Trap on ADDRESS match. If this bit is set ON and the computed
address (TPR.CA) matches the setting of the address switches on the processor
maintenance panel, generate the fourth floating fault (xed FFV+6). See NOTE
below.

OPCODE Function The operation code on which to trap if OC TRAP (bit 16, key a)
is set ON or for which to strobe all control unit cycles into the control unit
history registers if O.C\$\textcent (bit 29, key j) is set ON.

or

Processor conditions codes as follows if OC TRAP (bit 16, key a) and O.C\$¢
(bit 29, key j) are set OFF and ¢ VOLT (bit 32, key m) is set ON.

c Set control unit overlap inhibit if set ON. The control unit waits for the
operations unit to complete execution of the even instruction of the current
instruction pair before it begins address preparation for the associated odd
instruction. The control unit also waits for the operations unit to complete
execution of the odd instruction before it fetches the next instruction pair.

d Set store overlap inhibit if set ON. The control unit waits for completion of
a current main memory fetch (read cycles only) before requesting a main memory
access for another fetch.

e Set store incorrect data parity if set ON. The control unit causes incorrect
data parity to be sent to the system controller for the next store instruction
and then resets bit 20.

f Set store incorrect zone-address-command (ZAC) parity if set ON. The control
unit causes incorrect zone-address-command (ZAC) parity to be sent to the
system controller for each main memory cycle of the next store instruction and
resets bit 21 at the end of the instruction.

g Set timing margins if set ON. If ¢ VOLT (bit 32, key m) is set ON and the
margin control switch on the processor maintenance panel is in PROG position,
set processor timing margins as follows:

22,23 margin
0,0 normal
0,1 slow
1,0 normal
1,1 fast

h Set +5 voltage margins if set ON. If ¢ VOLT (bit 32, key m) is set ON and the
margin control switch on the processor maintenance panel is in the PROG
position, set +5 voltage margins as follows:

24,25 margin
0,0 normal
0,1 low
1,0 high
1,1 normal

i Trap on control unit history register count overflow if set ON. If this bit
and STROBE ¢ (bit 30, key k) are set ON and the control unit history register
counter overflows, generate the third floating fault (xed FFV+4). Further, if
FAULT RESET (bit 31, key 1) is set, reset STROBE ¢ (bit 30, key k), locking the
history registers. A Load Central Processor Register (lcpr), TAG = 04,
instruction setting bit 28 ON resets the control unit history register counter
to zero. (See NOTE below.)

j O.C\$¢ Strobe control unit history registers on OPCODE match. If this bit and
STROBE ¢ (bit 30, key k) are set ON and the operation code of the current
instruction matches OPCODE, strobe the control unit history registers on all
control unit cycles (including indirect cycles).

k STROBE ¢ Enable history registers. If this bit is set ON, all history
registers are strobed at appropriate points in the various processor cycles. If
this bit is set OFF or MR ENABLE (bit 35, key n) is set OFF, all history
registers are locked. This bit is set OFF with a Load Central Processor
Register (lcpr), TAG = 04, instruction providing a 0 bit, by an operation not
complete fault, and, conditionally, by other faults (see FAULT RESET (bit 31,
key 1) below). Once set OFF, this bit must be set ON with a Load Central
Processor Register (lcpr), TAG = 04, instruction providing a 1 bit to re-enable
the history registers.

l FAULT RESET History register lock control. If this bit is set ON, set STROBE
¢ (bit 30, key k) OFF, locking the history registers for all faults including
the floating faults. See NOTE below.

m ¢ VOLT Test mode indicator. This bit is set ON whenever the TEST/NORMAL
switch on the processor maintenance panel is in TEST position; otherwise, it is
set OFF. It serves to enable the program control of voltage and timing margins.

n MR ENABLE Enable mode register. When this bit is set ON, all other bits and
controls of the mode register are active. When this bit is set OFF, the mode
register controls are disabled.  

NOTE: The traps described above (address match, OPCODE match, control unit
history register counter overflow) occur after completion of the next odd
instruction following their detection. They are handled as Group 7 faults in
regard to servicing and inhibition. (See Section 7 for descriptions of these
faults.) The complete Group 7 priority sequence (in increasing order) is:

1 - Connect

2 - Time runout

3 - Shutdown

4 - OPCODE trap

5 - Control unit history register counter overflow

6 - Address match trap

7 - External interrupts

\subsection{MODE REGISTER (MR) - DPS 8M}

Format: - 36 bits

Even word of Y-pair as stored by Store Central Processor Register (scpr), TAG = 06

Figure 3-21. Mode Register (MR) Format - DPS 8M

Description:

An assemblage of flags and registers from the control unit. The Mode Register
and the Cache Mode Register are both stored into the Y-pair by the Store
Central Processor Register (scpr), TAG = 06. The Mode Register is loaded with
the Load Central Processor Register (lcpr), TAG = 04, instruction.

Function:

The mode register controls the operation of those features of the processor
that are capable of being enabled and disabled.

The functions of the constituent flags and registers are:

Flag or key register Function

a cuolin Set CU overlap inhibit. The CU waits for the OU to complete execution
of the even instruction before it begins address preparation for the associated
odd instruction. The CU also waits for the OU to complete execution of the odd
instruction before it fetches the next instruction pair.

b solin Set store overlap inhibit. The CU waits for completion of a current
memory fetch (read cycles only) before requesting a memory access for another
fetch.

c sdpap Set store incorrect data parity. The CU causes incorrect data parity to
be sent to the SC for the next data store instruction and then resets bit 20.

d separ Set store incorrect ZAC parity. The CU causes incorrect
zone-addresscommand (ZAC) parity to be sent to the SC for each memory cycle of
the next data store instruction and resets bit 21 at the end of the
instruction.

e tm Set timing margins. If bit 32 key (k) is set and the margin control switch
on the CPU maintenance panel is in program position, set CPU timing margins as
follows:

22,23 margin

0,0 normal

0,1 slow

1,0 normal

1,1 fast

f vm Set +5 voltage margins. If bit 32 (key k) is set and the margin control
switch on the CPU maintenance panel is in the program position, set +5 voltage
margins as follows:

24,25 margin

0,0 normal

0,1 low

1,0 high

1,1 normal

g hrhlt Stop HR Strobe on HR Counter Overflow. (Setting bit 28 shall cause the
HR counter to be reset to zero.)

h hrxfr Strobe the HR on Transfer Made. If bits 29,30, and 35 are = 1, the HR
will be strobed on all Transfers Made. Bits 36-53 of the OU/DU register will
indicate the {``}From'' location and bits 36-59 of the CU register will contain
the real address of the final {``}To'' location.

i ihr Enable History Registers. If bit 30 = 1, the HRs may be strobed. If bit
30 = 0 or bit 35 = 0, they will be locked out. This bit will be reset by either
an LCPR with the bit corresponding to 30 = 0 or by an Op Not Complete fault. It
may be reset by other faults (see bit 31). After being reset, it must be
enabled by another LCPR instruction before the History Registers may be strobed
again.

j ihrrs Additional resetting of bit 30. If bit 31 = 1, the following faults
also reset bit 30:

- Lock Up

- Parity

- Command

- Store

- Illegal Procedure

- Shutdown

k mrgctl Margin Control. Bit 32 informs the software when it can control
margins.  A one indicates that software has control. When the LOCAL/REMOTE
switch on the power supply is in REMOTE and bit 35 = 1, bit 32 is set to 1 by
occurrence of the following conditions: the NORMAL/TEST switch is in the TEST
position, the Memory and CU Overlap Inhibit switches are OFF, the Timing
Margins for the OU, CU, DU and VU are NORMAL, and the Forced Data and ZAC
Parity are OFF.

l hexfp Hexadecimal Exponent Floating Point Arithmetic Mode can be set. When
this bit is set, the Hex mode becomes effective when the Indicator Register bit
32 is set to 1.

m emr Enable Mode Register. Unless bit 35 = 1, all other bits in the Mode
Register are ignored and the History Register is ignored and locked.

\subsection{CACHE MODE REGISTER (CMR) - DPS AND L68}

Format: - 28 bits

Odd word of Y-pair as stored by Store Central Processor Register (scpr), TAG = 06

Figure 3-22. Cache Mode Register (CMR) Format - DPS and L68

Description:

An assemblage of flags and registers from the control unit. The Mode Register
and Cache Mode Register are both stored into the Y-pair by the Store Central
Processor Register (scpr), TAG = 06, instruction. The Cache Mode Register is
loaded with the Load Central Processor Register (lcpr), TAG = 02, instruction.

The data stored from the cache mode register is address-dependent. The
algorithm used to map main memory into the cache memory (see Section 9) is
effective for the Store Central Processor Register (scpr) instruction. In
general, the user may read out data from the directory entry for any cache
memory block by proper selection of certain subfields in the 24-bit absolute
main memory address. In particular, the user may read out the directory entry
for the cache memory block involved in a suspected cache memory error by
ensuring that the required 24-bit absolute main memory address subfields are
the same as those for the access which produced the suspected error.

The fault handling procedure(s) should be unencacheable (SDW.C = 0) and the
history registers and cache memory should be disabled as quickly as possible in
order that vital information concerning the suspected error not be lost.

Function:

The Cache Mode register provides configuration information and software control
over the operation of the cache memory. Those items with an {``}x'' in the
column headed L are not loaded by the Load Central Processor Register (lcpr),
TAG = 02, instruction.

The functions of the constituent flags and registers are:

key L Register Function

x CACHE DIR ADDRESS 15 high-order bits of the cache memory block address from
the cache directory.

a x PAR BIT Cache memory directory parity bit.

b x LEV FUL The selected column and level is loaded with active data.

c CSH1 ON Enable the upper 1024 words of the cache memory (see Section 9).

d CSH2 ON Enable the lower 1024 words of the cache memory (see Section 9).

e OPND ON Enable the cache memory for operands (see Section 9).

f INST ON Enable the cache memory for instructions (see Section 9).

g CSH REG Enable cache-to-register (dump) mode. When this bit is set ON,
double-precision operations unit read operands (e.g., Load AQ (ldaq) operands)
are read from the cache memory according to the mapping algorithm and without
regard to matching of the full 24-bit absolute main memory address.  All other
operands address main memory as though the cache memory were disabled. This bit
is reset automatically by the hardware for any fault or interrupt.

h x STR ASD Enable store aside. When this bit is set ON, the processor does not
wait for main memory cycle completion after a store operation but proceeds
after the cache memory cycle is complete.

i x COL FUL Selected cache memory column is full.

j x RRO A,B Cache round robin counter (see Section 9).

k LUF MSB,LSB Lockup timer setting. The lockup timer may be set to four
different values according to the value of this field.

LUF value Lockup time

0 2ms

1 4ms

2 8ms

3 16ms

The lockup timer is set to 16ms when the processor is initialized.

\subsection{CACHE MODE REGISTER (CMR) - DPS 8M}

Format: - 36 bits

Odd word of Y-pair as stored by Store Central Processor Register (scpr), TAG = 06.

Figure 3-23. Cache Mode Register (CMR) Format - DPS 8M

Description:

An assemblage of flags and registers from the control unit. The Mode Register
and Cache Mode Register are both stored into the Y-pair by the Store Central
Processor Register (scpr), TAG = 06, instruction. The Cache Mode Register is
loaded with the Load Central Processor Register (lcpr), TAG = 02, instruction.

The data stored from the Cache Mode register is address-dependent. The
algorithm used to map main memory into the cache memory (see Section 9) is
effective for the Store central Processor Register (scpr) instruction. In
general, the user may read out data from the directory entry for any cache
memory block by proper selection of certain subfields in the 24-bit absolute
main memory address. In particular, the user may read out the directory entry
for the cache memory block involved in a suspected cache memory error by
ensuring that the required 24-bit absolute main memory address subfields are
the same as those for the access which produced the suspected error.  

The fault handling procedure(s) should be unencacheable (SDW.D = 0) and the
history registers and cache memory should be disabled as quickly as possible in
order that vital information concerning the suspected error not be lost.

Function:

The Cache Mode Register provides configuration information and software control
over the operation of the cache memory. Those items with an {``}x'' in the
column headed L are not loaded by the Load Central Processor Register (lcpr),
TAG = 02, instruction.

The functions of the constituent flags and registers are:

key L Register Function

x CACHE DIR ADDRESS 15 high-order bits of the cache memory block address from the cache directory.

a x PAR BIT Cache memory directory parity bit.

b x LEV FUL The selected column and level is loaded with active data.

c CSH1 ON Enable the upper 4096 words of the cache memory (see Section 9).

d CSH2 ON Enable the lower 4096 words of the cache memory (see Section 9).

e INST ON Enable the cache memory for instructions (see Section 9).

f CSH REG Enable cache-to-register (dump) mode. When this bit is set ON,
double-precision operations unit read operands (e.g., Load AQ (ldaq) operands)
are read from the cache memory according to the mapping algorithm and without
regard to matching of the full 24-bit absolute main memory address. All other
operands address main memory as though the cache memory were disabled. This bit
is reset automatically by the hardware for any fault or interrupt.

g x STR ASD Enable store aside. When this bit is set ON, the processor does not wait for main memory cycle completion after a store operation but proceeds after the cache memory cycle is complete.

h x COL FUL Selected cache memory column is full.

i x RRO A,B Cache round-robin counter (see Section 9).

j Bypass cache bit. Enables the bypass option of SDW.C when set OFF. See Notes
below for further information.

k LUF MSB,LSB Lockup timer setting. The lockup timer may be set to four
different values according to the value of this field.

LUF value Lockup time

0 2ms

1 4ms

2 8ms

3 16ms

The lockup timer is set to 16ms when the processor is initialized.

Notes

1. The COL FUL, RRO A, RRO B, and CACHE DIR ADDRESS fields reflect different
locations in cache depending on the final (absolute) address of the scpr
instruction storing this data.

2. If either cache enable bit c or d changes from disable state to enable
state, the entire cache is cleared.

3. The DPS 8M processors contain an 8k hardware-controlled cache memory. When
running a mixed configuration of DPS 8M and DPS/L68 processors, bit 68 of the
CMR (reference j) allows the DPS 8M processor to utilize software compatible
with the older 2k software controlled by the DPS/L68 and DPS processors. The
following summarizes the operation of the DPS 8M hardware-controlled cache.

a. The cache bypass option in the segment descriptor word is retained. An overriding bypass enable, bit 68 of the Cache Mode Register, is added. The cache mode is set as follows:

SDW.C CMR68 RESULTANT CACHE MODE

Use Cache X Use Cache

Bypass Cache Bypass Cache Bypass Cache

Bypass Cache Use Cache Use Cache

b. All close gate instructions, LDAC, LDQC, STAC, STACQ, and SZNC automatically
bypass cache. Two features are added to ensure integrity of gated shared data;
one is added during the close gate operation and the other during the open gate
operation. The instruction following the close gate instruction bypasses cache
if the instruction is a Read or a Read-alter-rewrite. The open gate operation
must be performed with either a STC2 or STACQ, which includes the synchronizing
function.  The synchronizing function forces the processor to delay the open
gate operation until it is notified by the SCU that write completes have
occurred and write notifications requesting cache block clears have been sent
to the other processors for all write instructions that the processor
previously issued.

c. Read-alter-rewrite instructions no longer automatically bypass cache.  Cache
behavior for these instructions is determined fully by SDW.C. If the bypass
cache mode is set, these instructions bypass cache and issue
read-lock-write-unlock commands to memory. If a cache directory match occurs,
the location is cleared.

d. All accesses to memory by SDW and PTW associative memory hardware continue
to bypass cache. Operations are Reads for SDWs, Read-alter-rewrites with lock
for PTWs and setting the page Used bit, and Writes for setting the page
Modified and Used bits. For Writes, the hardware also disables the key line so
that the SCU lock is honored. This is consistent with dynamic PTW modification
by software, which also bypasses cache and uses Read-alter-rewrite
instructions.

e. The instructions that cleared the associative memories and also cleared
cache or selective portions of cache are changed to eliminate the cache clear
function. Bit C (TPR.CA)15, is ignored. These instructions also include
disable/enable capabilities for each half of the associative memories.

f. Cache mode register bit 56, which had previously controlled cache bypass for
operands, is disregarded. All other cache control bits are continued. However,
maintenance panel cache control function is restricted to cache half
enable/disable functions.

\subsection{CONTROL UNIT (CU) HISTORY REGISTERS - DPS AND L68}

The L68 and DPS processors have four sets of 16 history requests. There is one
set for each major unit: the Control Unit, CU; the Operations Unit, OU; the
Decimal Unit, DU; and the Appending Unit, APU. The DPS 8M Processor has four
sets of 64 history registers. There is one set for the CU, two sets for the
APU, and one set that combines the history of the OU and DU.

Because the history registers for the L68 and DPS and the DPS 8M are different
in number and content, they are described separately. The following section
describes the L68 and DPS history registers first, followed by a description of
the DPS 8M history registers.

Format: - 72 bits each

Even word of Y-pair as stored by Store Central Processor Register (scpr), TAG = 20

Odd word of Y-pair as stored by Store Central Processor Register (scpr), TAG = 20

Figure 3-24. Control Unit (CU) History Register Format - DPS and L68

Description:

A combination of 16 flags and registers from the control unit. The 16 registers
are handled as a rotating queue controlled by the Control Unit History Register
counter. The counter is always set to the number of the oldest entry and
advances by one for each history register reference (data entry or Store
Central Processor Register (scpr) instruction). Multicycle instructions (such
as Load Pointer Registers from ITS Pairs (lpri), Load Registers (lreg), Restore
Control Unit (rcu), etc.) have an entry for each of their cycles.

Function:

A control unit history register entry shows the conditions at the end of the
control unit cycle to which it applies. The 16 registers hold the conditions
for the last 16 control unit cycles.  Entries are made according to controls
set in the Mode Register. (See Mode Register earlier in this section.)

The meanings of the constituent flags and registers are:

key Flag Name Meaning

a PIA Prepare instruction address

b POA Prepare operand address

c RIW Request indirect word

d SIW Restore indirect word

e POT Prepare operand tally (indirect tally chain)

f PON Prepare operand no tally (as for POT except no chain)

g RAW Request read-alter-rewrite word

h SAW Restore read-alter-rewrite word

i TRGO Transfer GO (conditions met)

j XDE Execute even instruction from Execute Double (xed) pair

k XDO Execute odd instruction from Execute Double (xed) pair

l IC Execute odd instruction of the current pair

m RPTS Execute a repeat instruction

n WI Wait for instruction fetch

o AR F/E 1 = ADDRESS has valid data

p -XIP NOT prepare interrupt address

q -FLT NOT prepare fault address

r -BASE NOT BAR mode

OPCODE Operation code from current instruction word

I Interrupt inhibit bit from current instruction word

P Pointer register flag bit from current instruction word

TAG Current address modifier. This modifier is replaced by the contents of the
TAG fields of indirect words as they are fetched during indirect chains.

ADDRESS Current computed address (TPR.CA)

CMD System controller command

SEL Port select bits. (Valid only if port A-D is selected)

s XEC-INT An interrupt is present

t INS-FETCH Perform an instruction fetch

u CU-STORE Control unit store cycle

v OU-STORE Operations unit store cycle

w CU-LOAD Control unit load cycle

x OU-LOAD Operations unit load cycle

y DIRECT Direct cycle

z -PC-BUSY Port control logic not busy
* BUSY Port interface busy

\subsection{CONTROL UNIT (CU) HISTORY REGISTERS - DPS 8M}

Format: - 72 bits each

Even word of Y-pair as stored by Store Central Processor Register (scpr), TAG = 20

Odd word of Y-pair as stored by Store Central Processor Register (scpr), TAG = 20

Figure 3-25. Control Unit (CU) History Register Format - DPS 8M

Description:

A combination of 64 flags and registers from the control unit. The 64 registers
are handled as a rotating queue, controlled by the control unit history
register counter, in which only the 16 most recently used are stored (except in
the event of a system crash in which case all 64 will be saved). The counter is
always set to the number of the oldest entry and advances by one for each
history register reference (data entry or Store Central Processor Register
(scpr) instruction). Multicycle instructions (such as Load Pointer Registers
from ITS Pairs (lpri), Load Registers (lreg), Restore Control Unit (rcu), etc.)
have an entry for each of their cycles.

Function:

A control unit history register entry shows the conditions at the end of the
control unit cycle to which it applies. The 16 registers hold the conditions
for the last 16 control unit cycles.  Entries are made according to controls
set in the Mode Register. (See Mode Register earlier in this section.)

The meanings of the constituent flags and registers are:

key Flag Name Meaning

a PIA Prepare instruction address

b POA Prepare operand address

c RIW Request indirect word

d SIW Restore indirect word

e POT Prepare operand tally

f PON Prepare operand no tally

g RAW Request read-alter-rewrite word

h SAW Restore read-alter-rewrite word

i RTRGO Remember transfer GO (condition met)

j XDE XED from even location

k XDO XED from odd location

l IC Even/odd instruction pair

m RPTS Repeat operation

n PORTF Memory cycle to port on previous cycle

o INTERNAL Memory cycle to cache or direct on previous cycle

p PAI Prepare interrupt address

q PFA Prepare fault address

r PRIV In privileged mode

OPCODE Opcode of instruction

I Inhibit interrupt bit

P AR reg mod flag

TAG Tag field of instruction

ADDRESS Absolute mean address of instruction

CMD Processor command register

s XINT Execute instruction

t IFT Instruction fetch

u CRD Cache read, this CU cycle

v MRD Memory read, this CU cycle

w MSTO Memory store, this CU cycle

x PIB Memory port interface busy

\subsection{OPERATIONS UNIT (OU) HISTORY REGISTERS - DPS AND L68}

Format: - 72 bits each

Even word of Y-pair as stored by Store Central Processor Register (scpr), TAG = 40

Odd word of Y-pair as stored by Store Central Processor Register (scpr), TAG = 40

Figure 3-26. Operations Unit (OU) History Register Format

Description:

A combination of 16 flags and registers from the operation unit and control
unit. The 16 registers are handled as a rotating queue controlled by the
operations unit history register counter. The counter is always set to the
number of the oldest entry and advances by one for each history register
reference (data entry or Store Central Processor Register (scpr) instruction).

Function:

An Operations Unit History Register entry shows the conditions at the end of
the operations unit cycle to which it applies. The 16 registers hold the
conditions for the last 16 operations unit cycles. As the operations unit
performs various cycles in the execution of an instruction, it does not advance
the counter for each such cycle. The counter is advanced only at successful
completion of the instruction or if the instruction is aborted for a fault
condition. Entries are made according to controls set in the Mode Register.
(See Mode Register earlier in this section.)

The meanings of the constituent flags and registers are:

key Flag Name Meaning

RP REG Primary operations unit operation register. RP REG receives the
operation code and other data for the next instruction from the control unit
during the control unit instruction fetch cycle while the operations unit may
be busy with a prior instruction.  RP REG is further substructured as:

OP CODE The 9 high-order bits of the 10-bit operation code from the instruction
word. Note that basic (non EIS) instructions do not involve bit 27 hence the
9-bit field is sufficient to determine the instruction.

a 9 CHAR Character size for indirect then tally address modifiers

0 = 6-bit

1 = 9-bit

b TAG1,2,3 The 3 low-order bits of the address modifier from the instruction
word. This field may contain a character position for an indirect then tally
address modifier.

c CR FLG Character operation flag

d DR FLG Direct operation flag

EAC Address counter for lreg/sreg instructions

RS REG Secondary operations unit operation register. OP CODE is moved from RP
REG to RS REG during the operand fetch cycle and is held until completion of
the instruction.

e RB1 FULL OP CODE buffer is loaded

f RP FULL RP REG is loaded

g RS FULL RS REG is loaded

h GIN First cycle for all OU instructions

i GOS Second cycle for multicycle OU instructions

j GD1 First divide cycle

k GD2 Second divide cycle

l GOE Exponent compare cycle

m GOA Mantissa alignment cycle

n GOM General operations unit cycle

o GON Normalize cycle

p GOF Final operations unit cycle

q STR OP Store (output) data available

r -DA-AV Data not available

s -A-REG A register not in use

t -Q-REG Q register not in use

u -X0-RG X0 not in use

v -X1-RG X1 not in use

w -X2-RG X2 not in use

x -X3-RG X3 not in use

y -X4-RG X4 not in use

z -X5-RG X5 not in use

A -X6-RG X6 not in use

B -X7-RG X7 not in use

ICT TRACKER The current value of the instruction counter (PPR.IC). Since the
Control Unit and Operations Unit run asynchronously and overlap is usually
enabled, the value of ICT TRACKER may not be the address of the operations unit
instruction currently being executed.

\subsection{DECIMAL UNIT (DU) HISTORY REGISTERS - DPS AND L68}

Format: - 72 bits each

Decimal Unit History Register data is stored with the Store Central Processor
Register (scpr), TAG = 10, instruction. There is no format diagram because the
data is defined as individual bits.

Description:

A combination of 16 flags from the decimal unit. The 16 registers are handled
as a rotating queue controlled by the decimal unit history register counter.
The counter is always set to the number of the oldest entry and advances by one
for each history register reference (data entry or Store Central Processor
Register (scpr) instruction).

The decimal unit and the control unit run synchronously. There is a control
unit history register entry for every decimal unit history register entry and
vice versa (except for instruction fetch and EIS descriptor fetch cycles). If
the processor is not executing a decimal instruction, the decimal unit history
register entry shows an idle condition.

Function:

A decimal unit history register entry shows the conditions in the decimal unit
at the end of the control unit cycle to which it applies. The 16 registers hold
the conditions for the last 16 control unit cycles. Entries are made according
to controls set in the Mode Register.  (See Mode Register earlier in this
section.)

A minus (-) sign preceding the flag name indicates that the complement of the flag is shown.  Unused bits are set ON.

The meanings of the constituent flags are:

bit Flag Name Meaning

0 -FPOL Prepare operand length

l -FPOP Prepare operand pointer

2 -NEED-DESC Need descriptor

3 -SEL-ADR Select address register

4 -DLEN=DIRECT Length equals direct

5 -DFRST Descriptor processed for first time

6 -FEXR Extended register modification

7 -DLAST-FRST Last cycle of DFRST

8 -DDU-LDEA Decimal unit load

9 -DDU-STAE Decimal unit store

10 -DREDO Redo operation without pointer and length update

11 -DLVL$<$WD-SZ Load with count less than word size

12 -EXH Exhaust

13 DEND-SEQ End of sequence

14 -DEND End of instruction

15 -DU=RD+WRT Decimal unit write-back

16 -PTRA00 PR address bit 0

17 -PTRA01 PR address bit l

18 FA/Il Descriptor l active

19 FA/I2 Descriptor 2 active

20 FA/I3 Descriptor 3 active

21 -WRD Word operation

22 -NINE 9-bit character operation

23 -SIX 6-bit character operation

24 -FOUR 4-bit character operation

25 -BIT Bit operation

26 Unused

27 Unused

28 Unused

29 Unused

30 FSAMPL Sample for mid-instruction interrupt

31 -DFRST-CT Specified first count of a sequence

32 -ADJ-LENGTH Adjust length

33 -INTRPTD Mid-instruction interrupt

34 -INHIB Inhibit STC1 (force {``}STC0'')

35 Unused

36 DUD Decimal unit idle

37 -GDLDA Descriptor load gate A

38 -GDLDB Descriptor load gate B

39 -GDLDC Descriptor load gate C

40 NLD1 Prepare alignment count for first numeric operand load

41 GLDP1 Numeric operand one load gate

42 NLD2 Prepare alignment count for second numeric operand load

43 GLDP2 Numeric operand two load gate

44 ANLD1 Alphanumeric operand one load gate

45 ANLD2 Alphanumeric operand two load gate

46 LDWRT1 Load rewrite register one gate

47 LDWRT2 Load rewrite register two gate

48 -DATA-AVLDU Decimal unit data available

49 WRT1 Rewrite register one loaded

50 GSTR Numeric store gate

51 ANSTR Alphanumeric store gate

52 FSTR-OP-AV Operand available to be stored

53 -FEND-SEQ End sequence flag

54 -FLEN$<$128 Length less than 128

55 FGCH Character operation gate

56 FANPK Alphanumeric packing cycle gate

57 FEXMOP Execute MOP gate

58 FBLNK Blanking gate

59 Unused

60 DGBD Binary to decimal execution gate

61 DGDB Decimal to binary execution gate

62 DGSP Shift procedure gate

63 FFLTG Floating result flag

64 FRND Rounding flag

65 DADD-GATE Add/subtract execute gate

66 DMP+DV-GATE Multiply/divide execution gate

67 DXPN-GATE Exponent network execution gate

68 Unused

69 Unused

70 Unused

71 Unused

\subsection{DECIMAL/OPERATIONS UNIT (DU/OU) HISTORY REGISTERS DPS 8M}

Format: - 72 bits each

Even word of Y-pair as stored by Store Central Processor Register (scpr), TAG = 40

Odd word of Y-pair as stored by Store Central Processor Register (scpr), TAG = 40

Figure 3-27. Decimal/Operations (DU/OU) History Register Format - DPS 8M

Description:

A combination of 16 flags and registers from the operation unit and decimal unit. The 16 registers are handled as a rotating queue controlled by the operations unit history register counter. The counter is always set to the number of the oldest entry and advances by one for each history register reference (data entry or Store Central Processor Register (scpr) instruction).

The decimal unit and the control unit run synchronously. There is a control
unit history register entry for every decimal unit history register entry and
vice versa (except for instruction fetch and EIS descriptor fetch cycles). If
the processor is not executing a decimal instruction, the decimal unit history
register entry shows an idle condition.

Function:

An operations unit history register entry shows the conditions at the end of
the operations unit cycle to which it applies. The 16 registers hold the
conditions for the last 16 operations unit cycles. As the operations unit
performs various cycles in the execution of an instruction, it does not advance
the counter for each such cycle. The counter is advanced only at successful
completion of the instruction or if the instruction is aborted for a fault
condition. Entries are made according to controls set in the Mode Register.
(See Mode Register earlier in this section.)

The meanings of the constituent flags and registers are:

key Flag Name Meaning

a FANLD1 Alpha-num load desc l (complemented)

b FANLD2 Alpha-num load desc 2 (complemented)

c FANSTR Alpha-num store (complemented)

d FLDWRT1 Load re-write reg l (complemented)

e FLDWRT2 Load re-write reg 2 (complemented)

f FNLD1 Numeric load desc l (complemented)

g FNLD2 Numeric load desc 2 (complemented)

h NOSEQF End sequence flag

i FDUD Decimal unit idle (complemented)

j FGSTR General store flag (complemented)

k NOSEQ End of sequence (complemented)

l NINE 9-bit character operation

m SIX 6-bit character operation

n FOUR 4-bit character operation

o DUBIT Bit operation

p DUWORD Word operation

q PTR1 Select ptr l

r PTR2 Select ptr 2

s PRT3 Select ptr 3

t FPOP Prepare operand pointer

u GEAM Add timing gates (complemented)

v LPD12 Load pointer l or 2 (complemented)

w GEMAE Multiply gates A E (complemented)

x BTDS Binary to decimal gates (complemented)

y SP15 Align cycles (complemented)

z FSWEQ Single word sequence flag (complemented)

A FGCH Character cycle (complemented)

B DFRST Processing descriptor for first time

C EXH Exhaust

D FGADO Add cycle (complemented)

E INTRPTD Interrupted

F GLDP2 Load DP2

G GEMC Multiply gate C

H GBDA Binary to decimal gate A

I GSP5 Final align cycle

ICT Instruction counter (See NOTE below.)

RS OU op-code register (RS0-8)

IR Indicator register (IR):

J ZERO Zero indicator

K NEG Negative indicator

L CARRY Carry indicator

M OVFL Overflow indicator

N EOVFL Exponent overflow indicator

O EUFL Exponent underflow indicator

P OFLM Overflow mask indicator

Q HEX Hex mode indicator

R DTRGO Transfer go

NOTE: The current value of the instruction counter (PPR.IC). Since the control
unit and operations unit run asynchronously and overlap is usually enabled, the
value of ICT TRACKER may not be the address of the operations unit instruction
currently being executed.

\subsection{APPENDING UNIT (APU) HISTORY REGISTERS - DPS AND L68}

Format: - 72 bits each

Even word of Y-pair as stored by Store Central Processor Register (scpr), TAG = 00

Odd word of Y-pair as stored by Store Central Processor Register (scpr), TAG = 00

3

Figure 3-28. Appending Unit (APU) History Register Format - DPS and L68

Description:

A combination of 16 flags and registers from the appending unit. The 16
registers are handled as a rotating queue controlled by the appending unit
history register counter. The counter is always set to the number of the oldest
entry and advances by one for each history register reference (data entry or
Store Central Processor Register (scpr) instruction).

Function:

An appending unit history register entry shows the conditions in the appending
unit at the end of an address preparation cycle in appending mode. The 16
registers hold the conditions for the last 16 such address preparation cycles.
Entries are made according to controls set in the Mode Register. (See Mode
Register earlier in this section.)

The meanings of the constituent flags and registers are:

key Flag Name Meaning

ESN Effective segment number (TPR.TSR)

a BSY Data source for ESN

00 = from PPR.PSR

01 = from PRn.SNR

10 = from TPR.TSR

11 = not used

b FDSPTW Descriptor segment PTW fetch

c MDSPTW Descriptor segment PTW modification

d FSDWP SDW fetch from paged descriptor segment

e FPTW PTW fetch

f FPTW2 PTW+1 fetch (prepaging for certain EIS instructions)

g MPTW PTW modification

h FANP Final address fetch from nonpaged segment

i FAP Final address fetch from paged segment

j SDWAMM SDWAM match occurred

SDWAMR SDWAM register number if SDWAMM=1

k PTWAMM PTWAM match occurred

PTWAMR PTWAM register number if PTWAMM=1

l FLT Access violation or directed fault on this cycle

ADD 24-bit absolute main memory address from this cycle

TRR Ring number from this cycle (TPR.TRR)

m Multiple match error in SDWAM

n CA Segment is encacheable

p Multiple match error in PTWAM

r FHLD An access violation or directed fault is waiting

\subsection{APPENDING UNIT (APU) HISTORY REGISTERS -- DPS 8M}

Format: - 72 bits each

Even word of Y-pair as stored by Store Central Processor Register (scpr), TAG = 00

Odd word of Y-pair as stored by Store Central Processor Register (scpr), TAG = 00

Extended APU History Register:

Even word of Y-pair as stored by Store Central Processor Register (scpr), TAG = 10

Figure 3-29. Appending Unit (APU) History Register Format - DPS 8M

Description:

A combination of 64 flags and registers from the appending unit. The 64
registers are handled as a rotating queue controlled by the appending unit
history register counter. The counter is always set to the number of the oldest
entry and advances by one for each history register reference (data entry or
Store Central Processor Register (scpr) instruction).

Function:

An appending unit history register entry shows the conditions in the appending
unit at the end of an address preparation cycle in appending mode. The 64
registers hold the conditions for the last 64 such address preparation cycles.
Entries are made according to controls set in the Mode Register. (See Mode
Register earlier in this section.)

The meanings of the constituent flags and registers are:

key Flag Name Meaning

ESN Effective segment number

a PIA Page overflow

b PIA out of segment bounds

c FDSPTW Fetch descriptor segment PTW

d MDSPTW Descriptor segment PTW is modified

e FSDW Fetch SDW

f FPTW Fetch PTW

g FPTW2 Fetch pre-page PTW

h MPTW PTW modified

i FANP Final address nonpaged

j FAP Final address paged

k MTCHSDW SDW match found

l SDWMF SDW match found and used

BSY Data source for ESN

00 = from ppr.ic

01 = from prn.tsr

10 = from tpr.swr

11 = from tpr.ca

m MTCHPTW PTW match found (AM)

m1 PTWMF PTW match found (AM) and used

n PTWAM PTW AM direct address (ZCA bits 4-7)

o SDWMF SDW match found

RMA Read 24 bit memory address

p RTRR Temporary ring register

q SDWME SDW match error

r SDWLVL SDW match level count (0 = Level A)

s CACHE Cache used this cycle

t PTW match error

u PTWLVL PTW match level count (0 = level A)

v FLTHLD A directed fault or access violation fault is waiting

ZCA Computed address

INSTR Instruction executed

I Inhibit bit

MOD Instruction modifier

\subsection{CONFIGURATION SWITCH DATA - DPS AND L68}

Format: - 36 bits each

Data read by Read Switches (rsw), y = xxxxx0

Data read by Read Switches (rsw), y = xxxxx2

Data read by Read Switches (rsw), y = xxxxx1 (port A-D) or xxxxx3 (port E-H)

Data read by Read Switches (rsw), y = xxxxx4

Figure 3-30. Configuration Switch Data Formats - DPS and L68

Description:

The Read Switches (rsw) instruction provides the ability to interrogate various
switches and options on the processor maintenance and configuration panels. The
3 low-order bits of the computed address (TPR.CA) select the switches to be
read. High-order address bits are ignored. Data are placed in the A Register.

Read Switches (rsw), y = xxxxx1 reads data for ports A, B, C, and D. Read
Switches (rsw), y = xxxxx3 reads data for ports E, F, G, and H.

Function:

The meanings of the constituent fields are:

key Field Name Meaning

a CPU-Type Equals {``}00'' for a L68 or a DPS processor.

FLT BASE The seven MSB of the 12-bit fault base address

b dps\_option Processor option

0 = L68 processor

1 = DPS processor

c cache 2K cache option

0 = disabled

1 = enabled

d ext\_gcos GCOS mode extended memory option

0 = disabled

1 = enabled

CPU\_ID These bit positions have a configuration of {``}1110'' for a L68 or a
DPS CPU.

CPU Processor number from processor configuration panel number switches.

PORT A or E, etc.  Port data fields further substructured as:

ADR Address assignment switch setting for port

c Port enabled flag

d System initialize enabled flag

e Interlace enabled flag

MEM Coded memory size . . .

000 32K

001 64K

010 128K

011 256K

100 512K

101 1024K

110 2048K

111 4096K

A, B, etc.  Port data fields further substructured as:

f Interlace mode

0 = 4 word if interlace enabled for port

1 = 2 word if interlace enabled for port

g Main memory size

0 = full, all of MEM is configured

1 = half, half of MEM is configured

\subsection{CONFIGURATION SWITCH DATA - DPS 8M}

The following changes apply to the DPS 8M processor.

Format: - 36 bits each

Data read by Read Switches (rsw), y = xxxxx2

Data read by Read Switches (rsw), y = xxxxx1 (port A-D)

Figure 3-31. Configuration Switch Data Formats - DPS 8M

Description:

The Read Switches (rsw) instruction provides the ability to interrogate various
switches and options on the processor maintenance and configuration panels. The
two low-order bits of the computed address (TPR.CA) select the switches to be
read. High-order address bits are ignored. Data are placed in the A Register.

Read Switches (rsw), y = xxxxx1 reads data for ports A, B, C, and D.

Function:

The meanings of the constituent fields are:

key Field Name Meaning

a If the corresponding rsw 1 interface enabled flag, bit (e) is ON, then

0 = 4 word interfaces

1 = 2 word interfaces

For ports A - D

b Indicates processor type

00 = L68 or DPS Processor

01 = DPS 8M Processor

10 = reserved for future use

11 = reserved for future use

FLTBASE The seven MSB of the 12-bit fault base address

c ID prom

0 = id prom not installed

1 = id prom installed

d BCD option (Marketing designation)

1 = BCD option installed

e DPS option (Marketing designation)

1 = DPS option

f 8K cache

1 = 8K cache installed

g DPS 8M Processor type designation

1 = DPS 8/xxM

0 = DPS 8/xx

h GCOS/VMS switch position

1 = Virtual Mode

0 = GCOS Mode

i Current or new product line peripheral type

1 = NPL

0 = CPL

SPEED Processor speed options

0000 = 8/70

0100 = 8/52

CPU Processor number

ADR Address assignment switch setting for port

j Port enabled flag

k System initialize enabled flag

l Interface enabled flag

MEM Coded memory size:

000 32K

001 64K

010 128K

011 256K

100 512K

101 1024K

110 2048K

111 4096K

\subsection{CONTROL UNIT DATA}

Format: - 288 bits, 8 machine words

Data as stored by Store Control Unit (scu) instruction Word

Figure 3-32. Control Unit Data Format

Description:

A collection of flags and registers from the appending unit and the control
unit. In general, the data has valid meaning only when stored with the Store
Control Unit (scu) instruction as the first instruction of a fault or interrupt
trap pair.

Function:

The control unit data allows the processor to restart an instruction at the
point of interruption when it is interrupted by an access violation fault, a
directed fault, or (for certain EIS instructions) an interrupt. Directed faults
are intentional, and most access violation faults and interrupts are
recoverable. If the interruption is not recoverable, the control unit data
provides enough information to determine the exact nature of the error.

Instruction execution restarts immediately upon execution of a Restore Control
Unit (rcu) instruction referencing the Y-block8 area into which the control
unit data was stored.

Fields having an {``}x'' in the column headed L are not restored by the Restore
Control Unit (rcu) instruction.

The meanings of the constituent fields are:

Word key L Field Name Meaning

0 PRR Procedure ring register (PPR.PRR)

0 PSR Procedure segment register (PPR.PSR)

0 a P Privileged bit (PPR.P)

0 b XSF External segment flag

0 c x SDWAMM Match on SDWAM

0 d x SD-ON SDWAM enabled

0 e x PTWAMM Match on PTWAM

0 f x PT-ON PTWAM enabled

0 g x PI-AP Instruction fetch append cycle

0 h x DSPTW Fetch descriptor segment PTW

0 i x SDWNP Fetch SDW - nonpaged

0 j x SDWP Fetch SDW - paged

0 k x PTW Fetch PTW

0 l x PTW2 Fetch prepage PTW

0 m x FAP Fetch final address - paged

0 n x FANP Fetch final address - nonpaged

0 o x FABS Fetch final address - absolute

0 FCT Fault counter - counts retries

1 a x IRO For access violation fault - illegal ring order

x ISN For store fault - illegal segment number

1 b x ORB For access violation fault - out of execute bracket

x IOC For illegal procedure fault - illegal op code

1 c x E-OFF For access violation fault - execute bit is OFF

x IA+IM For illegal procedure fault - illegal address or modifier

1 d x ORB For access violation fault - out of read bracket

x ISP For illegal procedure fault - illegal slave procedure

1 e x R-OFF For access violation fault - read bit is OFF

x IPR For illegal procedure fault - illegal EIS digit

1 f x OWB For access violation fault - out of write bracket

x NEA For store fault - nonexistent address

1 g x W-OFF For access violation fault - write bit is OFF

x OOB For store fault - out of bounds (BAR mode)

1 h x NO GA For access violation fault - not a gate

1 i x OCB For access violation fault - out of call bracket

1 j x OCALL For access violation fault - outward call

1 k x BOC For access violation fault - bad outward call

1 l x PTWAM\_ER For access violation fault - on DPS 8M processors, a PTW
associative memory error. Not used on DPS/L68 processors.

1 m x CRT For access violation fault - cross ring transfer

1 n x RALR For access violation fault - ring alarm

1 o x SDWAM\_ER For access violation fault - on DPS 8M an SDW associative
memory error. An associative memory error on DPS/L68.

1 p x OOSB For access violation fault - out of segment bounds

1 q x PARU For parity fault - processor parity upper

1 r x PARL For parity fault - processor parity lower

1 s x ONC1 For operation not complete fault -- processor/system controller
sequence error \#1

1 t x ONC2 For operation not complete fault -- processor/system controller
sequence error \#2

1 x IA System controller illegal action lines (see Table 3-2)

1 x IACHN Illegal action processor port

1 x CNCHN For connect fault - connect processor port

1 x F/I ADDR Modulo 2 fault/interrupt vector address

1 u x F/I Fault/interrupt flag

0 = interrupt

1 = fault

2 TRR Temporary ring register (TPR.TRR)

2 TSR Temporary segment register (TPR.TSR)

PTW DPS 8M processors only; this field mbz on DPS/L68 processors:

2 a x PTWAM levels A, B enabled (enabled = 1)

2 b x PTWAM levels C, D enabled

2 c x PTWAM levels A, B match (match = 1)

2 d x PTWAM levels C, D match

SDW DPS 8M processors only; this field mbz on DPS/L68 processors:

2 e x SDWAM levels A, B enabled

2 f x SDWAM levels C, D enabled

2 g x SDWAM levels A, B match

2 h x SDWAM levels C, D match

2 CPU CPU number

2 DELTA Address increment for repeats

3 TSNA Pointer register number for non-EIS operands or for EIS operand \#1
further substructured as:

3 a PRNO Pointer register number

3 b ---- 1 = PRNO is valid

3 TSNB Pointer register number for EIS operand \#2 further substructured as for
TSNA above

3 TSNC Pointer register number for EIS operand \#3 further substructured as for
TSNA above

3 TEMP BIT Current bit offset (TPR.TBR)

4 IC Instruction counter (PPR.IC)

4 a ZERO Zero indicator

4 b NEG Negative indicator

4 c CARY Carry indicator

4 d OVFL Overflow indicator

4 e EOVF Exponent overflow indicator

4 f EUFL Exponent underflow indicator

4 g OFLM Overflow mask indicator

4 h TRO Tally runout indicator

4 i PAR Parity error indicator

4 j PARM Parity mask indicator

4 k -BM Not BAR mode indicator

4 l TRU EIS truncation indicator

4 m MIF Mid-instruction interrupt indicator

4 n ABS Absolute mode indicator

4 o HEX Hex mode indicator (DPS 8M processors only)

5 x CA Current computed address (TPR.CA) 5

a RF First cycle of all repeat instructions 5

b RPT Execute a Repeat (rpt) instruction

5 c RD Execute a Repeat Double (rpd) instruction

5 d RL Execute a Repeat Link (rpl) instruction

5 e POT Prepare operand tally.  This flag is up until the indirect then tally
address modifier is word of an indirect successfully fetched.

5 f PON Prepare operand no tally. This flag is up until the indirect word of a
return type transfer instruction is successfully fetched. It indicates that
there is no indirect chain even though an indirect fetch is being performed.

5 g XDE Execute instruction from Execute Double even pair

5 h XDO Execute instruction from Execute Double odd pair

5 i ITP Execute ITP indirect cycle

5 j RFI Restart this instruction

5 k ITS Execute ITS indirect cycle

5 l FIF Fault occurred during instruction fetch

5 CT HOLD Contents of the modifier holding register

6 Word 6 is the contents of the working instruction register and reflects
conditions at the exact point of address preparation when the fault or
interrupt occurred. The ADDRESS and TAG fields are replaced with data from
pointer registers, indirect pointers, and/or indirect words during each
indirect cycle. Each instruction of the current pair is moved to this register
before actual address preparation begins.

7 Meaning Word 7 is the contents of the instruction holding register. It
contains the odd word of the last instruction pair fetched from main memory.
Note that, primarily because of overlap, this instruction is not necessarily
paired with the instruction in word 6.

\subsection{DECIMAL UNIT DATA}

Format: - 288 bits, 8 machine words

Data as stored by Store Pointers and Lengths (spl) instruction

Figure 3-33. Decimal Unit Data Format

Description:

A collection of flags and registers from the decimal unit.

Function:

The decimal unit data allows the processor to restart an EIS instruction at the
point of interruption when it is interrupted by an access violation fault, a
directed fault, or (for certain EIS instructions) an interrupt. Directed faults
are intentional, and most access violation faults and interrupts are
recoverable.

The data are restored with the Load Pointers and Lengths (lpl) instruction.
Fields having an {``}x'' in the column headed L are not restored. When starting
(or restarting) execution of an EIS instruction, the decimal unit registers and
flags are not initialized from the operand descriptors if the mid-instruction
interrupt fault (MIF) indicator is set ON.

The meanings of the constituent flags and registers are:

Word L Field Name Meaning

0 Z All bit-string instruction results are zero

0 {\O} Negative overpunch found in 6-4 expanded move

0 CHTALLY The number of characters examined by the scm, scmr, scd, scdr, tct, or tctr instructions (up to the interrupt or match)

2 D1 PTR Address of the last double-word accessed by operand descriptor 1; bits 17-23 (bit-address) valid only for initial access

2,4,6 TA Alphanumeric type of operand descriptor 1,2,3

2 x I Decimal unit interrupted flag; a copy of the mid-instruction interrupt fault indicator

2,4,6 F First time; data in operand descriptor 1,2,3 is valid

2,4,6 A Operand descriptor 1,2,3 is active

3 LEVEL l Difference in the count of characters loaded into the processor and characters not acted upon

3 D1 RES Count of characters remaining in operand descriptor l

4 D2 PTR Address of the last double-word accessed by operand descriptor 2; bits 17-23 (bit-address) valid only for initial access

4,6 x R Last cycle performed must be repeated

5 LEVEL 2 Same as LEVEL 1, but used mainly for OP 2 information

5 D2 RES Count of characters remaining in operand descriptor 2

6 D3 PTR Address of the last double-word accessed by operand descriptor 3; bits 17-23 (bit-address) valid only for initial access

6 JMP Descriptor count; number of words to skip to find the next instruction following this multiword instruction

7 D3 RES Count of characters remaining in operand descriptor 3

